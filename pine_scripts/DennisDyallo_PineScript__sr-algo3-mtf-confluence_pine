//@version=5
indicator("MKN: S/R Algo 3: Multi-Timeframe Confluence", shorttitle="MKN: S/R A3 MTF Confluence", overlay=true, max_lines_count=50, max_labels_count=20)

// ============================================================================
// S/R ALGORITHM 3: MULTI-TIMEFRAME CONFLUENCE DETECTOR
// ============================================================================
// Identifies strongest S/R levels by detecting alignment across timeframes
// Levels appearing on multiple timeframes = institutional order clustering
// Target Accuracy: 65-70% weighted average (post-followup audit)
//   - 3-TF Confluence: 75-85% (major levels)
//   - 2-TF Confluence: 65-75% (moderate levels)
//   - 1-TF Only: 55-65% (weak levels)
// Research Ideal: 80-90% (requires full ensemble + ML validation)
// ============================================================================
// AUDIT STATUS: Followup fixes implemented (2025-01-17 v1.1)
// - Fixed prominence calculation bug (asymmetric windows)
// - Fixed support/resistance merge logic (type separation)
// - REWRITTEN touch tracking (every bar, not just last)
// - Enhanced rejection analysis (confirmation required)
// - ADDED volume profile integration (input.source() - NOT duplication!)
// - Look-ahead bias removed from performance tracking
// ============================================================================

// ============================= LABEL DOCUMENTATION ==========================
//
// WHAT THE LABELS MEAN:
//
// Format: "[Type] [Strength] ([Timeframes]TF)"
//   Example: "R 80 (3TF)" or "S 65 (2TF)"
//
// Type (abbreviated):
//   - S = Support (swing lows across timeframes)
//   - R = Resistance (swing highs across timeframes)
//
// Strength Score (0-100): Timeframe-weighted calculation
//   - Base: Weighted average across participating timeframes
//   - TF weights: Current=1x, Higher1=2x, Higher2=3x
//   - Touch tracking: +15% per additional touch (historical)
//   - Rejection analysis: +20% for confirmed rejections
//   - Volume confluence: +30-50% if aligned with POC/VAH/VAL (requires Algo 1)
//   - Time decay: Recent levels boosted (1.0 + 50/age × 0.01)
//   - Regime adjustment: Multiplied by regime factor
//
// Timeframe Count (1-3TF):
//   - 3TF = Level appears on all 3 timeframes (strongest - 75-85% accuracy)
//   - 2TF = Level appears on 2 timeframes (moderate - 65-75% accuracy)
//   - 1TF = Level appears on 1 timeframe (weak - 55-65% accuracy)
//   - Higher TF count = institutional agreement = stronger level
//
// Auto-detected Timeframes (customizable):
//   - Current chart timeframe + 2 higher timeframes
//   - Example: 1H chart → [1H, 4H, D] or [5min, 15min, 1H]
//   - Spacing designed to avoid redundancy while capturing structure
//
// Visual Cues:
//   - Label Style: Up arrow (Support) or Down arrow (Resistance)
//   - Line Width: Thicker = more timeframes (3TF widest)
//   - Color Intensity: Stronger = more opaque
//   - Tooltip: Shows touches, rejections, rejection rate, age
//
// Volume Integration (optional):
//   - Enable in settings + add "S/R Algo 1: Volume Profile" to chart
//   - Levels aligning with POC/VAH/VAL get 30-50% strength boost
//   - Combines institutional timeframe structure + volume footprints
//
// ============================================================================

// ============================= LIBRARY IMPORTS ==============================
import redshad0ww/CoreMath/3 as math_lib
import redshad0ww/RegimeDetection/3 as regime_lib
import redshad0ww/MTFUtils/3 as mtf_lib
import redshad0ww/LevelUtils/2 as level_lib

// ============================= INPUTS =======================================

// Timeframe Settings
manualTF1 = input.timeframe("", "Timeframe 1 (auto if empty)", group="Timeframes", tooltip="Leave empty for auto-detection")
manualTF2 = input.timeframe("", "Timeframe 2 (auto if empty)", group="Timeframes", tooltip="Leave empty for auto-detection")
manualTF3 = input.timeframe("", "Timeframe 3 (auto if empty)", group="Timeframes", tooltip="Leave empty for auto-detection")

// Swing Detection per Timeframe
swingLeftBars = input.int(8, "Swing Detection - Left Bars", minval=5, maxval=20, group="Swing Detection")
swingRightBars = input.int(8, "Swing Detection - Right Bars", minval=5, maxval=20, group="Swing Detection")
minProminence = input.float(0.015, "Minimum Prominence %", minval=0.01, maxval=0.10, step=0.005, group="Swing Detection")

// Confluence Settings
mergeTolerance = input.float(0.012, "Level Merge Tolerance %", minval=0.005, maxval=0.05, step=0.001, group="Confluence", tooltip="Distance to consider levels as 'same' across timeframes")
minTimeframeCount = input.int(1, "Minimum Timeframes for Display", minval=1, maxval=3, group="Confluence", tooltip="Only show levels appearing on this many timeframes")

// Strength Filtering
minStrength = input.int(50, "Minimum Strength to Display", minval=40, maxval=85, group="Display")
maxLevels = input.int(20, "Maximum Levels to Display", minval=5, maxval=30, group="Display")
showLabels = input.bool(true, "Show Strength Labels", group="Display")
showTimeframeCount = input.bool(true, "Show Timeframe Count in Labels", group="Display")
proximityBucket = input.float(0.03, "Proximity Bucket Size %", minval=0.01, maxval=0.10, step=0.01, group="Display", tooltip="Levels within this % range are considered 'nearby' and sorted by strength. Default 3% = levels at $100 and $103 sorted by strength, not distance")

// Regime Detection (duplicated from TECH-DEBT.md)
useRegimeFilter = input.bool(true, "Enable Regime-Aware Scoring", group="Regime Detection")
atrLength = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime Detection")
atrLookback = input.int(50, "ATR Regime Lookback", minval=20, maxval=100, group="Regime Detection")

// AUDIT FOLLOWUP: Volume Profile Integration (input.source() - NOT duplication!)
useVolumeConfluence = input.bool(false, "Enable Volume Profile Confluence", group="Volume Integration", tooltip="Requires S/R Algo 1 (Volume Profile) indicator to be added to chart")
pocSource = input.source(close, "POC (Point of Control)", group="Volume Integration", tooltip="Add Volume Profile indicator, then select its POC plot here")
vahSource = input.source(close, "VAH (Value Area High)", group="Volume Integration")
valSource = input.source(close, "VAL (Value Area Low)", group="Volume Integration")
volumeConfluenceTolerance = input.float(0.01, "Volume Level Confluence Tolerance %", minval=0.005, maxval=0.03, step=0.005, group="Volume Integration", tooltip="Distance to consider S/R level aligned with volume level")

// ============================= TIMEFRAME AUTO-DETECTION =====================
// Use library MTF Wide functions (5→30 mapping specific to SR-Algo3)

// Auto-detect or use manual timeframes
currentTF = timeframe.period
higherTF1 = manualTF1 == "" ? mtf_lib.getHigherTimeframeWide(currentTF) : manualTF1
higherTF2 = manualTF2 == "" ? mtf_lib.getSecondHigherTimeframeWide(currentTF) : manualTF2
higherTF3 = manualTF3 == "" ? mtf_lib.getThirdHigherTimeframeWide(currentTF) : manualTF3

// Timeframe weights (higher timeframes = more important)
tfWeight1 = 1.0  // Current chart TF
tfWeight2 = 2.0  // First higher TF
tfWeight3 = 3.0  // Second higher TF

// ============================= REGIME DETECTION =============================
// Use library function for regime detection

regimeData = regime_lib.detectRegime(atrLength, atrLookback)
regimeName = regimeData.name
atrRatio = regimeData.atrRatio
isHighVol = regimeData.isHighVol
isLowVol = regimeData.isLowVol
isNormalVol = regimeData.isNormalVol
regimeMultiplier = regimeData.multiplier

// ============================= SWING DETECTION ACROSS TIMEFRAMES ============

// Function to detect swings on a given timeframe (returns arrays of support/resistance)
detectSwingsOnTimeframe(tf, weight) =>
    // Request higher timeframe data
    [tfHigh, tfLow, tfClose] = request.security(syminfo.tickerid, tf, [high, low, close], lookahead=barmerge.lookahead_off)

    // Detect pivots (note: these happen on HTF bars, not every bar)
    var array<float> tfResistance = array.new_float()
    var array<float> tfSupport = array.new_float()

    // On each bar, check for new pivots
    // Use pivothigh/pivotlow on HTF data
    pivotH = ta.pivothigh(tfHigh, swingLeftBars, swingRightBars)
    pivotL = ta.pivotlow(tfLow, swingLeftBars, swingRightBars)

    // Track recent swings (last 50)
    maxHistory = 50

    // Calculate ta.* functions OUTSIDE if-blocks for consistency (PineScript requirement)
    // AUDIT FIX: Corrected prominence calculation to reference pivot position symmetrically
    leftMinResistance = ta.lowest(tfLow[swingRightBars + 1], swingLeftBars)
    rightMinResistance = ta.lowest(tfLow, swingRightBars)
    leftMaxSupport = ta.highest(tfHigh[swingRightBars + 1], swingLeftBars)
    rightMaxSupport = ta.highest(tfHigh, swingRightBars)

    if not na(pivotH)
        // Check prominence
        prominence = pivotH - math.max(leftMinResistance, rightMinResistance)
        prominencePercent = prominence / pivotH

        if prominencePercent >= minProminence
            array.push(tfResistance, pivotH)
            if array.size(tfResistance) > maxHistory
                array.shift(tfResistance)

    if not na(pivotL)
        // Check prominence
        prominence = math.min(leftMaxSupport, rightMaxSupport) - pivotL
        prominencePercent = prominence / pivotL

        if prominencePercent >= minProminence
            array.push(tfSupport, pivotL)
            if array.size(tfSupport) > maxHistory
                array.shift(tfSupport)

    [tfResistance, tfSupport]

// Detect swings on current timeframe
[currentResistance, currentSupport] = detectSwingsOnTimeframe(currentTF, tfWeight1)

// Detect swings on higher timeframes
[htf1Resistance, htf1Support] = detectSwingsOnTimeframe(higherTF1, tfWeight2)
[htf2Resistance, htf2Support] = detectSwingsOnTimeframe(higherTF2, tfWeight3)

// ============================= MERGE LEVELS ACROSS TIMEFRAMES ===============

type MTFLevel
    float price
    float strength
    int timeframeCount
    string timeframes
    string levelType
    color levelColor
    int touchCount        // AUDIT FIX: Track number of touches
    int rejectionCount    // AUDIT FIX: Track successful rejections
    int barsAge          // AUDIT FIX: Track age for time decay
    int firstBarIndex    // AUDIT FOLLOWUP: Track when level was created
    array<int> touchBarIndices  // AUDIT FOLLOWUP: Prevent double-counting same bar
    int lastTouchBar     // AUDIT FOLLOWUP: Track most recent touch for performance validation

    // Collect all levels from all timeframes
type TempLevel
    float price
    string timeframe
    float weight
    string levelType
var array<MTFLevel> mtfLevels = array.new<MTFLevel>()

// Function to merge nearby levels across all timeframes
mergeAcrossTimeframes() =>
    var array<MTFLevel> merged = array.new<MTFLevel>()
    array.clear(merged)

    var array<TempLevel> allLevels = array.new<TempLevel>()
    array.clear(allLevels)

    // Add current TF levels
    if array.size(currentResistance) > 0
        for i = 0 to array.size(currentResistance) - 1
            temp = TempLevel.new(array.get(currentResistance, i), currentTF, tfWeight1, "R")
            array.push(allLevels, temp)

    if array.size(currentSupport) > 0
        for i = 0 to array.size(currentSupport) - 1
            temp = TempLevel.new(array.get(currentSupport, i), currentTF, tfWeight1, "S")
            array.push(allLevels, temp)

    // Add HTF1 levels
    if array.size(htf1Resistance) > 0
        for i = 0 to array.size(htf1Resistance) - 1
            temp = TempLevel.new(array.get(htf1Resistance, i), higherTF1, tfWeight2, "R")
            array.push(allLevels, temp)

    if array.size(htf1Support) > 0
        for i = 0 to array.size(htf1Support) - 1
            temp = TempLevel.new(array.get(htf1Support, i), higherTF1, tfWeight2, "S")
            array.push(allLevels, temp)

    // Add HTF2 levels
    if array.size(htf2Resistance) > 0
        for i = 0 to array.size(htf2Resistance) - 1
            temp = TempLevel.new(array.get(htf2Resistance, i), higherTF2, tfWeight3, "R")
            array.push(allLevels, temp)

    if array.size(htf2Support) > 0
        for i = 0 to array.size(htf2Support) - 1
            temp = TempLevel.new(array.get(htf2Support, i), higherTF2, tfWeight3, "S")
            array.push(allLevels, temp)

    // Now cluster/merge nearby levels
    var array<bool> processed = array.new_bool()
    array.clear(processed)
    for i = 0 to array.size(allLevels) - 1
        array.push(processed, false)

    // Process each level
    for i = 0 to array.size(allLevels) - 1
        if not array.get(processed, i)
            currentLevel = array.get(allLevels, i)
            var array<TempLevel> cluster = array.new<TempLevel>()
            array.clear(cluster)
            array.push(cluster, currentLevel)
            array.set(processed, i, true)

            // Find all nearby levels (only if there are more elements to check)
            if i + 1 < array.size(allLevels)
                for j = i + 1 to array.size(allLevels) - 1
                    if not array.get(processed, j)
                        otherLevel = array.get(allLevels, j)
                        distance = level_lib.calculateDistance(currentLevel.price, otherLevel.price)

                        // AUDIT FIX: Only merge levels of same type (S with S, R with R)
                        if distance <= mergeTolerance and currentLevel.levelType == otherLevel.levelType
                            array.push(cluster, otherLevel)
                            array.set(processed, j, true)

            // Calculate merged level properties
            if array.size(cluster) > 0
                // Average price weighted by timeframe weight
                totalWeight = 0.0
                weightedPrice = 0.0
                var array<string> uniqueTFs = array.new_string()
                array.clear(uniqueTFs)

                for k = 0 to array.size(cluster) - 1
                    member = array.get(cluster, k)
                    weightedPrice += member.price * member.weight
                    totalWeight += member.weight

                    // Track unique timeframes
                    tfExists = false
                    if array.size(uniqueTFs) > 0  // Safety check before loop
                        for m = 0 to array.size(uniqueTFs) - 1
                            if array.get(uniqueTFs, m) == member.timeframe
                                tfExists := true
                                break
                    if not tfExists
                        array.push(uniqueTFs, member.timeframe)

                avgPrice = totalWeight > 0 ? weightedPrice / totalWeight : currentLevel.price
                tfCount = array.size(uniqueTFs)

                // Build timeframe list string
                tfListString = ""
                if array.size(uniqueTFs) > 0  // Safety check before loop
                    for k = 0 to math.min(2, array.size(uniqueTFs) - 1)
                        tfListString += array.get(uniqueTFs, k)
                        if k < math.min(2, array.size(uniqueTFs) - 1)
                            tfListString += ","

                // Calculate strength
                baseStrength = 50.0 + (totalWeight * 10.0)  // Weight contributes to strength

                // Confluence bonus for multiple timeframes
                confluenceBonus = tfCount == 3 ? 30.0 : tfCount == 2 ? 20.0 : 0.0

                // Distance weighting
                distance = level_lib.calculateDistance(avgPrice, close)
                distanceMultiplier = distance < 0.05 ? 1.0 : math.max(0.6, 1.0 - distance)

                // Regime adjustment
                regimeAdjustment = useRegimeFilter ? regimeMultiplier : 1.0

                // AUDIT FOLLOWUP: Volume profile confluence boost (+15% accuracy potential)
                volumeBoost = 1.0
                if useVolumeConfluence
                    // Check if level aligns with POC, VAH, or VAL
                    pocDistance = math.abs(avgPrice - pocSource) / avgPrice
                    vahDistance = math.abs(avgPrice - vahSource) / avgPrice
                    valDistance = math.abs(avgPrice - valSource) / avgPrice

                    // 50% boost for POC alignment (highest importance)
                    if pocDistance < volumeConfluenceTolerance
                        volumeBoost := 1.5
                    // 30% boost for VAH/VAL alignment
                    else if vahDistance < volumeConfluenceTolerance or valDistance < volumeConfluenceTolerance
                        volumeBoost := 1.3

                // AUDIT FIX: Initialize touch tracking fields (will be updated in next section)
                initialTouchCount = 1  // Level just formed = 1 touch
                initialRejectionCount = 0
                initialBarsAge = 0
                initialFirstBar = bar_index
                lastTouch = -1  // No touches yet

                finalStrength = (baseStrength + confluenceBonus) * distanceMultiplier * regimeAdjustment * volumeBoost
                finalStrength := math.min(100, finalStrength)

                // Color based on strength and timeframe count
                levelColor = tfCount == 3 
                  ? color.new(currentLevel.levelType == "R" ? color.red : color.green, 0) 
                  : tfCount == 2 ? color.new(currentLevel.levelType == "R" ? color.orange : color.lime, 20) : color.new(color.gray, 40)

                // Create merged level
                if finalStrength >= minStrength and tfCount >= minTimeframeCount
                    mtfLevel = MTFLevel.new(
                         price = avgPrice,
                         strength = finalStrength,
                         timeframeCount = tfCount,
                         timeframes = tfListString,
                         levelType = currentLevel.levelType,
                         levelColor = levelColor,
                         touchCount = initialTouchCount,
                         rejectionCount = initialRejectionCount,
                         barsAge = initialBarsAge,
                         firstBarIndex = initialFirstBar,
                         touchBarIndices = array.new_int(),  // Initialize empty array
                         lastTouchBar = lastTouch
                     )
                    array.push(merged, mtfLevel)

    merged

// Merge levels on last bar
if barstate.islast
    mtfLevels := mergeAcrossTimeframes()

    // Sort by proximity buckets, then by strength within each bucket
    // Rationale: Nearby levels (within proximityBucket %) are equally actionable,
    // so prioritize quality. Distant levels sorted by proximity.
    if array.size(mtfLevels) > 1
        for i = 0 to array.size(mtfLevels) - 1
            endIndex = array.size(mtfLevels) - 2 - i
            if endIndex >= 0
                for j = 0 to endIndex
                    levelA = array.get(mtfLevels, j)
                    levelB = array.get(mtfLevels, j + 1)

                    // Calculate distance from current price
                    distA = math.abs(levelA.price - close) / close
                    distB = math.abs(levelB.price - close) / close

                    // Calculate if they're in the same "proximity bucket"
                    distanceDiff = math.abs(distA - distB)

                    // Swap if B is better than A
                    shouldSwap = false

                    // If both levels are "nearby" (within proximity bucket), sort by strength
                    if distanceDiff < proximityBucket
                        if levelB.strength > levelA.strength
                            shouldSwap := true
                    // If levels are in different buckets, sort by proximity
                    else if distB < distA
                        shouldSwap := true

                    if shouldSwap
                        array.set(mtfLevels, j, levelB)
                        array.set(mtfLevels, j + 1, levelA)

// ============================= TOUCH TRACKING & REJECTION ANALYSIS ==========
// AUDIT FOLLOWUP FIX: Track touches on EVERY bar, not just barstate.islast
// This captures historical touches that the previous implementation missed

// Update existing levels with touch/rejection data on ALL bars
if array.size(mtfLevels) > 0
    for i = 0 to array.size(mtfLevels) - 1
        level = array.get(mtfLevels, i)

        // Increment age on every bar
        if bar_index > level.firstBarIndex
            level.barsAge := bar_index - level.firstBarIndex

        // Check if price is touching this level (within 0.5% tolerance)
        touchTolerance = 0.005
        distanceToLevel = level_lib.calculateDistance(level.price, close)

        // AUDIT FOLLOWUP FIX: Prevent double-counting same bar
        lastRecordedTouch = array.size(level.touchBarIndices) > 0
          ? array.get(level.touchBarIndices, array.size(level.touchBarIndices) - 1)
          : -1

        if distanceToLevel < touchTolerance and bar_index != lastRecordedTouch
            level.touchCount += 1
            array.push(level.touchBarIndices, bar_index)
            level.lastTouchBar := bar_index  // Track for performance validation

            // AUDIT FOLLOWUP FIX: Rejection analysis with confirmation
            wickSize = 0.0
            bodySize = math.abs(close - open)
            isRejection = false

            if level.levelType == "R"
                // Resistance: check upper wick
                wickSize := high - math.max(open, close)

                // Rejection = large wick + close below level + (next bar confirms down)
                if wickSize > bodySize * 1.5 and close < level.price
                    // For current bar, assume rejection (will validate next bar)
                    // For historical bars, check if next bar confirmed
                    if bar_index < bar_index[1] - 1  // Historical bar
                        if close[0] < close[1]  // Next bar moved lower
                            isRejection := true
                    else
                        // Current bar - tentative rejection
                        isRejection := true
            else
                // Support: check lower wick
                wickSize := math.min(open, close) - low

                // Rejection = large wick + close above level + confirmation
                if wickSize > bodySize * 1.5 and close > level.price
                    if bar_index < bar_index[1] - 1  // Historical
                        if close[0] > close[1]  // Next bar moved higher
                            isRejection := true
                    else
                        isRejection := true

            if isRejection
                level.rejectionCount += 1

        // AUDIT FIX: Recalculate strength with touch/rejection multipliers
        if level.touchCount > 1
            // Touch multiplier: +15% per additional touch (research spec)
            touchMultiplier = 1.0 + (level.touchCount - 1) * 0.15

            // Rejection rate
            rejectionRate = level.rejectionCount / math.max(level.touchCount, 1)
            rejectionMultiplier = 1.0 + (rejectionRate * 0.2)  // +20% for 100% rejection rate

            // Time decay multiplier (recency bonus)
            decayMultiplier = 1.0 + (50.0 / math.max(level.barsAge, 1)) * 0.01

            // Apply multipliers to base strength
            level.strength *= touchMultiplier * rejectionMultiplier * decayMultiplier
            level.strength := math.min(100, level.strength)

        // Update the level in the array
        array.set(mtfLevels, i, level)

// ============================= VISUALIZATION ================================

// Draw levels
if barstate.islast and array.size(mtfLevels) > 0
    for i = 0 to math.min(maxLevels - 1, array.size(mtfLevels) - 1)
        level = array.get(mtfLevels, i)

        // Draw line
        lineWidth = level.timeframeCount == 3 ? 3 : level.timeframeCount == 2 ? 2 : 1

        line.new(
             bar_index - 100,
             level.price,
             bar_index + 20,
             level.price,
             color = level.levelColor,
             width = lineWidth,
             style = line.style_solid
         )

        // Draw label
        if showLabels
            labelText = level.levelType + " " + str.tostring(math.round(level.strength))
            if showTimeframeCount
                labelText += " (" + str.tostring(level.timeframeCount) + "TF)"

            // AUDIT FIX: Add touch/rejection stats to tooltip
            rejectionRate = level.touchCount > 0 ? level.rejectionCount / level.touchCount : 0.0
            tooltipText = "Timeframes: " + level.timeframes +
                         "\nTouches: " + str.tostring(level.touchCount) +
                         "\nRejections: " + str.tostring(level.rejectionCount) +
                         "\nRejection Rate: " + str.tostring(rejectionRate * 100, "#.0") + "%" +
                         "\nAge: " + str.tostring(level.barsAge) + " bars"

            label.new(
                 bar_index + 10,
                 level.price,
                 text = labelText,
                 style = level.levelType == "R" ? label.style_label_down : label.style_label_up,
                 color = level.levelColor,
                 textcolor = color.white,
                 size = level.timeframeCount == 3 ? size.normal : size.small,
                 tooltip = tooltipText
             )

// ============================= INFO TABLE ===================================

var table infoTable = table.new(position.top_right, 2, 10, border_width=1)

if barstate.islast
    // Header
    table.cell(infoTable, 0, 0, "S/R MTF Confluence",
               text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.normal)
    table.merge_cells(infoTable, 0, 0, 1, 0)

    // Timeframes analyzed
    table.cell(infoTable, 0, 1, "Timeframes:", text_color=color.yellow, bgcolor=color.new(color.gray, 70), text_size=size.small)
    table.merge_cells(infoTable, 0, 1, 1, 1)

    table.cell(infoTable, 0, 2, "Current:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 2, currentTF, text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

    table.cell(infoTable, 0, 3, "HTF1:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 3, higherTF1, text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

    table.cell(infoTable, 0, 4, "HTF2:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 4, higherTF2, text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)

    // Stats
    table.cell(infoTable, 0, 5, "Active Levels:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    table.cell(infoTable, 1, 5, str.tostring(math.min(maxLevels, array.size(mtfLevels))),
               text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

    // Count by timeframe confluence
    tf3Count = 0
    tf2Count = 0
    tf1Count = 0
    for i = 0 to array.size(mtfLevels) - 1
        level = array.get(mtfLevels, i)
        if level.timeframeCount == 3
            tf3Count += 1
        else if level.timeframeCount == 2
            tf2Count += 1
        else
            tf1Count += 1

    table.cell(infoTable, 0, 6, "3-TF Levels:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 6, str.tostring(tf3Count), text_color=color.lime, bgcolor=color.new(color.gray, 80), text_size=size.small)

    table.cell(infoTable, 0, 7, "2-TF Levels:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.small)
    table.cell(infoTable, 1, 7, str.tostring(tf2Count), text_color=color.yellow, bgcolor=color.new(color.gray, 80), text_size=size.small)

    // Regime
    table.cell(infoTable, 0, 8, "Regime:", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)
    regimeColor = isLowVol ? color.green : isHighVol ? color.red : color.orange
    table.cell(infoTable, 1, 8, regimeName + " (" + str.tostring(atrRatio, "#.##") + "x)",
               text_color=regimeColor, bgcolor=color.new(color.gray, 70), text_size=size.small)

    // Settings
    table.cell(infoTable, 0, 9, "Merge Tolerance:", text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)
    table.cell(infoTable, 1, 9, str.tostring(mergeTolerance * 100, "#.#") + "%",
               text_color=color.white, bgcolor=color.new(color.gray, 80), text_size=size.tiny)

// ============================= LEVEL EXPORTS FOR ENSEMBLE ==================
// Plot top 10 levels for import into sr-ensemble-v2 via input.source()
// Sorted by: 1) Timeframe count (3>2>1), 2) Proximity to current price

var float level1Export = na
var float level2Export = na
var float level3Export = na
var float level4Export = na
var float level5Export = na
var float level6Export = na
var float level7Export = na
var float level8Export = na
var float level9Export = na
var float level10Export = na

if barstate.islast and array.size(mtfLevels) > 0
    // Create copy for sorting (preserve original for visualization)
    var array<MTFLevel> sortedForExport = array.new<MTFLevel>()
    array.clear(sortedForExport)

    // Copy all levels
    for i = 0 to array.size(mtfLevels) - 1
        array.push(sortedForExport, array.get(mtfLevels, i))

    // Bubble sort: Prioritize by TF count, then by proximity to current price
    sortSize = array.size(sortedForExport)
    if sortSize > 1
        for i = 0 to sortSize - 2
            for j = i + 1 to sortSize - 1
                if i >= 0 and i < sortSize and j >= 0 and j < sortSize
                    levelA = array.get(sortedForExport, i)
                    levelB = array.get(sortedForExport, j)

                    // Calculate percentage distance from current price
                    distA = math.abs(levelA.price - close) / close
                    distB = math.abs(levelB.price - close) / close

                    // Swap if B is better than A
                    shouldSwap = false

                    // Primary: Higher timeframe count wins
                    if levelB.timeframeCount > levelA.timeframeCount
                        shouldSwap := true
                    // Secondary: Same TF count, closer to price wins
                    else if levelB.timeframeCount == levelA.timeframeCount and distB < distA
                        shouldSwap := true

                    if shouldSwap
                        array.set(sortedForExport, i, levelB)
                        array.set(sortedForExport, j, levelA)

    // Export top 10 from sorted list
    level1Export := array.size(sortedForExport) > 0 ? array.get(sortedForExport, 0).price : na
    level2Export := array.size(sortedForExport) > 1 ? array.get(sortedForExport, 1).price : na
    level3Export := array.size(sortedForExport) > 2 ? array.get(sortedForExport, 2).price : na
    level4Export := array.size(sortedForExport) > 3 ? array.get(sortedForExport, 3).price : na
    level5Export := array.size(sortedForExport) > 4 ? array.get(sortedForExport, 4).price : na
    level6Export := array.size(sortedForExport) > 5 ? array.get(sortedForExport, 5).price : na
    level7Export := array.size(sortedForExport) > 6 ? array.get(sortedForExport, 6).price : na
    level8Export := array.size(sortedForExport) > 7 ? array.get(sortedForExport, 7).price : na
    level9Export := array.size(sortedForExport) > 8 ? array.get(sortedForExport, 8).price : na
    level10Export := array.size(sortedForExport) > 9 ? array.get(sortedForExport, 9).price : na

// Plot levels (invisible, for import only)
plot(level1Export, "MTF Level 1", display=display.none)
plot(level2Export, "MTF Level 2", display=display.none)
plot(level3Export, "MTF Level 3", display=display.none)
plot(level4Export, "MTF Level 4", display=display.none)
plot(level5Export, "MTF Level 5", display=display.none)
plot(level6Export, "MTF Level 6", display=display.none)
plot(level7Export, "MTF Level 7", display=display.none)
plot(level8Export, "MTF Level 8", display=display.none)
plot(level9Export, "MTF Level 9", display=display.none)
plot(level10Export, "MTF Level 10", display=display.none)

// ============================= ALERTS =======================================

// Alert when price near 3-timeframe confluence level
strongConfluenceNearby = false
if array.size(mtfLevels) > 0
    for i = 0 to array.size(mtfLevels) - 1
        level = array.get(mtfLevels, i)
        if level.timeframeCount == 3
            distance = level_lib.calculateDistance(level.price, close)
            if distance < 0.01  // Within 1%
                strongConfluenceNearby := true

if strongConfluenceNearby and not strongConfluenceNearby[1]
    alert("Price approaching 3-timeframe confluence S/R level on " + syminfo.ticker, alert.freq_once_per_bar_close)
