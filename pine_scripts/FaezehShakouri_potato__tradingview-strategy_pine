//@version=5
strategy("Portfolio Rebalancing Strategy", overlay=false, initial_capital=10000, default_qty_type=strategy.percent_of_equity, commission_type=strategy.commission.percent, commission_value=0.1)

// ============================================================================
// INPUTS
// ============================================================================

// Portfolio Configuration
asset1Weight = input.float(50.0, "Asset 1 Weight (%)", minval=0, maxval=100, step=1, group="Portfolio Allocation")
asset2Weight = input.float(50.0, "Asset 2 Weight (%)", minval=0, maxval=100, step=1, group="Portfolio Allocation")

// Rebalancing Parameters
rebalanceThreshold = input.float(5.0, "Rebalance Threshold (%)", minval=0.5, maxval=20, step=0.5, group="Rebalancing", tooltip="Trigger rebalance when allocation drifts by this percentage")
useTimeRebalance = input.bool(false, "Enable Time-Based Rebalancing", group="Rebalancing")
rebalanceDays = input.int(30, "Rebalance Every (Days)", minval=1, maxval=365, group="Rebalancing")

// Asset Selection (for display purposes)
asset1Name = input.string("BTC", "Asset 1 Symbol", group="Display")
asset2Name = input.string("ETH", "Asset 2 Symbol", group="Display")

// ============================================================================
// VALIDATION
// ============================================================================

if (asset1Weight + asset2Weight != 100)
    runtime.error("Asset weights must sum to 100%")

// ============================================================================
// STATE VARIABLES
// ============================================================================

var float asset1Units = 0.0
var float asset2Units = 0.0
var int rebalanceCount = 0
var int lastRebalanceBar = 0
var bool isInitialized = false

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Get prices for both assets (assuming this is run on a chart with price data)
// For TradingView, you'll need to add the second asset as a security
asset1Price = close // Primary chart asset
asset2Price = request.security(syminfo.tickerid, timeframe.period, close) // You'll need to modify this

// Calculate portfolio value and allocations
calcPortfolioValue(a1Units, a1Price, a2Units, a2Price) =>
    a1Units * a1Price + a2Units * a2Price

calcAllocation(assetUnits, assetPrice, totalValue) =>
    if totalValue > 0
        (assetUnits * assetPrice / totalValue) * 100
    else
        0.0

// Check if rebalancing is needed
needsRebalancing(currentAlloc, targetAlloc, threshold) =>
    math.abs(currentAlloc - targetAlloc) > threshold

// ============================================================================
// MAIN STRATEGY LOGIC
// ============================================================================

// Initialize portfolio on first bar
if not isInitialized and barstate.isfirst
    capital = strategy.initial_capital
    asset1Value = capital * (asset1Weight / 100)
    asset2Value = capital * (asset2Weight / 100)
    
    asset1Units := asset1Value / asset1Price
    asset2Units := asset2Value / asset2Price
    isInitialized := true
    lastRebalanceBar := bar_index

// Calculate current state
totalValue = calcPortfolioValue(asset1Units, asset1Price, asset2Units, asset2Price)
currentAsset1Alloc = calcAllocation(asset1Units, asset1Price, totalValue)
currentAsset2Alloc = calcAllocation(asset2Units, asset2Price, totalValue)

// Check rebalancing conditions
shouldRebalanceThreshold = needsRebalancing(currentAsset1Alloc, asset1Weight, rebalanceThreshold) or 
                           needsRebalancing(currentAsset2Alloc, asset2Weight, rebalanceThreshold)

barsSinceRebalance = bar_index - lastRebalanceBar
shouldRebalanceTime = useTimeRebalance and (barsSinceRebalance >= rebalanceDays)

shouldRebalance = shouldRebalanceThreshold or shouldRebalanceTime

// Execute rebalancing
if shouldRebalance and not barstate.isfirst
    // Calculate target values
    targetAsset1Value = totalValue * (asset1Weight / 100)
    targetAsset2Value = totalValue * (asset2Weight / 100)
    
    // Calculate new units
    newAsset1Units = targetAsset1Value / asset1Price
    newAsset2Units = targetAsset2Value / asset2Price
    
    // Calculate trades needed
    asset1Trade = newAsset1Units - asset1Units
    asset2Trade = newAsset2Units - asset2Units
    
    // Update units
    asset1Units := newAsset1Units
    asset2Units := newAsset2Units
    
    // Update counters
    rebalanceCount += 1
    lastRebalanceBar := bar_index
    
    // Plot rebalance event
    label.new(bar_index, totalValue, "Rebalance #" + str.tostring(rebalanceCount), 
              color=color.blue, style=label.style_label_down, size=size.small)

// ============================================================================
// PLOTTING
// ============================================================================

// Plot portfolio value
plot(totalValue, "Portfolio Value", color=color.new(color.blue, 0), linewidth=2)

// Plot allocations
plot(currentAsset1Alloc, asset1Name + " Allocation %", color=color.orange, linewidth=1)
plot(currentAsset2Alloc, asset2Name + " Allocation %", color=color.purple, linewidth=1)

// Plot target allocations as reference lines
hline(asset1Weight, "Target " + asset1Name, color=color.new(color.orange, 70), linestyle=hline.style_dashed)
hline(asset2Weight, "Target " + asset2Name, color=color.new(color.purple, 70), linestyle=hline.style_dashed)

// Plot rebalancing threshold bands
hline(asset1Weight + rebalanceThreshold, "Upper Threshold", color=color.new(color.red, 80), linestyle=hline.style_dotted)
hline(asset1Weight - rebalanceThreshold, "Lower Threshold", color=color.new(color.red, 80), linestyle=hline.style_dotted)

// ============================================================================
// STATISTICS TABLE
// ============================================================================

if barstate.islast
    var table statsTable = table.new(position.top_right, 2, 8, border_width=1)
    
    // Headers
    table.cell(statsTable, 0, 0, "Metric", bgcolor=color.new(color.gray, 80), text_color=color.white)
    table.cell(statsTable, 1, 0, "Value", bgcolor=color.new(color.gray, 80), text_color=color.white)
    
    // Stats
    initialCapital = strategy.initial_capital
    finalValue = totalValue
    totalReturn = ((finalValue - initialCapital) / initialCapital) * 100
    
    table.cell(statsTable, 0, 1, "Initial Capital", text_color=color.white)
    table.cell(statsTable, 1, 1, "$" + str.tostring(initialCapital, "#,###.##"), text_color=color.white)
    
    table.cell(statsTable, 0, 2, "Final Value", text_color=color.white)
    table.cell(statsTable, 1, 2, "$" + str.tostring(finalValue, "#,###.##"), text_color=color.white)
    
    table.cell(statsTable, 0, 3, "Total Return", text_color=color.white)
    table.cell(statsTable, 1, 3, str.tostring(totalReturn, "#.##") + "%", 
               text_color=totalReturn >= 0 ? color.green : color.red)
    
    table.cell(statsTable, 0, 4, "Rebalances", text_color=color.white)
    table.cell(statsTable, 1, 4, str.tostring(rebalanceCount), text_color=color.white)
    
    table.cell(statsTable, 0, 5, asset1Name + " Allocation", text_color=color.white)
    table.cell(statsTable, 1, 5, str.tostring(currentAsset1Alloc, "#.##") + "%", text_color=color.orange)
    
    table.cell(statsTable, 0, 6, asset2Name + " Allocation", text_color=color.white)
    table.cell(statsTable, 1, 6, str.tostring(currentAsset2Alloc, "#.##") + "%", text_color=color.purple)
    
    table.cell(statsTable, 0, 7, asset1Name + " Units", text_color=color.white)
    table.cell(statsTable, 1, 7, str.tostring(asset1Units, "#.#####"), text_color=color.white)

// ============================================================================
// ALERTS
// ============================================================================

if shouldRebalance
    alert("Portfolio rebalancing triggered! " + asset1Name + ": " + str.tostring(currentAsset1Alloc, "#.##") + "% | " + 
          asset2Name + ": " + str.tostring(currentAsset2Alloc, "#.##") + "%", alert.freq_once_per_bar)

