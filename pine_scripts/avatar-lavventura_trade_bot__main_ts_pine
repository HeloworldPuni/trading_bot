//@version=4
strategy(title="alper", shorttitle="alper", overlay=false,
     calc_on_order_fills=false, initial_capital=300, default_qty_value=400,
     default_qty_type=strategy.cash, calc_on_every_tick=false, pyramiding=0,
     currency=currency.USD, commission_type=strategy.commission.percent,
     commission_value=0.1)


fromMonth = input(5, "Backtest Start Month")
fromDay = input(22)
// // //
thruMonth = input(12, "Backtest Stop Month")
thruDay = input(30, "Backtest Stop Day")

fromYear = input(2021, "Backtest Start Year")
thruYear = input(2021, "Backtest Stop Year")

// WaveTrend
// =========
n1 = input(9, "Channel Length")   // 10
n2 = input(20, "Average Length")  // 21
// Squeeze Momentum Strategy
// =========================
length = input(14, title="BB Length") //////////////////////// default: 20
mult = input(2.0, title="BB MultFactor")
lengthKC = input(17, title="KC Length") /////////////////////// default: 20
mult_kc = input(1.5, title="KC MultFactor")
//FILTERS
useMomAverage = input(true, title="Filter for Momenutum value", type=input.bool)
MomentumMin = input(20, title="Min for momentum")
// RSI-divergence
src_fast = close, len_fast = input(5, minval=1, title="Length Fast RSI")
src_slow = close, len_slow = input(14,minval=1, title="Length Slow RSI")
// ============================================================================
testPeriodStart = timestamp(fromYear, fromMonth, fromDay, 0, 0)
testPeriodStop  = timestamp(thruYear, thruMonth, thruDay, 0, 0)
start           = timestamp(fromYear, fromMonth, fromDay, 04, 00)  // backtest start window
finish          = timestamp(thruYear, thruMonth, thruDay, 23, 59)  // backtest finish window
window() => time >= start and time <= finish ? true : false

// WaveTrend
// =========
obLevel1 = input(70, "Over Bought Level 1")
obLevel2 = input(53, "Over Bought Level 2")
osLevel1 = input(-70, "Over Sold Level 1")
osLevel2 = input(-53, "Over Sold Level 2")

ap = hlc3
esa = ema(ap, n1)
d = ema(abs(ap - esa), n1)
ci = (ap - esa) / (0.015 * d)
tci = ema(ci, n2)
wt1 = tci
wt2 = sma(wt1, 4)

plot(obLevel1, color=color.red)
plot(osLevel1, color=color.green)
plot(obLevel2, color=color.red, style=3)
plot(osLevel2, color=color.green, style=3)
plot(wt1, color=color.green)
plot(wt2, color=color.red)
plot(wt1-wt2, color=color.blue, style=plot.style_area, transp=80)

plot(cross(wt1, wt2) ? wt2 : na, color=color.black , style=plot.style_circles, linewidth=3)
plot(cross(wt1, wt2) ? wt2 : na, color = (wt2 > wt1 ? color.red : color.lime) , style=plot.style_circles, linewidth=2)
barcolor(cross(wt1, wt2) ? (wt2 > wt1 ? color.aqua : color.yellow) : na)

wt1_past_1 = wt1[1]
wt2_past_1 = wt2[1]
divcrosslong  = wt1 < wt2
divcrossshort = wt1 > wt2
_divcrosslong  = divcrosslong and wt1_past_1 > wt2_past_1
_divcrossshort = divcrossshort and wt1_past_1 < wt2_past_1
plot(cross(wt1, wt2) ? wt2 : na, color = (wt2 - wt1 > 0 ? color.red : color.lime) , style=plot.style_circles, linewidth = 2)

// Squeeze Momentum Strategy
// =========================
// Calculate BB
src = ohlc4
ma_1 = sma(src, length)
ma_2 = sma(src, lengthKC)
range_ma = sma(high - low, lengthKC)
dev = mult * stdev(src, length)
upper_bb = ma_1 + dev
lower_bb = ma_1 - dev
upper_kc = ma_2 + range_ma * mult_kc
lower_kc = ma_2 - range_ma * mult_kc
sqz_on = lower_bb > lower_kc and upper_bb < upper_kc

sqz_off = lower_bb < lower_kc and upper_bb > upper_kc
no_sqz = sqz_on == false and sqz_off == false
val = linreg(src - avg(avg(highest(hl2, lengthKC), lowest(low, lengthKC)), sma(hl2, lengthKC)), lengthKC, 0)
bcolor = iff(val > 0, iff(val > nz(val[1]), color.lime, color.green), iff(val < nz(val[1]), color.red, color.maroon))
scolor = no_sqz ? color.blue : sqz_on ? color.black : color.orange

dodo = scolor == color.blue
//LOGIC //momentum filter
filterMom = useMomAverage ? abs(val) > MomentumMin / 100000 ? true : false : true

//standard condition
longCondition = scolor[1] != color.aqua and scolor == color.aqua and bcolor == color.lime and filterMom
exitLongCondition = bcolor == color.green
shortCondition = scolor[1] != color.aqua and scolor == color.aqua and bcolor == color.red and filterMom
exitShortCondition = bcolor == color.maroon
//====================================================================================================
// RSI-divergence
up_fast = rma(max(change(src_fast), 0), len_fast)
down_fast = rma(-min(change(src_fast), 0), len_fast)
rsi_fast = down_fast == 0 ? 100 : up_fast == 0 ? 0 : 100 - (100 / (1 + up_fast / down_fast))
up_slow = rma(max(change(src_slow), 0), len_slow)
down_slow = rma(-min(change(src_slow), 0), len_slow)
rsi_slow = down_slow == 0 ? 100 : up_slow == 0 ? 0 : 100 - (100 / (1 + up_slow / down_slow))
divergence = rsi_fast - rsi_slow
band = hline(0)
rsi_divlong = divergence > 0.11
rsi_divshort = divergence < 0

_obLevel1 = 95

is_long  = (strategy.position_size > 0)
is_short  = (strategy.position_size < 0)

// is_alper = (val < 0.00001 and val > -0.00001) and sqz_on
ss = sqz_on[1] and sqz_on[2] and sqz_on[3] and sqz_on[4] and sqz_on[5] and sqz_on[6] and sqz_on[7] and sqz_on[8] and sqz_on[9] and sqz_on[10] and sqz_on[11] and sqz_on[12] and sqz_on[13] and sqz_on[14] and sqz_on[15] and sqz_on[16] and sqz_on[17] and sqz_on[18] and sqz_on[19] and sqz_on[20] and sqz_on[21] and sqz_on[22] and sqz_on[23] and sqz_on[24] and sqz_on[25] and sqz_on[26]

is_long_pos_in_profit=strategy.position_avg_price > close and is_long and sqz_on // try: divcrosslong enable if less than the long position
is_short_pos_in_profit=strategy.position_avg_price < close and is_short and sqz_on

net_volume = sign(change(close)) * volume
_nz = nz(volume)
check_nz = _nz > 9500000

// === GENERAL INPUTS ===
// short ma
maFastSource   = input(defval = open, title = "Fast MA Source")
maFastLength   = input(defval = 14, title = "Fast MA Period", minval = 1)
// long ma
maSlowSource   = input(defval = open, title = "Slow MA Source")
maSlowLength   = input(defval = 21, title = "Slow MA Period", minval = 1)

// === STRATEGY RELATED INPUTS ===
tradeInvert     = input(defval = false, title = "Invert Trade Direction?")
inpTakeProfit   = input(defval = 2000, title = "Take Profit", minval = 0)
inpStopLoss     = input(defval = 450, title = "Stop Loss", minval = 0)
inpTrailStop    = input(defval = 100, title = "Trailing Stop Loss", minval = 0)
inpTrailOffset  = input(defval = 0, title = "Trailing Stop Loss Offset", minval = 0)

// === RISK MANAGEMENT VALUE PREP ===
// if an input is less than 1, assuming not wanted so we assign 'na' value to disable it.
useTakeProfit   = inpTakeProfit  >= 1 ? inpTakeProfit  : na
useStopLoss     = inpStopLoss    >= 1 ? inpStopLoss    : na
useTrailStop    = inpTrailStop   >= 1 ? inpTrailStop   : na
useTrailOffset  = inpTrailOffset >= 1 ? inpTrailOffset : na

// === SERIES SETUP ===
/// a couple of ma's..
maFast = ema(maFastSource, maFastLength)
maSlow = ema(maSlowSource, maSlowLength)

// === LOGIC ===
// is fast ma above slow ma?
aboveBelow = maFast >= maSlow ? true : false
// are we inverting our trade direction?
tradeDirection = tradeInvert ? aboveBelow ? false : true : aboveBelow ? true : false

// === STRATEGY - LONG POSITION EXECUTION ===
enterLong() => not tradeDirection[1] and tradeDirection // functions can be used to wrap up and work out complex conditions
exitLong() => tradeDirection[1] and not tradeDirection

//STRATEGY - SHORT POSITION EXECUTION
enterShort() => tradeDirection[1] and not tradeDirection
exitShort() => not tradeDirection[1] and tradeDirection

strategy.entry("Long", strategy.long, when=window() and divcrossshort and rsi_divlong)
strategy.close("Long", when=window() and _divcrosslong and rsi_divlong)
//
strategy.entry("Short",strategy.short, when=window() and divcrosslong and rsi_divshort)
strategy.close("Short", when=window() and _divcrossshort and rsi_divshort)
//
strategy.exit("Exit Long", from_entry = "Long", profit = useTakeProfit, loss = useStopLoss, trail_points = useTrailStop, trail_offset = useTrailOffset)
strategy.exit("Exit Short", from_entry = "Short", profit = useTakeProfit, loss = useStopLoss, trail_points = useTrailStop, trail_offset = useTrailOffset)
// {{ticker}},{{strategy.order.action}},{{strategy.market_position}},{{strategy.prev_market_position}},{{timenow}},{{close}}
