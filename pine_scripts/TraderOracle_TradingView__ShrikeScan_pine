//@version=6
import TradingView/ta/10
// vim: syntax=pine 
indicator("Shrike Scan", overlay=true)

iBBThreshold = input.float(0.0015, minval=0.0, title="Bollinger Lower Threshold", tooltip="0.003 for daily, 0.0015 for 30 min candles", group="General Settings")
RSILower = input.int(25, minval=1, title="RSI Lower Threshold", tooltip="Normally 25", group="General Settings")
RSIUpper  = input.int(72, minval=1, title="RSI Upper Threshold", tooltip="Normally 75", group="General Settings")

smEMA = input.int(21, "Standard EMA", minval=1, group="Indicator Settings")
bigEMA = input.int(200, "Longer EMA", minval=1, group="Indicator Settings")
rsiLen = input.int(14, "RSI Length", minval=1, group="Indicator Settings")
bbLength = input.int(20, "Bollinger Length",  minval=1, group="Indicator Settings")
bbMultiplier = input.float(2, "Bollinger Multiplier", minval=0.1, step=0.1, group="Indicator Settings")
sensitivity = input.int(150, title="Sensitivity", group="Indicator Settings")
atrTP = input.float(1.6, title="ATR Multiplier for Take Profit")

//#region SYMBOLS
var symbols = array.from("NASDAQ:AAPL", "NYSE:MSFT", "NASDAQ:GOOGL", "NASDAQ:GOOG")
//#endregion

// <editor-fold desc="FUNCTIONS">
CreateAlert(s, sym, cc, tp) =>
    why = s + " on " + sym + " at " + str.tostring(cc) + ". tp: " + str.tostring(tp)
    result = "{ content: '" + s + " on " + sym + " at " + str.tostring(cc) + ". tp: " + str.tostring(tp) + "'}"
    result

BBUpper0(len, m) =>
    float basis = ta.sma(close, len)
    float dev = m * ta.stdev(close, len)
    basis + dev

BBLower0(len, m) =>
    float basis = ta.sma(close, len)
    float dev = m * ta.stdev(close, len)
    basis - dev

BBUpper1(len, m) =>
    float basis = ta.sma(close[1], len)
    float dev = m * ta.stdev(close[1], len)
    basis + dev

BBLower1(len, m) =>
    float basis = ta.sma(close[1], len)
    float dev = m * ta.stdev(close[1], len)
    basis - dev

calc_macd0() =>
    fastMA = ta.ema(close, 20)
    slowMA = ta.ema(close, 40)
    fastMA - slowMA

calc_macd1() =>
    fastMA = ta.ema(close[1], 20)
    slowMA = ta.ema(close[1], 40)
    fastMA - slowMA

Trampoline() =>
    result = 0
    isRed = close < open
    isGreen = close > open

    basisBB = ta.sma(close, 20)
    devBB = 2.0 * ta.stdev(close, 20)
    upperBB = basisBB + devBB
    lowerBB = basisBB - devBB
    downBB = low < lowerBB or high < lowerBB
    upBB = low > upperBB or high > upperBB
    bbw = (upperBB - lowerBB) / basisBB

    up = ta.rma(math.max(ta.change(close), 0), 14)
    down = ta.rma(-math.min(ta.change(close), 0), 14)
    rsiM = down == 0 ? 100 : up == 0 ? 0 : 100 - (100 / (1 + up / down))

    back1 = isRed[1] and rsiM[1] <= 25 and close[1] < lowerBB[1] and bbw[1] > 0.0015
    back2 = isRed[2] and rsiM[2] <= 25 and close[2] < lowerBB[2] and bbw[2] > 0.0015
    back3 = isRed[3] and rsiM[3] <= 25 and close[3] < lowerBB[3] and bbw[3] > 0.0015
    back4 = isRed[4] and rsiM[4] <= 25 and close[4] < lowerBB[4] and bbw[4] > 0.0015
    back5 = isRed[5] and rsiM[5] <= 25 and close[5] < lowerBB[5] and bbw[5] > 0.0015

    for1 = isGreen[1] and rsiM[1] >= 72 and close[1] > upperBB[1] and bbw[1] > 0.0015
    for2 = isGreen[2] and rsiM[2] >= 72 and close[2] > upperBB[2] and bbw[2] > 0.0015
    for3 = isGreen[3] and rsiM[3] >= 72 and close[3] > upperBB[3] and bbw[3] > 0.0015
    for4 = isGreen[4] and rsiM[4] >= 72 and close[4] > upperBB[4] and bbw[4] > 0.0015
    for5 = isGreen[5] and rsiM[5] >= 72 and close[5] > upperBB[5] and bbw[5] > 0.0015

    weGoUp = isGreen and (back1 or back2 or back3 or back4 or back5) and (high > high[1])
    upThrust = weGoUp and not weGoUp[1] and not weGoUp[2] and not weGoUp[3] and not weGoUp[4]
    weGoDown = isRed and (for1 or for2 or for3 or for4 or for5) and (low < low[1])
    downThrust = weGoDown and not weGoDown[1] and not weGoDown[2] and not weGoDown[3] and not weGoDown[4]
    result := upThrust ? 1 : downThrust ? -1 : 0

    result

findGreenGaps() =>
    bool isGreens = close > open and close[1] > open[1] and close[2] > open[2]
    bool hasGap = isGreens and open > close[1] and open[1] > close[2]
    bool foundTwoMore = false

    if hasGap
        for i = 2 to 20
            // if we find a green gap, leave
            bool isGreensR = close[i] > open[i] 
            bool hasGapG = isGreensR and open[i] > close[i+1]
            if (isGreensR and hasGapG)
                break

            bool isRed0 = close[i] < open[i] 
            bool isRed1 = close[i+1] < open[i+1] 
            bool hasGapR = isRed0 and open[i] < close[i+1]
            bool hasGapR2 = isRed1 and open[i+1] < close[i+2]

            if(hasGapR and hasGapR2)
                foundTwoMore := true
                break
                
    hasGap and foundTwoMore

findRedGaps() =>
    bool isReds = close < open and close[1] < open[1] and close[2] < open[2]
    bool hasGap = isReds and open < close[1] and open[1] < close[2]
    bool foundTwoMore = false
    
    if hasGap
        for i = 2 to 20
            // if we find a red gap, leave
            bool isRedsR = close[i] < open[i] 
            bool hasGapR = isRedsR and open[i] < close[i+1]
            if (isRedsR and hasGapR)
                break

            bool isGreen0 = close[i] > open[i] 
            bool isGreen1 = close[i+1] > open[i+1] 
            bool hasGapG = isGreen0 and open[i] > close[i+1]
            bool hasGapG2 = isGreen1 and open[i+1] > close[i+2]

            if(hasGapG and hasGapG2)
                foundTwoMore := true
                break

    hasGap and foundTwoMore

// </editor-fold>

updateTHIRTY(string symie) =>
    [yoTramp, atr] = request.security(sym, "30", [Trampoline(), ta.atr(14)]) 


updateFIVEminute(string sym) =>
    [Open, Close, High, Low, POpen, PPOpen, PClose, PPClose,PHigh, PLow, PPLow, VWAP, Ema, Ema200, upper, lower, pupper, plower, macd0, macd1, bShiftG, bShiftR, yoTramp, atr] = request.security(sym, "5", [open, close, high, low, open[1], open[2], close[1], close[2], high[1], low[1], low[2], ta.vwap(close), ta.ema(close, smEMA), ta.ema(close, bigEMA), BBUpper0(20,2), BBLower0(20,2), BBUpper1(20,2), BBLower1(20,2), calc_macd0(), calc_macd1(), findGreenGaps(), findRedGaps(), Trampoline(), ta.atr(14)]) 
 
    isRed0 = Close < Open
    isRed1 = PClose < POpen
    isRed2 = PPClose < PPOpen
    isGreen0 = Close > Open
    isGreen1 = PClose > POpen
    isGreen2 = PPClose > PPOpen

    // WADDAH EXPLOSION
    t1 = (macd0 - macd1) * sensitivity
    e1 = (upper - lower)

    // GREEN FULLY ABOVE OR BELOW BB
    bFullGreenAboveBB = isGreen0 and Close < lower and Open < lower
    bFullRedAboveBB = isRed0 and Close > upper and Open > upper
    // CANDLE GAP AT THE BOLLINGER BAND
    bGreenGapAtBB = isGreen0 and isGreen1 and Open > PClose and PLow < plower
    bRedGapAtBB = isRed0 and isRed1 and Open < PClose and PHigh > pupper
    // ENGULFING CANDLE OFF THE BOLLINGER BAND
    bEngulingBBGreen = Close > PClose and isGreen0 and isGreen1 and isRed2 and PLow < plower and PPLow < plower and math.abs(POpen - PClose) > math.abs(PPOpen - PPClose)

    atrUp = High + atr * atrTP
    atrDown = Low - atr * atrTP
     
    sGreenGapAtBB = CreateAlert("Candle Gap Buy", sym, Close, atrUp)
    //alertcondition(bGreenGapAtBB, "CGBuy_" + sym, "Candle Gap Buy " + sym)
    if (bGreenGapAtBB)
        alert(sGreenGapAtBB, alert.freq_once_per_bar)

    sRedGapAtBB = CreateAlert("Candle Gap Sell", sym, Close, atrDown)
    //alertcondition(bRedGapAtBB, "CGSell_" + sym, "Candle Gap Sell " + sym)
    if (bRedGapAtBB)
        alert(sRedGapAtBB, alert.freq_once_per_bar)

    sShiftG = CreateAlert("Direction Shift Green", sym, Close, atrUp)
    //alertcondition(bShiftG, "DRGreen_" + sym, "Direction Shift Green " + sym)
    if (bShiftG)
        alert(sShiftG, alert.freq_once_per_bar)

    sShiftR = CreateAlert("Direction Shift Red", sym, Close, atrDown)
    //alertcondition(bShiftR, "DRRed_" + sym, "Direction Shift Red " + sym)
    if (bShiftR)
        alert(sShiftR, alert.freq_once_per_bar)

    sFullGreenAboveBB = CreateAlert("ðŸš¨ Quick Buy", sym, Close, atrUp)
    //alertcondition(bFullGreenAboveBB, "QBuy_" + sym, "ðŸš¨ Quick Buy " + sym)
    if (bFullGreenAboveBB)
        alert(sFullGreenAboveBB, alert.freq_once_per_bar)

    sFullRedAboveBB = CreateAlert("ðŸš¨ Quick Sell", sym, Close, atrDown)
    //alertcondition(bFullRedAboveBB, "QSell_" + sym, "ðŸš¨ Quick Sell " + sym)
    if (bFullRedAboveBB)
        alert(sFullRedAboveBB, alert.freq_once_per_bar)

    // Plot shapes for each symbol
    
    //plotshape(bEngulingBBGreen ? hl2 : na, title="EngBB_" + sym, text="EngBB", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.rgb(46, 173, 84), textcolor=color.white)

    //plotshape(yoTramp == 1 ? hl2 : na, title="Tramp_" + sym, text="Tramp", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.rgb(46, 173, 84), textcolor=color.white)
    //plotshape(yoTramp == -1 ? hl2 : na, title="Tramp_" + sym, text="Tramp", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.rgb(173, 46, 69), textcolor=color.white)

    //plotshape(bGreenGapAtBB ? hl2 : na, title="Gap_" + sym, text="Gap", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.rgb(46, 173, 84), textcolor=color.white)
    //plotshape(bRedGapAtBB ? hl2 : na, title="Gap_" + sym, text="Gap", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.rgb(173, 46, 69), textcolor=color.white)

    //plotshape(bShiftG ? hl2 : na, title="Shift_" + sym, text="Shift", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.rgb(46, 173, 84), textcolor=color.white)
    //plotshape(bShiftR ? hl2 : na, title="Shift_" + sym, text="Shift", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.rgb(173, 46, 69), textcolor=color.white)

    //plotshape(bFullGreenAboveBB ? hl2 : na, title="Strong Buy_" + sym, text="Strong Buy", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.rgb(46, 173, 84), textcolor=color.white)
    //plotshape(bFullRedAboveBB ? hl2 : na, title="Strong Sell_" + sym, text="Strong Sell", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.rgb(173, 46, 69), textcolor=color.white)

if barstate.islast

    for i = 0 to array.size(symbols) - 1    
        updateFIVEminute(str.tostring(symbols[i]))
