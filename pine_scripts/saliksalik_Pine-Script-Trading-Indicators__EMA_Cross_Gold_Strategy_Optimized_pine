// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  
// https://creativecommons.org/licenses/by-nc-sa/4.0/
// Â© EMA Cross Gold Strategy with Range Filter + Win Rate (OPTIMIZED)

//@version=5
indicator("EMA Cross Gold Strategy + Range Filter [Optimized]", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=200)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

grpEMA = "â•â•â• EMA SETTINGS â•â•â•"
string emaTF       = input.timeframe("", "EMA Timeframe", group=grpEMA, tooltip="Timeframe for EMA calculation. Leave empty to use chart timeframe.")
int emaFastLen     = input.int(9, "Fast EMA Length", minval=1, maxval=50, group=grpEMA)
int emaSlowLen     = input.int(26, "Slow EMA Length", minval=1, maxval=100, group=grpEMA)
color emaFastColor = input.color(color.rgb(0, 255, 0), "Fast EMA Color", group=grpEMA)
color emaSlowColor = input.color(color.rgb(255, 0, 64), "Slow EMA Color", group=grpEMA)
bool showEMAs      = input.bool(true, "Show EMAs on Chart", group=grpEMA)

grpRange = "â•â•â• RANGE FILTER (LuxAlgo) â•â•â•"
bool useRangeFilter     = input.bool(true, "Enable Range Filter", group=grpRange, tooltip="Only signal when price is NOT in a range")
int rangeLength         = input.int(20, "Minimum Range Length", minval=2, group=grpRange)
float rangeMult         = input.float(1.0, "Range Width Multiplier", minval=0.1, step=0.1, group=grpRange)
int rangeAtrLen         = input.int(500, "Range ATR Length", minval=1, group=grpRange)
bool showRangeBox       = input.bool(true, "Show Range Boxes", group=grpRange)
color rangeUpCss        = input.color(#089981, "Range Broken Upward", group=grpRange)
color rangeDnCss        = input.color(#f23645, "Range Broken Downward", group=grpRange)
color rangeUnbrokenCss  = input.color(#2157f3, "Range Unbroken", group=grpRange)

grpSLTP = "â•â•â• SL/TP SETTINGS (PIPS) â•â•â•"
float slPips        = input.float(40.0, "Stop Loss (Pips)", minval=1.0, maxval=500.0, step=1.0, group=grpSLTP, tooltip="For Gold (XAUUSD): 1 pip = 0.1 price movement. 40 pips = $4.00")
float tpPips        = input.float(80.0, "Take Profit (Pips)", minval=1.0, maxval=1000.0, step=1.0, group=grpSLTP, tooltip="For Gold (XAUUSD): 1 pip = 0.1 price movement. 80 pips = $8.00")
float pipValue      = input.float(0.1, "Pip Value (Price per Pip)", minval=0.0001, maxval=1.0, step=0.0001, group=grpSLTP, tooltip="Gold: 0.1, Forex majors: 0.0001, JPY pairs: 0.01")
bool showSLTP       = input.bool(true, "Show SL/TP Lines", group=grpSLTP)
color slColor       = input.color(color.red, "Stop Loss Color", group=grpSLTP)
color tpColor       = input.color(color.green, "Take Profit Color", group=grpSLTP)
int slTpLineLength  = input.int(30, "SL/TP Line Length (bars)", minval=10, maxval=100, group=grpSLTP)

grpSignal = "â•â•â• SIGNAL SETTINGS â•â•â•"
bool enableSignals = input.bool(true, "Enable Buy/Sell Signals", group=grpSignal)
bool enableAlerts  = input.bool(true, "Enable Alerts", group=grpSignal)
color buySignalColor  = input.color(color.lime, "Buy Signal Color", group=grpSignal)
color sellSignalColor = input.color(color.red, "Sell Signal Color", group=grpSignal)

grpStats = "â•â•â• WIN RATE TRACKING â•â•â•"
bool trackWinRate     = input.bool(true, "Track Win Rate", group=grpStats)
bool showStatsTable   = input.bool(true, "Show Statistics Table", group=grpStats)
string statsPosition  = input.string("Bottom Right", "Stats Table Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group=grpStats)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TYPE DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type TradeRecord
    float entry
    float sl
    float tp
    bool isBuy
    int entryBar
    bool isOpen


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VARIABLES - Consolidated and optimized
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Trade tracking
var array<TradeRecord> trades = array.new<TradeRecord>()
var int totalWins = 0
var int totalLosses = 0

// SL/TP visual tracking - use single arrays with tuples approach
var array<line> slLines = array.new_line()
var array<line> tpLines = array.new_line()
var array<label> slLabels = array.new_label()
var array<label> tpLabels = array.new_label()

// Range variables
var box rangeBx = na
var line rangeLvl = na
var float rangeMax = na
var float rangeMin = na

// Pre-calculate constants (avoid recalculating every bar)
float slDistance = slPips * pipValue
float tpDistance = tpPips * pipValue
float rrRatioCalc = tpPips / slPips


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER FUNCTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Stats table position
f_getStatsPos() =>
    switch statsPosition
        "Top Right" => position.top_right
        "Top Left" => position.top_left
        "Bottom Right" => position.bottom_right
        => position.bottom_left

// Draw SL/TP lines - optimized with early return
f_drawSLTP(float _sl, float _tp) =>
    if showSLTP
        // SL Line and Label
        slLine = line.new(bar_index, _sl, bar_index + slTpLineLength, _sl, color=slColor, style=line.style_dashed, width=1)
        slLbl = label.new(bar_index + slTpLineLength, _sl, "SL " + str.tostring(slPips, "#") + "p", style=label.style_label_left, color=slColor, textcolor=color.white, size=size.tiny)
        array.push(slLines, slLine)
        array.push(slLabels, slLbl)
        
        // TP Line and Label
        tpLine = line.new(bar_index, _tp, bar_index + slTpLineLength, _tp, color=tpColor, style=line.style_dashed, width=1)
        tpLbl = label.new(bar_index + slTpLineLength, _tp, "TP " + str.tostring(tpPips, "#") + "p", style=label.style_label_left, color=tpColor, textcolor=color.white, size=size.tiny)
        array.push(tpLines, tpLine)
        array.push(tpLabels, tpLbl)

// Cleanup old visual elements - more efficient batch cleanup
f_cleanupArrays() =>
    // Trades array limit
    while array.size(trades) > 100
        array.shift(trades)
    
    // Visual elements limit (cleanup in batches)
    int maxVisuals = 30
    while array.size(slLines) > maxVisuals
        line.delete(array.shift(slLines))
        label.delete(array.shift(slLabels))
    while array.size(tpLines) > maxVisuals
        line.delete(array.shift(tpLines))
        label.delete(array.shift(tpLabels))


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EMA CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Calculate EMAs - single security call with tuple return (more efficient)
[emaFast, emaSlow] = request.security(syminfo.tickerid, emaTF, [ta.ema(close, emaFastLen), ta.ema(close, emaSlowLen)], lookahead=barmerge.lookahead_off)

// EMA Cross Detection
bool emaBullCross = ta.crossover(emaFast, emaSlow)
bool emaBearCross = ta.crossunder(emaFast, emaSlow)

// Current trend (single comparison, reused)
bool isBullishTrend = emaFast > emaSlow


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RANGE DETECTION (LuxAlgo Logic - Optimized)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int n = bar_index
float rangeAtr = ta.atr(rangeAtrLen) * rangeMult
float rangeMa = ta.sma(close, rangeLength)

// Count bars outside range - optimized with math.sum
float outsideRange = 0.0
for i = 0 to rangeLength - 1
    outsideRange += math.abs(close[i] - rangeMa) > rangeAtr ? 1.0 : 0.0
int rangeCount = int(outsideRange)

// Detect new range
color rangeDetectCss = na
bool isNewRange = rangeCount == 0 and rangeCount[1] != rangeCount

if isNewRange
    bool hasOverlap = not na(rangeBx) and n[rangeLength] <= rangeBx.get_right()
    
    if hasOverlap
        // Extend existing box
        rangeMax := math.max(rangeMa + rangeAtr, rangeBx.get_top())
        rangeMin := math.min(rangeMa - rangeAtr, rangeBx.get_bottom())
        rangeBx.set_top(rangeMax)
        rangeBx.set_rightbottom(n, rangeMin)
        if showRangeBox
            rangeBx.set_bgcolor(color.new(rangeUnbrokenCss, 80))
        float avg = math.avg(rangeMax, rangeMin)
        rangeLvl.set_y1(avg)
        rangeLvl.set_xy2(n, avg)
        rangeLvl.set_color(rangeUnbrokenCss)
    else
        // Create new box
        rangeMax := rangeMa + rangeAtr
        rangeMin := rangeMa - rangeAtr
        rangeBx := box.new(n[rangeLength], rangeMax, n, rangeMin, na, bgcolor=showRangeBox ? color.new(rangeUnbrokenCss, 80) : na)
        rangeLvl := line.new(n[rangeLength], rangeMa, n, rangeMa, color=rangeUnbrokenCss, style=line.style_dotted)
        rangeDetectCss := color.new(color.gray, 80)

else if rangeCount == 0 and not na(rangeBx)
    rangeBx.set_right(n)
    rangeLvl.set_x2(n)

// Update box color based on breakout
if not na(rangeBx)
    float boxTop = rangeBx.get_top()
    float boxBot = rangeBx.get_bottom()
    
    if close > boxTop
        if showRangeBox
            rangeBx.set_bgcolor(color.new(rangeUpCss, 80))
        rangeLvl.set_color(rangeUpCss)
    else if close < boxBot
        if showRangeBox
            rangeBx.set_bgcolor(color.new(rangeDnCss, 80))
        rangeLvl.set_color(rangeDnCss)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RANGE STATUS - Simplified and optimized
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Check if price is in range (combined conditions)
bool priceInRangeBand = math.abs(close - rangeMa) <= rangeAtr
bool priceInBox = not na(rangeBx) and close >= rangeBx.get_bottom() and close <= rangeBx.get_top()
bool inRange = priceInRangeBand or priceInBox or rangeCount == 0
bool canSignal = not useRangeFilter or not inRange


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SIGNAL GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool buySignal = enableSignals and emaBullCross and canSignal
bool sellSignal = enableSignals and emaBearCross and canSignal

// Process BUY signal
if buySignal
    float slLevel = close - slDistance
    float tpLevel = close + tpDistance
    f_drawSLTP(slLevel, tpLevel)
    if trackWinRate
        array.push(trades, TradeRecord.new(close, slLevel, tpLevel, true, bar_index, true))

// Process SELL signal
if sellSignal
    float slLevel = close + slDistance
    float tpLevel = close - tpDistance
    f_drawSLTP(slLevel, tpLevel)
    if trackWinRate
        array.push(trades, TradeRecord.new(close, slLevel, tpLevel, false, bar_index, true))


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TRADE OUTCOME TRACKING - Optimized loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if trackWinRate
    int tradeCount = array.size(trades)
    if tradeCount > 0
        for i = tradeCount - 1 to 0 by 1
            TradeRecord trade = array.get(trades, i)
            
            if trade.isOpen
                bool tpHit = trade.isBuy ? high >= trade.tp : low <= trade.tp
                bool slHit = trade.isBuy ? low <= trade.sl : high >= trade.sl
                
                if tpHit
                    trade.isOpen := false
                    totalWins += 1
                else if slHit
                    trade.isOpen := false
                    totalLosses += 1

// Cleanup arrays
f_cleanupArrays()


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOTS - EMAs and Signals
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

plot(showEMAs ? emaFast : na, title="EMA Fast", color=emaFastColor, linewidth=2)
plot(showEMAs ? emaSlow : na, title="EMA Slow", color=emaSlowColor, linewidth=2)

plotshape(buySignal, title="BUY Signal", style=shape.labelup, location=location.belowbar, color=buySignalColor, text="BUY", textcolor=color.white, size=size.normal)
plotshape(sellSignal, title="SELL Signal", style=shape.labeldown, location=location.abovebar, color=sellSignalColor, text="SELL", textcolor=color.white, size=size.normal)

// Range backgrounds
bgcolor(rangeDetectCss, title="Range Detected")
bgcolor(inRange and useRangeFilter ? color.new(color.orange, 90) : na, title="In Range - No Signals")


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DASHBOARD - Combined and optimized (single table update)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var table dash = table.new(position.top_right, 2, 7, chart.bg_color, frame_color=color.gray, frame_width=1)
var table statsTable = table.new(f_getStatsPos(), 2, 7, chart.bg_color, frame_color=color.gray, frame_width=1)

if barstate.islast
    // === Main Dashboard ===
    string trendText = isBullishTrend ? "BULLISH" : "BEARISH"
    color trendColor = isBullishTrend ? color.lime : color.red
    string rangeText = inRange ? "IN RANGE" : "CLEAR"
    color rangeStatusColor = inRange ? color.orange : color.lime
    string emaTFText = emaTF == "" ? timeframe.period : emaTF
    
    table.cell(dash, 0, 0, "EMA Trend", text_color=color.gray, text_size=size.small)
    table.cell(dash, 1, 0, trendText, text_color=trendColor, text_size=size.small)
    table.cell(dash, 0, 1, "EMA TF", text_color=color.gray, text_size=size.small)
    table.cell(dash, 1, 1, emaTFText, text_color=color.yellow, text_size=size.small)
    table.cell(dash, 0, 2, "Range Status", text_color=color.gray, text_size=size.small)
    table.cell(dash, 1, 2, rangeText, text_color=rangeStatusColor, text_size=size.small)
    table.cell(dash, 0, 3, "Range Filter", text_color=color.gray, text_size=size.small)
    table.cell(dash, 1, 3, useRangeFilter ? "ON" : "OFF", text_color=useRangeFilter ? color.green : color.gray, text_size=size.small)
    table.cell(dash, 0, 4, "SL (Pips)", text_color=color.gray, text_size=size.small)
    table.cell(dash, 1, 4, str.tostring(slPips, "#.#"), text_color=slColor, text_size=size.small)
    table.cell(dash, 0, 5, "TP (Pips)", text_color=color.gray, text_size=size.small)
    table.cell(dash, 1, 5, str.tostring(tpPips, "#.#"), text_color=tpColor, text_size=size.small)
    table.cell(dash, 0, 6, "R:R", text_color=color.gray, text_size=size.small)
    table.cell(dash, 1, 6, "1:" + str.tostring(rrRatioCalc, "#.#"), text_color=color.aqua, text_size=size.small)
    
    // === Win Rate Stats Table ===
    if showStatsTable and trackWinRate
        int closedTrades = totalWins + totalLosses
        float winRate = closedTrades > 0 ? (float(totalWins) / float(closedTrades)) * 100.0 : 0.0
        float lossRate = 100.0 - winRate
        
        // Count open trades
        int openTrades = 0
        for trade in trades
            if trade.isOpen
                openTrades += 1
        
        // Expected Value & Profit Factor
        float expectedValue = closedTrades > 0 ? ((winRate/100 * rrRatioCalc) - (lossRate/100)) * 100 : 0.0
        float profitFactor = totalLosses > 0 ? (float(totalWins) * rrRatioCalc) / float(totalLosses) : totalWins > 0 ? 999.0 : 0.0
        
        // Colors based on performance
        color winRateColor = winRate >= 50 ? color.lime : winRate >= 33 ? color.yellow : color.red
        color evColor = expectedValue >= 0 ? color.lime : color.red
        color pfColor = profitFactor >= 1 ? color.lime : color.red
        
        table.cell(statsTable, 0, 0, "â•â• STATS â•â•", text_color=color.white, text_size=size.small)
        table.cell(statsTable, 1, 0, "", text_size=size.small)
        table.cell(statsTable, 0, 1, "Total Trades", text_color=color.gray, text_size=size.small)
        table.cell(statsTable, 1, 1, str.tostring(closedTrades) + " (" + str.tostring(openTrades) + " open)", text_color=chart.fg_color, text_size=size.small)
        table.cell(statsTable, 0, 2, "Wins / Losses", text_color=color.gray, text_size=size.small)
        table.cell(statsTable, 1, 2, str.tostring(totalWins) + " / " + str.tostring(totalLosses), text_color=chart.fg_color, text_size=size.small)
        table.cell(statsTable, 0, 3, "Win Rate", text_color=color.gray, text_size=size.small)
        table.cell(statsTable, 1, 3, str.tostring(winRate, "#.#") + "%", text_color=winRateColor, text_size=size.small)
        table.cell(statsTable, 0, 4, "Profit Factor", text_color=color.gray, text_size=size.small)
        table.cell(statsTable, 1, 4, str.tostring(profitFactor, "#.##"), text_color=pfColor, text_size=size.small)
        table.cell(statsTable, 0, 5, "Exp. Value", text_color=color.gray, text_size=size.small)
        table.cell(statsTable, 1, 5, str.tostring(expectedValue, "#.#") + "%", text_color=evColor, text_size=size.small)
        table.cell(statsTable, 0, 6, "Pips: SL/TP", text_color=color.gray, text_size=size.small)
        table.cell(statsTable, 1, 6, str.tostring(slPips, "#") + " / " + str.tostring(tpPips, "#"), text_color=color.aqua, text_size=size.small)


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(enableAlerts and buySignal, title="ğŸŸ¢ BUY Signal - EMA Cross", message="ğŸš€ BUY SIGNAL on {{ticker}} ({{interval}})\nEMA Cross Bullish - Fast EMA crossed ABOVE Slow EMA\nSL: " + str.tostring(slPips) + " pips | TP: " + str.tostring(tpPips) + " pips")

alertcondition(enableAlerts and sellSignal, title="ğŸ”´ SELL Signal - EMA Cross", message="ğŸ”» SELL SIGNAL on {{ticker}} ({{interval}})\nEMA Cross Bearish - Fast EMA crossed BELOW Slow EMA\nSL: " + str.tostring(slPips) + " pips | TP: " + str.tostring(tpPips) + " pips")

alertcondition(buySignal or sellSignal, title="âš¡ Any EMA Cross Signal", message="EMA Cross Signal on {{ticker}} ({{interval}}) - Check chart!")


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WATERMARK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

var table watermark = table.new(position.bottom_left, 1, 1)
if barstate.islast
    table.cell(watermark, 0, 0, text="EMA Cross Gold Strategy [Optimized] | Range: " + (useRangeFilter ? "ON" : "OFF"), text_size=size.small, text_color=color.new(color.gray, 50))
