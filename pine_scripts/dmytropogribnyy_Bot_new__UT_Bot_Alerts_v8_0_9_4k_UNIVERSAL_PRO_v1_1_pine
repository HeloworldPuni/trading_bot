//@version=6
indicator(title="UT Bot Alerts v8.0.9.4k UNIVERSAL PRO v1.1 (CORE-4: BTC/ETH/BNB/SOL)", overlay=true, max_labels_count=500)

// ============================================================================
// UNIVERSAL PRO v1.1 - –í–∏–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤–µ—Ä—Å—ñ—è –∑ —ñ–¥–µ—è–º–∏ GPT + –≤–∞—à—ñ –¥–∞–Ω—ñ
// ============================================================================
// BASE: v8.0.9.4k BALANCED
//
// –ö–õ–Æ–ß–û–í–Ü –ó–ú–Ü–ù–ò –≤—ñ–¥ GPT (–≤–∏–ø—Ä–∞–≤–ª–µ–Ω—ñ):
// 1. ATR: 0.22/0.23% (–í–ê–®–Ü –î–ê–ù–Ü, –Ω–µ 0.24/0.25 –≤—ñ–¥ GPT!)
// 2. EMA9 Filter: close > ema9 –¥–ª—è LONG (counter-trend –∑–∞—Ö–∏—Å—Ç)
// 3. ATR Cap: max 2.5% (anti-news –∑–∞—â–∏—Ç–∞ –≤—ñ–¥ GPT) ‚úÖ
// 4. HTF Filter: –û–ü–¶–Ü–û–ù–ê–õ–¨–ù–ò–ô 15m EMA200 (OFF –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –¥–ª—è –≥–Ω—É—á–∫–æ—Å—Ç—ñ)
// 5. ADX: 18/22 (—è–∫ —É –≤–∞—à–∏—Ö custom, GPT –π–æ–≥–æ –∑–∞–±—É–≤)
//
// –î–õ–Ø –ö–û–ì–û: BTC/ETH/BNB/SOL (—Ç–µ—Å—Ç—É—î—Ç—å—Å—è –Ω–∞ –≤—Å—ñ—Ö CORE-4)
//
// –û–ß–Ü–ö–£–Ñ–¢–¨–°–Ø:
// ‚Ä¢ BTC/ETH/BNB: 15-20 —Å–∏–≥–Ω–∞–ª—ñ–≤/–¥–µ–Ω—å, WR 85-88%
// ‚Ä¢ SOL: —Ç–µ—Å—Ç—É—î—Ç—å—Å—è –Ω–∞ UNIVERSAL (–º–æ–∂–µ –ø–æ—Ç—Ä–µ–±—É–≤–∞—Ç–∏ –æ–∫—Ä–µ–º–∏–π custom —è–∫—â–æ WR < 80%)
// ‚Ä¢ EMA9 filter –±–ª–æ–∫—É—î counter-trend –≤—Ö–æ–¥–∏ (-$10.70 —Å—å–æ–≥–æ–¥–Ω—ñ ‚Üí $0)
// ‚Ä¢ HTF 15m –æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ –¥–ª—è –¥–æ–¥–∞—Ç–∫–æ–≤–æ—ó —è–∫–æ—Å—Ç—ñ (OFF –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º)
//
// DATE: November 21, 2025
// ============================================================================

// GRADUATED parameters (–í–ê–®–Ü –î–ê–ù–Ü, –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω—ñ 21 Nov)
minAtrPctLong     = 0.22      // –í–ê–®–ï: 0.22% (–Ω–µ 0.24 –≤—ñ–¥ GPT!)
minAtrPctShort    = 0.23      // –í–ê–®–ï: 0.23% (–Ω–µ 0.25 –≤—ñ–¥ GPT!)
maxAtrPct         = 2.50      // GPT: Anti-news cap ‚úÖ
minEmaGapPct      = 0.035     // –Ø–∫ –≤ BALANCED
emaAlignToleranceLong  = 0.005     // LONG: 0.5%
emaAlignTolShort = 0.003     // SHORT: 0.30%

// ============================================================================
// INPUTS
// ============================================================================
a  = input.int(1,  title="Key Value (sensitivity)")
c  = input.int(10, title="ATR Period")
h  = input.bool(false, title="Signals from Heikin Ashi Candles")

// Quality Filter
useSoftFilter          = input.bool(true,  title="Enable Quality Filter")
emaFastLen             = input.int(9,  title="EMA Fast (EMA9)")
emaSlowLen             = input.int(21, title="EMA Slow (EMA21)")
confirmClose           = input.bool(true, title="Confirm on bar close")

// Filter mode (ASYMMETRIC)
filterModeLong         = input.string("OR", title="Filter mode (LONG)", options=["OR","AND"])
filterModeShort        = input.string("AND", title="Filter mode (SHORT)", options=["OR","AND"])
minBarsBetweenSignals  = input.int(7, title="Min bars between signals", minval=0)

// RangeGuard (OFF –¥–ª—è universal, ON —Ç—ñ–ª—å–∫–∏ –¥–ª—è SOL)
useRangeGuard          = input.bool(false, "Enable RangeGuard (OFF –¥–ª—è BTC/ETH/BNB)")
rangeLen               = input.int(14, "Range lookback")
minRangePct            = input.float(0.40, "Min range%", step=0.05)

// Crossover smoothing
crossSmoothLen         = input.int(1, "Crossover EMA length (1=no smoothing)", minval=1, maxval=5)

// ShortGuard LITE + anti-1bar
useShortGuardLite      = input.bool(true,  "Enable ShortGuard LITE (SHORT)")
minStopGapShortPct     = input.float(0.08,  "LITE: Min stop gap%", step=0.01)
minBearBodyShortPct    = input.float(37.0,  "LITE: Min bear body%", step=1.0)
requireShortStayBars   = input.int(1, "SHORT: min consecutive bars below stop", minval=0, maxval=3)
minShortMomentumBars   = input.int(2, "SHORT: min consecutive red bars", minval=0, maxval=5)
strongShortGapPct      = input.float(0.10,"SHORT bypass: stop gap%", step=0.01)
strongBearBodyBypass   = input.float(55.0,"SHORT bypass: strong bear body%", step=1.0)

// Enhanced LONG filters
minLongMomentumBars    = input.int(1,  "LONG: min consecutive green bars", minval=0, maxval=3)
strongLongGapPct       = input.float(0.12,"LONG bypass: stop gap%", step=0.01)
strongBullBodyBypass   = input.float(55.0,"LONG bypass: strong bull body%", step=1.0)

// EMA Alignment filters (ASYMMETRIC)
requireEmaAlignmentLong  = input.bool(true, "LONG: require EMA9 > EMA21 or near (0.5%)")
requireEmaAlignmentShort = input.bool(true, "SHORT: require EMA9 < EMA21 or near (0.30%)")

// ============================================================================
// NEW FILTERS (v1.1)
// ============================================================================

// ADX Filter (—è–∫ —É –≤–∞—à–∏—Ö custom, GPT –π–æ–≥–æ –∑–∞–±—É–≤!)
useAdxFilter       = input.bool(true,  "Enable ADX Trend Strength Filter")
adxLength          = input.int(14,     "ADX Length", minval=7, maxval=21)
adxThresholdLong   = input.float(18.0, "ADX Threshold LONG (—è–∫ ETH/SOL custom)", step=1.0, minval=15.0, maxval=25.0)
adxThresholdShort  = input.float(22.0, "ADX Threshold SHORT (—è–∫ ETH/SOL custom)", step=1.0, minval=18.0, maxval=30.0)

// EMA9 Close Filter (–í–ê–®–ê –í–ò–ú–û–ì–ê - counter-trend –∑–∞—Ö–∏—Å—Ç!)
useEma9CloseFilter = input.bool(true, "Enable EMA9 Close Filter (counter-trend protection)")

// HTF EMA200 Filter (–û–ü–¶–Ü–û–ù–ê–õ–¨–ù–ò–ô, 15m –∑–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—î—é GPT)
useHtfEma200       = input.bool(false, "Enable HTF EMA200 Filter (15m, optional)")
htfTf              = input.timeframe("15", "HTF Timeframe (15m recommended)")
htfEmaLen          = input.int(200, "HTF EMA Length")

// ATR Cap (anti-news –≤—ñ–¥ GPT) ‚úÖ
useAtrCap          = input.bool(true, "Enable ATR Max Cap (Anti-news)")

// Squeeze Momentum Filter (SHORT ONLY)
useSqueezeFilter = input.bool(true,  "Enable Squeeze for SHORT")
squeezeBbLength  = input.int(20,     "Squeeze BB/KC Length", minval=10, maxval=30)
squeezeBbMult    = input.float(2.0,  "Squeeze BB Multiplier", step=0.1, minval=1.5, maxval=2.5)
squeezeKcMult    = input.float(1.5,  "Squeeze KC Multiplier", step=0.1, minval=1.0, maxval=2.0)

// MACD Histogram Filter (optional)
useMacdFilter    = input.bool(false,  "Enable MACD Histogram Filter")
macdFastLength   = input.int(12,     "MACD Fast", minval=8, maxval=15)
macdSlowLength   = input.int(26,     "MACD Slow", minval=20, maxval=30)
macdSignalLength = input.int(9,      "MACD Signal", minval=5, maxval=15)

// Volume Filter (optional)
useVolumeFilter  = input.bool(false,  "Enable Volume Filter")
volumeEmaShort   = input.int(5,      "Volume EMA Short", minval=3, maxval=10)
volumeEmaLong    = input.int(10,     "Volume EMA Long", minval=8, maxval=20)
volumeThreshold  = input.float(15.0, "Volume Threshold %", step=5.0, minval=0.0, maxval=100.0)

// Body filter (optional)
minCandleBodyPct       = input.float(0.0, "Min candle body% (0=OFF)", step=1.0, minval=0.0, maxval=50.0)

// EMA-200 Global Trend Filter
useEma200Filter        = input.bool(true,  "Enable EMA-200 Global Filter")
ema200Tolerance        = input.float(0.7,  "EMA-200 tolerance %", step=0.1, minval=0.0, maxval=2.0)

// Anti-Bottom-Short Filter
useAntiBottomShort     = input.bool(true,  "Enable Anti-Bottom-Short Filter")
dropThresholdPct       = input.float(8.0,  "Recent drop threshold %", step=1.0, minval=5.0, maxval=15.0)
bottomLookbackBars     = input.int(8,      "Bottom detection lookback", minval=5, maxval=15)

// Debug
enableDebug            = input.bool(false, "Enable Debug labels")

// ============================================================================
// FILTER CALCULATIONS
// ============================================================================

// ADX Calculation (—è–∫ —É –≤–∞—à–∏—Ö custom!)
[diPlus, diMinus, adx] = ta.dmi(adxLength, adxLength)
adxLongOk  = not useAdxFilter or (adx > adxThresholdLong)
adxShortOk = not useAdxFilter or (adx > adxThresholdShort)

// Squeeze Momentum (SHORT ONLY)
basisSqz = ta.sma(close, squeezeBbLength)
dev = squeezeBbMult * ta.stdev(close, squeezeBbLength)
upperBB = basisSqz + dev
lowerBB = basisSqz - dev
maSqz = ta.sma(close, squeezeBbLength)
rangeMa = ta.sma(ta.tr, squeezeBbLength)
upperKC = maSqz + rangeMa * squeezeKcMult
lowerKC = maSqz - rangeMa * squeezeKcMult
sqzOn = (lowerBB > lowerKC) and (upperBB < upperKC)
squeezeBreakdown = sqzOn and close < lowerKC
squeezeOk = not useSqueezeFilter or not sqzOn or squeezeBreakdown

// MACD Histogram
[macdLine, signalLine, histLine] = ta.macd(close, macdFastLength, macdSlowLength, macdSignalLength)
macdLongOk = not useMacdFilter or histLine > 0
macdShortOk = not useMacdFilter or histLine < 0

// Volume Confirmation
volShort = ta.ema(volume, volumeEmaShort)
volLong  = ta.ema(volume, volumeEmaLong)
volOsc   = 100 * (volShort - volLong) / math.max(volLong, 1)
volumeOk = not useVolumeFilter or (volOsc > volumeThreshold)

// EMA-200 Global Filter
ema200 = ta.ema(close, 200)
toleranceMult = ema200Tolerance / 100.0
ema200LongOk  = not useEma200Filter or (close > ema200 * (1.0 - toleranceMult))
ema200ShortOk = not useEma200Filter or (close < ema200 * (1.0 + toleranceMult))

// HTF EMA200 Filter (15m, optional, OFF by default)
htfEma = useHtfEma200 ? request.security(syminfo.tickerid, htfTf, ta.ema(close, htfEmaLen), lookahead=barmerge.lookahead_off) : na
htfLongOk  = not useHtfEma200 or (close > htfEma)
htfShortOk = not useHtfEma200 or (close < htfEma)

// Anti-Bottom-Short Filter
recentHigh = ta.highest(high, 25)
recentLow  = ta.lowest(low, 25)
recentDrop = (recentHigh - recentLow) / recentHigh * 100.0
isAtBottom = low == ta.lowest(low, bottomLookbackBars)
antiBottomShortOk = not useAntiBottomShort or not (recentDrop >= dropThresholdPct and isAtBottom)

// ============================================================================
// CORE UT BOT LOGIC
// ============================================================================
xATR  = ta.atr(c)
nLoss = a * xATR
haTkr = ticker.heikinashi(syminfo.tickerid)
src   = h ? request.security(haTkr, timeframe.period, close, lookahead=barmerge.lookahead_off) : close

var float xATRTrailingStop = na
xATRTrailingStop := src > nz(xATRTrailingStop[1], 0) and src[1] > nz(xATRTrailingStop[1], 0) ?
                     math.max(nz(xATRTrailingStop[1]), src - nLoss) :
                     src < nz(xATRTrailingStop[1], 0) and src[1] < nz(xATRTrailingStop[1], 0) ?
                     math.min(nz(xATRTrailingStop[1]), src + nLoss) :
                     src > nz(xATRTrailingStop[1], 0) ? src - nLoss : src + nLoss

basis = crossSmoothLen == 1 ? src : nz(ta.ema(src, crossSmoothLen), src)
above = ta.crossover(basis, xATRTrailingStop)
below = ta.crossunder(basis, xATRTrailingStop)

buy    = src > xATRTrailingStop and above
sell   = src < xATRTrailingStop and below
barbuy  = src > xATRTrailingStop
barsell = src < xATRTrailingStop

// HA-compatible open/high/low
haOpen = request.security(haTkr, timeframe.period, open,  lookahead=barmerge.lookahead_off)
haHigh = request.security(haTkr, timeframe.period, high,  lookahead=barmerge.lookahead_off)
haLow  = request.security(haTkr, timeframe.period, low,   lookahead=barmerge.lookahead_off)
src_open = h ? haOpen : open
src_high = h ? haHigh : high
src_low  = h ? haLow  : low

// ============================================================================
// QUALITY FILTERS (v1.1 - –í–ò–ü–†–ê–í–õ–ï–ù–Ü)
// ============================================================================
emaF    = ta.ema(src, emaFastLen)   // EMA9
emaS    = ta.ema(src, emaSlowLen)   // EMA21

// ATR%: –í–ê–®–Ü –ó–ù–ê–ß–ï–ù–ù–Ø 0.22/0.23%
den_atr = math.max(math.abs(xATRTrailingStop), 1e-9)
atrp    = (xATR / den_atr) * 100.0

// EMA gap%
den_ema = math.max(math.abs(emaS), 1e-9)
gapPct  = na(emaS) or emaS == 0 ? na : math.abs((emaF - emaS) / den_ema) * 100.0

trendUp   = emaF > emaS and gapPct >= minEmaGapPct
trendDown = emaF < emaS and gapPct >= minEmaGapPct

// ATR gates (–í–ê–®–Ü –î–ê–ù–Ü: 0.22/0.23%)
atr_gate_long  = atrp >= minAtrPctLong   // 0.22%
atr_gate_short = atrp >= minAtrPctShort  // 0.23%

// ATR Cap (anti-news –≤—ñ–¥ GPT) ‚úÖ
atr_cap_ok = not useAtrCap or (atrp <= maxAtrPct)  // max 2.5%

// EMA9 Close Filter (–í–ê–®–ê –í–ò–ú–û–ì–ê!)
ema9_close_long  = not useEma9CloseFilter or (close > emaF)  // close > EMA9 –¥–ª—è LONG
ema9_close_short = not useEma9CloseFilter or (close < emaF)  // close < EMA9 –¥–ª—è SHORT

// ADX Soft Bypass
adxLongOk  := not useAdxFilter or (adx > adxThresholdLong) or (trendUp and atr_gate_long)
adxShortOk := not useAdxFilter or (adx > adxThresholdShort) or (trendDown and atr_gate_short)

long_core  = buy
short_core = sell

// RangeGuard (OFF –¥–ª—è universal)
rangeHigh = ta.highest(src, rangeLen)
rangeLow  = ta.lowest(src, rangeLen)
den_rng   = math.max(math.abs(src), 1e-9)
rangePct  = (rangeHigh - rangeLow) / den_rng * 100.0
range_ok  = not useRangeGuard or (rangePct >= minRangePct)

// Pre-calc cascade bypass
var int bearStreak_early = 0
bearStreak_early := (src < src_open) ? nz(bearStreak_early[1]) + 1 : 0
denAbs_early = math.max(math.abs(src), 1e-9)
rng_early = math.max(src_high - src_low, 1e-9)
body_early = math.abs(src_open - src)
bearBodyPct_early = (src < src_open) ? (body_early / rng_early * 100.0) : 0.0
stopGapShortPct_early = (xATRTrailingStop - src) / denAbs_early * 100.0

cascade_bypass = (bearStreak_early >= minShortMomentumBars + 1 and bearBodyPct_early >= minBearBodyShortPct) or
                  (bearStreak_early >= minShortMomentumBars + 2 and bearBodyPct_early >= minBearBodyShortPct - 10.0) or
                  (stopGapShortPct_early >= strongShortGapPct * 1.8 and bearBodyPct_early >= strongBearBodyBypass and atrp >= minAtrPctShort * 1.4)

// EMA Alignment
emaGapAbs = math.abs(emaF - emaS) / den_ema
ema_aligned_long  = not requireEmaAlignmentLong or (emaF > emaS) or (emaGapAbs < emaAlignToleranceLong)
ema_aligned_short = not requireEmaAlignmentShort or (emaF < emaS) or (emaGapAbs < emaAlignTolShort)

// ============================================================================
// FINAL FILTER COMBINATION (v1.1 - –∑ EMA9 + ATR Cap + HTF)
// ============================================================================

// LONG filters
long_filt = filterModeLong == "AND" ? (long_core and atr_gate_long and trendUp) : (long_core and (atr_gate_long or trendUp))
long_filt := long_filt and ema_aligned_long and adxLongOk and macdLongOk and volumeOk
// NEW v1.1: EMA9 close + ATR cap + HTF
long_filt := long_filt and ema9_close_long and atr_cap_ok and htfLongOk

// SHORT filters
short_base = filterModeShort == "AND" ? (short_core and atr_gate_short and trendDown) : (short_core and (atr_gate_short or trendDown))
short_filt = cascade_bypass ? short_core : (short_base and ema_aligned_short and adxShortOk and squeezeOk and macdShortOk and volumeOk)
// NEW v1.1: EMA9 close + ATR cap + HTF
short_filt := short_filt and ema9_close_short and atr_cap_ok and htfShortOk

// ShortGuard LITE + stay bars + anti-1bar
denAbs           = math.max(math.abs(src), 1e-9)
stopGapShortPct  = (xATRTrailingStop - src) / denAbs * 100.0
rng              = math.max(src_high - src_low, 1e-9)
body             = math.abs(src_open - src)
bearBodyPct      = (src < src_open) ? (body / rng * 100.0) : 0.0

short_lite_ok     = not useShortGuardLite or ((stopGapShortPct >= minStopGapShortPct) or (bearBodyPct >= minBearBodyShortPct))
isBelowStop = src < xATRTrailingStop
barsBelowStop_raw = ta.barssince(not isBelowStop)
barsBelowStop     = na(barsBelowStop_raw) ? 0 : barsBelowStop_raw
stay_ok_short     = (requireShortStayBars == 0) or (barsBelowStop >= requireShortStayBars)

var int bearStreak = 0
bearStreak := (src < src_open) ? nz(bearStreak[1]) + 1 : 0
short_momo_ok = (minShortMomentumBars == 0) or (bearStreak >= minShortMomentumBars) or (stopGapShortPct >= strongShortGapPct) or (bearBodyPct >= strongBearBodyBypass)

// Enhanced Long anti-1bar
var int bullStreak = 0
bullStreak := (src > src_open) ? nz(bullStreak[1]) + 1 : 0
bullBodyPct    = (src > src_open) ? (body / rng * 100.0) : 0.0
stopGapLongPct = (src - xATRTrailingStop) / denAbs * 100.0
long_momo_ok   = (minLongMomentumBars == 0) or (bullStreak >= minLongMomentumBars) or (stopGapLongPct >= strongLongGapPct) or (bullBodyPct >= strongBullBodyBypass)

// Impulse bypass
longImpulseBypass = (stopGapLongPct >= strongLongGapPct) or (bullBodyPct >= strongBullBodyBypass)
shortImpulseBypass = (stopGapShortPct >= strongShortGapPct * 1.2) or (bearBodyPct >= strongBearBodyBypass)

// Body filter
body_filter_ok = (minCandleBodyPct == 0.0) or ((body / rng * 100.0) >= minCandleBodyPct)

// Cooldown
var int lastSigBar = na
cooldown_ok = na(lastSigBar) or (bar_index - lastSigBar >= minBarsBetweenSignals)

// Combine filters
long_filt  := long_filt  and range_ok and long_momo_ok and body_filter_ok
short_quality_ok = short_lite_ok and stay_ok_short and short_momo_ok
short_filt := short_filt and range_ok and (cascade_bypass or short_quality_ok) and body_filter_ok

long_ok  = useSoftFilter ? (long_filt  and cooldown_ok) : long_core
short_ok = useSoftFilter ? (short_filt and cooldown_ok) : short_core

// ============================================================================
// APPLY EMA-200 + Anti-Bottom-Short
// ============================================================================
long_ok  := long_ok  and (ema200LongOk or longImpulseBypass or trendUp or atr_gate_long)
short_ok := short_ok and (ema200ShortOk or shortImpulseBypass) and antiBottomShortOk

if (long_ok or short_ok) and (not confirmClose or barstate.isconfirmed)
    lastSigBar := bar_index

// ============================================================================
// DEBUG LABELS
// ============================================================================
if enableDebug
    ema200DistLong = ((close - ema200) / close) * 100.0
    emaGapPctCur = gapPct
    atrPctCur = atrp
    adxCur = adx

    ema200DistShort = ((ema200 - close) / close) * 100.0

    short_reason = not short_core ? "NO_CORE" : not ema9_close_short ? "EMA9_CLOSE" : not atr_cap_ok ? str.format("ATR_CAP (atr:{0,number,#.##}%)", atrPctCur) : not htfShortOk ? "HTF_EMA200" : not ema200ShortOk ? str.format("EMA200_ABOVE (dist:{0,number,#.##}%)", ema200DistShort) : not antiBottomShortOk ? "BOTTOM_SHORT" : cascade_bypass ? "BYPASS_CASCADE" : not ema_aligned_short ? str.format("EMA_MISALIGN (gap:{0,number,#.###}%)", emaGapPctCur) : not atr_gate_short ? str.format("ATR_LOW (atr:{0,number,#.##}%)", atrPctCur) : not trendDown ? str.format("NO_TREND (gap:{0,number,#.###}%)", emaGapPctCur) : not squeezeOk ? "SQUEEZE_ON" : not range_ok ? "RANGE_NARROW" : not short_lite_ok ? str.format("SHORT_GUARD (gap:{0,number,#.##}%,body:{1,number,#.#}%)", stopGapShortPct, bearBodyPct) : not stay_ok_short ? str.format("STAY_BARS ({0})", barsBelowStop) : not short_momo_ok ? str.format("1BAR_SHORT (streak:{0})", bearStreak) : not body_filter_ok ? "WEAK_BODY" : not cooldown_ok ? "COOLDOWN" : not adxShortOk ? str.format("ADX_LOW (adx:{0,number,#.#})", adxCur) : "PASS"
    if short_core and not short_ok
        label.new(bar_index, high, "SHORT X " + short_reason, style=label.style_label_up, color=color.new(color.red,30), textcolor=color.white, size=size.small)

    long_reason = not long_core ? "NO_CORE" : not ema9_close_long ? "EMA9_CLOSE" : not atr_cap_ok ? str.format("ATR_CAP (atr:{0,number,#.##}%)", atrPctCur) : not htfLongOk ? "HTF_EMA200" : not ema200LongOk ? str.format("EMA200_BELOW (dist:{0,number,#.##}%)", ema200DistLong) : not ema_aligned_long ? str.format("EMA_MISALIGN (gap:{0,number,#.###}%)", emaGapPctCur) : not atr_gate_long ? str.format("ATR_LOW (atr:{0,number,#.##}%)", atrPctCur) : not trendUp ? str.format("NO_TREND (gap:{0,number,#.###}%)", emaGapPctCur) : not range_ok ? "RANGE_NARROW" : not long_momo_ok ? str.format("1BAR_LONG (streak:{0},gap:{1,number,#.##}%,body:{2,number,#.#}%)", bullStreak, stopGapLongPct, bullBodyPct) : not body_filter_ok ? "WEAK_BODY" : not cooldown_ok ? "COOLDOWN" : not adxLongOk ? str.format("ADX_LOW (adx:{0,number,#.#})", adxCur) : "PASS"
    if long_core and not long_ok
        label.new(bar_index, low, "LONG X " + long_reason, style=label.style_label_down, color=color.new(color.green,30), textcolor=color.white, size=size.small)

// ============================================================================
// VISUALIZATION
// ============================================================================
shouldPlot = (confirmClose ? barstate.isconfirmed : true)
plotshape(shouldPlot and long_ok,  title="Buy",  text="Buy",  style=shape.labelup,   location=location.belowbar, color=color.green, textcolor=color.white, size=size.tiny)
plotshape(shouldPlot and short_ok, title="Sell", text="Sell", style=shape.labeldown, location=location.abovebar, color=color.red,   textcolor=color.white, size=size.tiny)
barcolor(shouldPlot ? (barbuy ? color.new(color.green, 0) : (barsell ? color.new(color.red, 0) : na)) : na)

// =====================================================================
// ALERT DIAGNOSTICS (–ü–û–í–ò–ù–ù–Ü –ë–£–¢–ò –ü–ï–†–®–ò–ú–ò PLOT'–∞–º–∏ ‚Üí plot_0 / plot_1)
// =====================================================================
plot(atrp,   title="atr_pct",     display=display.none)     // -> {{plot_0}}
plot(gapPct, title="ema_gap_pct", display=display.none)     // -> {{plot_1}}

// EMA overlay (–≤—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è ‚Äî –Ω–µ –≤–ø–ª–∏–≤–∞—î –Ω–∞ –∞–ª–µ—Ä—Ç–∏)
plot(emaF,   title="EMA 9 (fast)",    color=color.new(#2196F3, 0), linewidth=1)
plot(emaS,   title="EMA 21 (slow)",   color=color.new(#FF9800, 0), linewidth=2)
plot(ema200, title="EMA 200 (global)",color=color.new(#9C27B0, 0), linewidth=2)
plot(useHtfEma200 ? htfEma : na, title="HTF EMA200", color=color.new(#E91E63, 0), linewidth=2)

// ============================================================================
// ALERTS
// ============================================================================
alertcondition((confirmClose ? barstate.isconfirmed : true) and long_ok,  "UT Long", message='{"action":"entry","side":"long","source":"utbot","symbol":"{{ticker}}","price":{{close}},"timeframe":"{{interval}}","t":"{{timenow}}","atr_pct":{{plot_0}},"ema_gap_pct":{{plot_1}}}')
alertcondition((confirmClose ? barstate.isconfirmed : true) and short_ok, "UT Short", message='{"action":"entry","side":"short","source":"utbot","symbol":"{{ticker}}","price":{{close}},"timeframe":"{{interval}}","t":"{{timenow}}","atr_pct":{{plot_0}},"ema_gap_pct":{{plot_1}}}')

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHANGELOG
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//
// v1.1 (Nov 21, 2025) ‚Äî UNIVERSAL PRO (–≤–∏–ø—Ä–∞–≤–ª–µ–Ω–∞ –≤–µ—Ä—Å—ñ—è GPT):
//   üéØ ATR: 0.22/0.23% (–í–ê–®–Ü –î–ê–ù–Ü, –Ω–µ 0.24/0.25 GPT!)
//   üéØ EMA9 Close Filter: close > ema9 –¥–ª—è LONG (counter-trend –∑–∞—Ö–∏—Å—Ç)
//   ‚úÖ ATR Cap: max 2.5% (anti-news –≤—ñ–¥ GPT)
//   ‚úÖ ADX: 18/22 (—è–∫ —É –≤–∞—à–∏—Ö custom, GPT –∑–∞–±—É–≤)
//   ‚ö†Ô∏è HTF EMA200: –û–ü–¶–Ü–û–ù–ê–õ–¨–ù–ò–ô, 15m (—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–æ GPT), OFF –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
//   üìä –û—á—ñ–∫—É—î—Ç—å—Å—è: BTC/ETH/BNB 15-20 —Å–∏–≥/–¥–µ–Ω—å/—Å–∏–º–≤–æ–ª @ WR 85-88%
//   üìä SOL: —Ç–µ—Å—Ç—É—î—Ç—å—Å—è –Ω–∞ UNIVERSAL; –ø—Ä–∏ WR < 80% ‚Üí fallback –Ω–∞ SOL_CUSTOM v1.x
//   ‚úÖ –î–ª—è: BTC/ETH/BNB/SOL (CORE-4)
//   üîß –í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ: –≤—Å—ñ –ø–æ–º–∏–ª–∫–∏ –∫–æ–¥—É GPT + –∫—Ä–∏—Ç–∏—á–Ω–∏–π fix plot_0/plot_1
//
