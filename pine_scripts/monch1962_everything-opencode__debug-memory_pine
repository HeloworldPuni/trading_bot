//@version=5
indicator("Debug Memory Profiler", overlay=false)

// ========== MEMORY PROFILING CONFIGURATION ==========

// Enable/disable memory profiling
memoryProfilingEnabled = input.bool(true, "Enable Memory Profiling", group="Memory Profiling")

// Memory tracking granularity
trackVariables = input.bool(true, "Track Variable Memory", group="Memory Profiling")
trackArrays = input.bool(true, "Track Array Memory", group="Memory Profiling")
trackSeries = input.bool(true, "Track Series Memory", group="Memory Profiling")

// Memory usage thresholds (in estimated units)
warningThreshold = input.int(50, "Memory Warning Threshold", group="Memory Profiling", minval=1, maxval=1000)
criticalThreshold = input.int(100, "Memory Critical Threshold", group="Memory Profiling", minval=1, maxval=1000)

// ========== MEMORY TRACKING DATA STRUCTURES ==========

// Track memory usage by variable type
var int totalMemory = 0
var int variableMemory = 0
var int arrayMemory = 0
var int seriesMemory = 0

// Memory usage history (last 100 bars)
var int[] memoryHistory = array.new_int(0)
var int maxHistorySize = 100

// Memory leak detection
var int[] leakDetection = array.new_int(0)
var int leakThreshold = 10  // Consecutive increases to flag as leak

// ========== MEMORY ESTIMATION FUNCTIONS ==========

/**
 * Estimate memory usage for a value
 * Returns: estimated memory units (1 unit â‰ˆ 8 bytes)
 */
debug.estimateMemory(value) =>
    if na(value)
        0
    else
        // Type-based estimation
        if value is bool
            1
        else if value is int
            4
        else if value is float
            8
        else if value is string
            str.length(str.tostring(value)) + 1
        else if value is color
            4
        else if value is line
            16
        else if value is label
            20
        else if value is box
            24
        else if value is table
            32
        else if value is array
            // Estimate array size
            arraySize = 0
            for i = 0 to array.size(value) - 1
                arraySize := arraySize + debug.estimateMemory(array.get(value, i))
            arraySize + 4  // Array overhead
        else
            8  // Default estimate for unknown types

/**
 * Track variable memory usage
 */
debug.trackVariable(name, value, type = "variable") =>
    if memoryProfilingEnabled
        memoryUsage = debug.estimateMemory(value)
        
        // Update totals
        totalMemory := totalMemory + memoryUsage
        
        // Update by type
        if type == "variable"
            variableMemory := variableMemory + memoryUsage
        else if type == "array"
            arrayMemory := arrayMemory + memoryUsage
        else if type == "series"
            seriesMemory := seriesMemory + memoryUsage
        
        // Add to history
        array.push(memoryHistory, totalMemory)
        if array.size(memoryHistory) > maxHistorySize
            array.shift(memoryHistory)
        
        // Check for memory leaks
        debug.detectMemoryLeak()
        
        memoryUsage

/**
 * Detect memory leaks by analyzing history
 */
debug.detectMemoryLeak() =>
    if array.size(memoryHistory) >= leakThreshold
        increasing = true
        for i = 1 to array.size(memoryHistory) - 1
            if array.get(memoryHistory, i) <= array.get(memoryHistory, i - 1)
                increasing := false
                break
        
        if increasing
            debug.logWarning("Potential memory leak detected! Memory increasing for " + str.tostring(array.size(memoryHistory)) + " consecutive bars")

/**
 * Get memory usage statistics
 * Returns: [total, variable, array, series, peak, average]
 */
debug.getMemoryStats() =>
    peak = 0
    sum = 0
    
    for i = 0 to array.size(memoryHistory) - 1
        value = array.get(memoryHistory, i)
        peak := math.max(peak, value)
        sum := sum + value
    
    average = array.size(memoryHistory) > 0 ? sum / array.size(memoryHistory) : 0
    
    [totalMemory, variableMemory, arrayMemory, seriesMemory, peak, average]

// ========== MEMORY PROFILING FUNCTIONS ==========

/**
 * Profile memory usage of a code block
 * Usage: memory = debug.profileMemory("MyFunction", () => myFunctionCall())
 */
debug.profileMemory(label, codeBlock) =>
    if memoryProfilingEnabled
        startMemory = totalMemory
        result = codeBlock()
        endMemory = totalMemory
        memoryUsed = endMemory - startMemory
        
        debug.log("Memory profile [" + label + "]: " + str.tostring(memoryUsed) + " units")
        
        // Check thresholds
        if memoryUsed > criticalThreshold
            debug.logError("Critical memory usage in [" + label + "]: " + str.tostring(memoryUsed) + " units")
        else if memoryUsed > warningThreshold
            debug.logWarning("High memory usage in [" + label + "]: " + str.tostring(memoryUsed) + " units")
        
        result
    else
        codeBlock()

/**
 * Reset memory tracking
 */
debug.resetMemoryTracking() =>
    totalMemory := 0
    variableMemory := 0
    arrayMemory := 0
    seriesMemory := 0
    array.clear(memoryHistory)
    true

/**
 * Generate memory usage report
 */
debug.generateMemoryReport() =>
    if memoryProfilingEnabled and barstate.islast
        [total, variable, array, series, peak, average] = debug.getMemoryStats()
        
        report = "=== MEMORY USAGE REPORT ===\n" +
                "Total: " + str.tostring(total) + " units\n" +
                "By Type:\n" +
                "  Variables: " + str.tostring(variable) + "\n" +
                "  Arrays: " + str.tostring(array) + "\n" +
                "  Series: " + str.tostring(series) + "\n" +
                "Peak: " + str.tostring(peak) + "\n" +
                "Average: " + str.tostring(average) + "\n"
        
        // Recommendations
        recommendations = []
        
        if array > total * 0.5
            array.push(recommendations, "High array memory usage. Consider using series instead of arrays where possible.")
        
        if peak > criticalThreshold
            array.push(recommendations, "Memory usage exceeds critical threshold. Optimize data structures.")
        
        if variable > series * 2
            array.push(recommendations, "High variable-to-series ratio. Consider converting variables to series for better memory management.")
        
        if array.size(recommendations) > 0
            report := report + "\n=== RECOMMENDATIONS ===\n"
            for i = 0 to array.size(recommendations) - 1
                report := report + str.tostring(i + 1) + ". " + array.get(recommendations, i) + "\n"
        
        report

// ========== VISUALIZATION FUNCTIONS ==========

/**
 * Plot memory usage chart
 */
debug.plotMemoryUsage() =>
    if memoryProfilingEnabled
        // Plot total memory
        plot(totalMemory, "Total Memory", color=color.blue, linewidth=2)
        
        // Plot thresholds
        hline(warningThreshold, "Warning", color=color.orange, linestyle=hline.style_dashed)
        hline(criticalThreshold, "Critical", color=color.red, linestyle=hline.style_dashed)
        
        // Plot by type (stacked area)
        plot(variableMemory, "Variable Memory", color=color.green, style=plot.style_area)
        plot(arrayMemory, "Array Memory", color=color.purple, style=plot.style_area, offset=variableMemory)
        plot(seriesMemory, "Series Memory", color=color.yellow, style=plot.style_area, offset=variableMemory + arrayMemory)

/**
 * Display memory statistics table
 */
debug.showMemoryTable() =>
    if memoryProfilingEnabled
        [total, variable, array, series, peak, average] = debug.getMemoryStats()
        
        debug.plotTable("Memory Statistics", [
            ["Total Memory", str.tostring(total) + " units"],
            ["Variable Memory", str.tostring(variable)],
            ["Array Memory", str.tostring(array)],
            ["Series Memory", str.tostring(series)],
            ["Peak Usage", str.tostring(peak)],
            ["Average Usage", str.tostring(average)],
            ["Warning Threshold", str.tostring(warningThreshold)],
            ["Critical Threshold", str.tostring(criticalThreshold)]
        ])

// ========== MEMORY OPTIMIZATION SUGGESTIONS ==========

/**
 * Analyze code for memory optimization opportunities
 */
debug.analyzeMemoryOptimizations(code) =>
    optimizations = []
    
    // Check for large arrays
    if str.contains(code, "array.new")
        array.push(optimizations, {
            "type": "array_optimization",
            "message": "Consider using series instead of arrays for sequential data",
            "impact": "high"
        })
    
    // Check for redundant variable declarations
    if str.contains(code, "var ") and str.contains(code, " := ")
        array.push(optimizations, {
            "type": "variable_reuse",
            "message": "Reuse variables instead of declaring new ones",
            "impact": "medium"
        })
    
    // Check for memory-intensive operations
    if str.contains(code, "ta.") and str.contains(code, "length = ")
        array.push(optimizations, {
            "type": "ta_optimization",
            "message": "Reduce TA function length parameters where possible",
            "impact": "medium"
        })
    
    optimizations

// ========== EXAMPLE USAGE ==========

/*
// Example of memory profiling in your indicator:

//@include "debug-memory.pine"

// Track variable memory
myVar = close
debug.trackVariable("myVar", myVar, "variable")

// Track array memory
myArray = array.new_float(0)
array.push(myArray, close)
debug.trackVariable("myArray", myArray, "array")

// Profile a function
result = debug.profileMemory("RSI Calculation", () =>
    ta.rsi(close, 14)
)

// Show memory visualization
debug.plotMemoryUsage()
debug.showMemoryTable()

// Generate report at the end
if barstate.islast
    report = debug.generateMemoryReport()
    debug.log(report)
*/