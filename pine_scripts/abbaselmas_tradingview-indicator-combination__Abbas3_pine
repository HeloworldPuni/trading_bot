//@version=6
indicator(title='PVP | Key Levels', shorttitle='Abbas3', overlay=true, max_bars_back=500, max_boxes_count=500, max_lines_count=500, max_labels_count=500)

// Optimize: Cache commonly used values
priceTxt = str.tostring(close, format.mintick)
tickerTxt = syminfo.ticker

// ════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════
f_resInMinutes() =>
    // Optimize: Simplified calculation with pre-calculated multipliers
    float _resInMinutes = timeframe.multiplier * (
      timeframe.isseconds ? 1. / 60 : 
      timeframe.isminutes ? 1. : 
      timeframe.isdaily ? 1440. : 
      timeframe.isweekly ? 10080. : 
      timeframe.ismonthly ? 43830. : na)
    _resInMinutes
f_tfResInMinutes(_res) =>
    request.security(syminfo.tickerid, _res, f_resInMinutes())
f_tfIsIntraday(_res) =>
    [intraday, daily, weekly, monthly] = request.security(syminfo.tickerid, _res, [timeframe.isintraday, timeframe.isdaily, timeframe.isweekly, timeframe.ismonthly])
    // Optimize: Simplified ternary
    string check = intraday ? "Intraday" : daily ? "Daily" : weekly ? "Weekly" : monthly ? "Monthly" : "Error" 
    check
f_drawOnlyLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)
f_drawLineX(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width) =>
    var id = line.new(_x1, _y1, _x2, _y2, _xloc, _extend, _color, _style, _width)
    line.set_xy1(id, _x1, _y1)
    line.set_xy2(id, _x2, _y2)
    line.set_color(id, _color)
    id
f_drawOnlyBoxX(_left, _top, _right, _bottom, _border_color, _border_width, _border_style) =>
    box.new(_left, _top, _right, _bottom, _border_color, _border_width, _border_style, bgcolor=_border_color)
f_drawOnlyLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)
f_drawLabelX(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip) =>
    var id = label.new(_x, _y, _text, _xloc, _yloc, _color, _style, _textcolor, _size, _textalign, _tooltip)
    label.set_xy(id, _x, _y)
    label.set_text(id, _text)
    label.set_tooltip(id, _tooltip)
f_getHighLow(_len, _calc, _offset) =>
    if _calc
        htf_l = low [_offset]
        htf_h = high[_offset]
        vol   = 0.
        if _len > 0
            for x = 0 to _len - 1
                htf_l := math.min(low [_offset + x], htf_l)
                htf_h := math.max(high[_offset + x], htf_h)
                vol += volume[_offset + x]
        [htf_h, htf_l, vol]
f_checkBreaches(arrayOfLines, extend) =>
    // Optimize: Cache array size and pre-calculate signs
    int qtyOfLines = array.size(arrayOfLines)
    if qtyOfLines > 0
        float close_prev_sign = math.sign(close[1])
        float close_sign = math.sign(close)
        float low_sign = math.sign(low)
        float high_sign = math.sign(high)
        
        for lineNo = 0 to qtyOfLines - 1
            if lineNo < array.size(arrayOfLines)
                line currentLine = array.get(arrayOfLines, lineNo)
                float lineLevel = line.get_y1(currentLine)
                bool lineWasCrossed = math.sign(close[1] - lineLevel) != math.sign(close - lineLevel)
                bool lineWasTouched = math.sign(close[1] - lineLevel) != math.sign(low - lineLevel) or math.sign(close[1] - lineLevel) != math.sign(high - lineLevel) 
                if lineWasCrossed and extend == 'Until Bar Cross'
                    array.remove(arrayOfLines, lineNo)
                else if lineWasTouched and extend == 'Until Bar Touch'
                    array.remove(arrayOfLines, lineNo)
                else
                    line.set_x2(currentLine, bar_index)
    int(na)
f_checkBreaches_alert(arrayOfLines, extend) =>
    // Optimize: Early exit and cached calculations
    int poc_alert_id = 0
    int qtyOfLines = array.size(arrayOfLines)
    if qtyOfLines > 0
        for lineNo = 0 to qtyOfLines - 1
            if lineNo < array.size(arrayOfLines)
                line currentLine = array.get(arrayOfLines, lineNo)
                float lineLevel = line.get_y1(currentLine)
                bool lineWasCrossed = math.sign(close[1] - lineLevel) != math.sign(close - lineLevel)
                bool lineWasTouched = math.sign(close[1] - lineLevel) != math.sign(low - lineLevel) or math.sign(close[1] - lineLevel) != math.sign(high - lineLevel) 
                if lineWasCrossed
                    poc_alert_id := 1
                    break  // Optimize: Exit early
                else if lineWasTouched
                    poc_alert_id := 2
                    break  // Optimize: Exit early
    poc_alert_id

// ════════════════════════════════════════════════════════════════════════════
// INPUT SETTINGS - VOLUME PROFILE
// ════════════════════════════════════════════════════════════════════════════
group_volume_profile = 'Periodic Volume Profile'
periodic_tf       = input.timeframe("W", "Periodic Timeframe", group = group_volume_profile, tooltip= 'Note that some higher timeframe may not work properly due to maximum historical bars limitation')

tooltip_vp        = 'Volume Profile - displays total trading activity over a specified time period at specific price levels'
volumeProfile     = input.bool(true, 'Volume Profile (Common Interest)', inline='BB3', group = group_volume_profile, tooltip = tooltip_vp)
totalVolumeColor  = input.color(color.new(color.orange, 50), '' , inline='BB3', group = group_volume_profile)
vaVolumeColor     = input.color(color.new(color.gray, 50), '' , inline='BB3', group = group_volume_profile)

tooltip_va        = 'Value Area (VA) – The range of price levels in which a specified percentage of all volume was traded during the time period'
isValueArea       = input.float(68, "Value Area Volume %", minval = 0, maxval = 100              , group = group_volume_profile, tooltip = tooltip_va) / 100
profileLevels     = input.int(200, 'Number of Rows' , minval = 50, maxval = 400 , step = 10      , group = group_volume_profile)
profilePlacement  = input.string('Left', 'Placement', options = ['Right', 'Left', 'Next Period'] , group = group_volume_profile)
profileWidth      = input.int(50, 'Profile Width %', minval = 0, maxval = 100                    , group = group_volume_profile) / 100

tooltip_poc       = 'Point of Control (POC) - The price level for the time period with the highest traded volume'
pointOfControl    = input.bool(true, 'Point of Control (PoC)'                       , inline='PoC', group = group_volume_profile, tooltip = tooltip_poc)
pocColor          = input.color(color.new(color.red, 0), ''                       , inline='PoC', group = group_volume_profile)
pocWidth          = input.int(2, 'Width'                                           , inline='PoC', group = group_volume_profile)
pocExtend         = input.string('Until Bar Touch', 'Extend Point of Control (PoC)', options=['Until Last Bar', 'Until Bar Cross', 'Until Bar Touch', 'None'], group = group_volume_profile)

tooltip_vah       = 'Value Area High (VAH) - The highest price level within the value area'
valueAreaHigh     = input.bool(false, 'Value Area High (VAH)'                        , inline='VAH', group = group_volume_profile, tooltip = tooltip_vah)
vahColor          = input.color(color.new(color.blue, 0), ''                      , inline='VAH', group = group_volume_profile)

tooltip_val       = 'Value Area Low (VAL) - The lowest price level within the value area'
valueAreaLow      = input.bool(false, 'Value Area Low (VAL) '                        , inline='VAL', group = group_volume_profile, tooltip = tooltip_val)
valColor          = input.color(color.new(color.blue, 0), ''                      , inline='VAL', group = group_volume_profile)

vaBackground      = input.bool(false, 'Background Fill of Value Area (VA)'           , inline='vBG', group = group_volume_profile)
vaBackgroundColor = input.color(color.new(color.blue, 90), ''                     , inline='vBG', group = group_volume_profile)

backgroundFill    = input.bool(false, 'Background Fill of Profile Range'             , inline ='BG', group = group_volume_profile)
backgroundColor   = input.color(color.new(color.blue, 95), ''                     , inline ='BG', group = group_volume_profile)

show_cross        = input.bool(true, 'Show POC Crosses', group = group_volume_profile)
show_touch        = input.bool(true, 'Show POC Touches', group = group_volume_profile)

show_previous     = input.bool(false, 'Show Previous POC, VAH, VAL', group = group_volume_profile)
show_dvp          = input.bool(false, 'Show Developing Profile', group = group_volume_profile)

show_dpoc         = input.bool(false, '└ Show Developing POC path', group = group_volume_profile, inline = 'dpoc')
dpoc_col          = input.color(color.yellow, '', group = group_volume_profile, inline = 'dpoc')
show_dvah         = input.bool(false, '└ Show Developing VAH path', group = group_volume_profile, inline = 'dvah')
dvah_col          = input.color(color.aqua, '', group = group_volume_profile, inline = 'dvah')
show_dval         = input.bool(false, '└ Show Developing VAL path', group = group_volume_profile, inline = 'dval')
dval_col          = input.color(color.aqua, '', group = group_volume_profile, inline = 'dval')

// ════════════════════════════════════════════════════════════════════════════
// VOLUME PROFILE VARIABLES
// ════════════════════════════════════════════════════════════════════════════
// Optimize: Cache volume to avoid repeated nz() calls
float nzVolume = nz(volume)
array<float> volumeStorageT = array.new_float(profileLevels + 1, 0.)
var array<line> a_poc_lines = array.new_line()
var int x1 = 0
var int x2 = 0
var int levelAbovePoc = 0
var int levelBelowPoc = 0
var float pPOC = 0.
var float pvah = 0.
var float pval = 0.

// ════════════════════════════════════════════════════════════════════════════
// VOLUME PROFILE CALCULATIONS
// ════════════════════════════════════════════════════════════════════════════
// Optimize: Pre-calculate time-based values
int min_of_day = hour * 60 + minute
int intv = 0
int C_bar = 0
bool bar_start = false
string period = f_tfIsIntraday(periodic_tf)
// Optimize: ta.barssince requires bool condition, not int - check if time changed
int daily_start = ta.barssince(ta.change(time("D")) != 0)
int weekly_start = ta.barssince(ta.change(time("W")) != 0)
int monthly_start = ta.barssince(ta.change(time("M")) != 0)
int threeM_start = ta.barssince(ta.change(time("3M")) != 0)
int sixM_start = ta.barssince(ta.change(time("6M")) != 0)
int yearly_start = ta.barssince(ta.change(time("12M")) != 0)
int profileLength = 0
if period == "Intraday"
    intv := int(f_tfResInMinutes(periodic_tf))
    C_bar := (min_of_day % intv)
    profileLength := ta.barssince(C_bar[1] == 0) +1
else if period == "Daily"
    C_bar := daily_start
    profileLength := daily_start[1]+1
else if period == "Weekly"
    C_bar := weekly_start
    profileLength := weekly_start[1]+1
else if period == "Monthly"
    C_bar := monthly_start
    profileLength := C_bar[1]+1

bar_start := C_bar == 0
bool proceed = bar_start

if proceed
    x1 := x2
    x2 := bar_index

[priceHighest, priceLowest, tradedVolume] = f_getHighLow(profileLength, proceed, 1)
float priceStep = (priceHighest - priceLowest) / profileLevels

// Optimize: Combine conditions and cache common checks
if proceed and nzVolume > 0 and priceStep > 0 and bar_index > profileLength and profileLength > 0
    for barIndexx = 1 to profileLength
        int level = 0
        int barIndex = barIndexx
        for priceLevel = priceLowest to priceHighest by priceStep
            float candleSize = high[barIndex] - low[barIndex]
            if high[barIndex] >= priceLevel and low[barIndex] < priceLevel + priceStep
                if high[barIndex] <= priceLevel + priceStep and low[barIndex] >= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex])
                else if high[barIndex] >= priceLevel + priceStep and low[barIndex] <= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * (priceStep/ candleSize))
                else if high[barIndex] >= priceLevel + priceStep
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * ((priceLevel + priceStep - low[barIndex]) / candleSize))
                else if low[barIndex] <= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * ((high[barIndex] - priceLevel) / candleSize))
            level += 1
    pocLevel          = array.indexof(volumeStorageT, array.max(volumeStorageT))
    totalVolumeTraded = array.sum(volumeStorageT) * isValueArea
    valueArea         = array.get(volumeStorageT, pocLevel)
    levelAbovePoc    := pocLevel
    levelBelowPoc    := pocLevel
    while valueArea < totalVolumeTraded
        if levelBelowPoc == 0 and levelAbovePoc == profileLevels - 1
            break
        volumeAbovePoc = 0.
        if levelAbovePoc < profileLevels - 1 
            volumeAbovePoc := array.get(volumeStorageT, levelAbovePoc + 1)
        volumeBelowPoc = 0.
        if levelBelowPoc > 0
            volumeBelowPoc := array.get(volumeStorageT, levelBelowPoc - 1)
        if volumeBelowPoc == 0 and volumeAbovePoc == 0
            break
        if volumeAbovePoc >= volumeBelowPoc
            valueArea     += volumeAbovePoc
            levelAbovePoc += 1
        else
            valueArea     += volumeBelowPoc
            levelBelowPoc -= 1
    for level = 0 to profileLevels - 1
        if volumeProfile
            startBoxIndex = profilePlacement == 'Right' ? bar_index - int(array.get(volumeStorageT, level) / array.max(volumeStorageT) * profileLength * profileWidth) : profilePlacement == 'Left' ? bar_index - profileLength : bar_index
            endBoxIndex   = profilePlacement == 'Right' ? bar_index  :  startBoxIndex + int( array.get(volumeStorageT, level) / array.max(volumeStorageT) * profileLength * profileWidth)
            f_drawOnlyBoxX(startBoxIndex, priceLowest + (level + 0.1) * priceStep, endBoxIndex, priceLowest + (level + 0.9) * priceStep, level >= levelBelowPoc and level <= levelAbovePoc ? totalVolumeColor : vaVolumeColor, 1, line.style_solid)
    if backgroundFill
        f_drawOnlyBoxX(bar_index - profileLength, priceHighest, bar_index - 1, priceLowest, backgroundColor, 1, line.style_dotted)
    if pointOfControl
        array.push(a_poc_lines, line.new(bar_index - profileLength, priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + 0.5) * priceStep, bar_index, priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + 0.5) * priceStep, color=pocColor, width = pocWidth))
    vah = f_drawOnlyLineX(bar_index - profileLength, priceLowest + (levelAbovePoc + 1.00) * priceStep, bar_index-1, priceLowest + (levelAbovePoc + 1.00) * priceStep, xloc.bar_index, extend.none, valueAreaHigh ? vahColor : #00000000, line.style_solid, 2)
    val = f_drawOnlyLineX(bar_index - profileLength, priceLowest + (levelBelowPoc + 0.00) * priceStep, bar_index-1, priceLowest + (levelBelowPoc + 0.00) * priceStep, xloc.bar_index, extend.none, valueAreaLow  ? valColor : #00000000, line.style_solid, 2)
    if vaBackground
        linefill.new(vah, val, vaBackgroundColor)
    pPOC := priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + 0.5) * priceStep
    pvah := priceLowest + (levelAbovePoc + 1.00) * priceStep
    pval := priceLowest + (levelBelowPoc + 0.00) * priceStep

current_start = ta.barssince(bar_start)

var a_profileD    = array.new_box()
profileLength    := current_start
priceHighest     := ta.highest(high, profileLength > 0 ? profileLength + 1 : 1)
priceLowest      := ta.lowest (low , profileLength > 0 ? profileLength + 1 : 1)
priceStep        := (priceHighest - priceLowest) / profileLevels
var pocLevel      = 0

[_, _, tradedVolume1] = f_getHighLow(profileLength, true, 0)

// Optimize: Check if nzVolume is greater than 0 (explicit boolean)
if nzVolume > 0 and profileLength > 0 and priceStep > 0 and show_dvp
    if array.size(a_profileD) > 0
        for i = 0 to array.size(a_profileD) - 1
            box.delete(array.shift(a_profileD))
    for barIndex = 0 to profileLength
        level = 0
        for priceLevel = priceLowest to priceHighest by priceStep
            candleSize = high[barIndex] - low[barIndex]
            if high[barIndex] >= priceLevel and low[barIndex] < priceLevel + priceStep
                if high[barIndex] <= priceLevel + priceStep and low[barIndex] >= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex])
                else if high[barIndex] >= priceLevel + priceStep and low[barIndex] <= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * (priceStep/ candleSize))
                else if high[barIndex] >= priceLevel + priceStep
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * ((priceLevel + priceStep - low[barIndex]) / candleSize))
                else if low[barIndex] <= priceLevel
                    array.set(volumeStorageT, level, array.get(volumeStorageT, level) + nzVolume[barIndex] * ((high[barIndex] - priceLevel) / candleSize))
            level += 1
    pocLevel          := array.indexof(volumeStorageT, array.max(volumeStorageT))
    totalVolumeTraded = array.sum(volumeStorageT) * isValueArea
    valueArea         = array.get(volumeStorageT, pocLevel)
    levelAbovePoc    := pocLevel
    levelBelowPoc    := pocLevel
    while valueArea < totalVolumeTraded and totalVolumeTraded > 0
        if levelBelowPoc == 0 and levelAbovePoc == profileLevels - 1
            break
        volumeAbovePoc = 0.
        if levelAbovePoc < profileLevels - 1 
            volumeAbovePoc := array.get(volumeStorageT, levelAbovePoc + 1)
        volumeBelowPoc = 0.
        if levelBelowPoc > 0
            volumeBelowPoc := array.get(volumeStorageT, levelBelowPoc - 1)
        if volumeBelowPoc == 0 and volumeAbovePoc == 0
            break
        if volumeAbovePoc >= volumeBelowPoc
            valueArea     += volumeAbovePoc
            levelAbovePoc += 1
        else
            valueArea     += volumeBelowPoc
            levelBelowPoc -= 1
        if levelAbovePoc - levelBelowPoc >= profileLevels
            break
    for level = 0 to profileLevels - 1
        if volumeProfile
            startBoxIndex = profilePlacement == 'Right' ? bar_index - int(array.get(volumeStorageT, level) / array.max(volumeStorageT) * profileLength * profileWidth)  : profilePlacement == 'Left' ? bar_index - profileLength : bar_index
            endBoxIndex   = profilePlacement == 'Right' ? bar_index  :  startBoxIndex + int( array.get(volumeStorageT, level) / array.max(volumeStorageT) * profileLength * profileWidth)
            array.push(a_profileD, box.new(startBoxIndex, priceLowest + (level + 0.1) * priceStep, endBoxIndex, priceLowest + (level + 0.9) * priceStep, level >= levelBelowPoc and level <= levelAbovePoc ? totalVolumeColor : vaVolumeColor, bgcolor = level >= levelBelowPoc and level <= levelAbovePoc ? totalVolumeColor : vaVolumeColor ))
    if backgroundFill
        array.push(a_profileD, box.new(bar_index - profileLength, priceHighest, bar_index, priceLowest, backgroundColor, bgcolor = backgroundColor ))
    if pointOfControl and not show_dpoc
        array.push(a_profileD, box.new(bar_index - profileLength, priceLowest + (pocLevel + .40) * priceStep, bar_index, priceLowest + (pocLevel + .60) * priceStep, pocColor, bgcolor = pocColor ))
    vah = f_drawLineX(bar_index - profileLength, priceLowest + (levelAbovePoc + 1.00) * priceStep, bar_index, priceLowest + (levelAbovePoc + 1.00) * priceStep, xloc.bar_index, extend.none, valueAreaHigh ? vahColor : #00000000, line.style_solid, 2)
    val = f_drawLineX(bar_index - profileLength, priceLowest + (levelBelowPoc + 0.00) * priceStep, bar_index, priceLowest + (levelBelowPoc + 0.00) * priceStep, xloc.bar_index, extend.none, valueAreaLow  ? valColor : #00000000, line.style_solid, 2)
    if vaBackground
        linefill.new(vah, val, vaBackgroundColor)
        
DPoC = priceLowest + (array.indexof(volumeStorageT, array.max(volumeStorageT)) + .50) * priceStep
DVAH = priceLowest + (levelAbovePoc + 1.00) * priceStep
DVAL = priceLowest + (levelBelowPoc + 0.00) * priceStep

var line DPoC_l = line.new(na, na, na, na, color=pocColor, width = 2)
var line DVAH_l = line.new(na, na, na, na, color=vahColor, width = 2)
var line DVAL_l = line.new(na, na, na, na, color=valColor, width = 2)

var line PPoC_l = line.new(na, na , na, na, color=pocColor, style = line.style_dashed, width = 2)
var line PVAH_l = line.new(na, na , na, na, color=vahColor, style = line.style_dashed, width = 2)
var line PVAL_l = line.new(na, na , na, na, color=valColor, style = line.style_dashed, width = 2)

if barstate.islast and show_dvp
    if not show_dpoc
        line.delete(DPoC_l)
        DPoC_l := line.new(last_bar_index - profileLength, DPoC , last_bar_index, DPoC, color=pocColor, width = 2)
    if not show_dvah
        line.delete(DVAH_l)
        DVAH_l := line.new(last_bar_index - profileLength, DVAH , last_bar_index, DVAH, color=vahColor, width = 2)
    if not show_dval
        line.delete(DVAL_l)
        DVAL_l := line.new(last_bar_index - profileLength, DVAL , last_bar_index, DVAL, color=valColor, width = 2)

if barstate.islast and show_previous
    line.delete(PPoC_l)
    line.delete(PVAH_l)
    line.delete(PVAL_l)
    PPoC_l := line.new(last_bar_index - profileLength, pPOC , last_bar_index, pPOC, color=pocColor, style = line.style_dashed, width = 2)
    PVAH_l := line.new(last_bar_index - profileLength, pvah , last_bar_index, pvah, color=vahColor, style = line.style_dashed, width = 2)
    PVAL_l := line.new(last_bar_index - profileLength, pval , last_bar_index, pval, color=valColor, style = line.style_dashed, width = 2)
    
    if vaBackground
        linefill.new(PVAH_l, PVAL_l, color.new(vaBackgroundColor, 95))

poc_alert = 0

if pointOfControl
    poc_alert := f_checkBreaches_alert(a_poc_lines, pocExtend)

poc_alert := proceed ? 0 : poc_alert

if pointOfControl and pocExtend != 'None' 
    f_checkBreaches(a_poc_lines, pocExtend)

plot(show_dpoc and show_dvp? DPoC : na, 'DPOC Path', proceed ? na : dpoc_col, 2)
plot(show_dvah and show_dvp? DVAH : na, 'DVAH Path', proceed ? na : dvah_col, 2)
plot(show_dval and show_dvp? DVAL : na, 'DPOC Path', proceed ? na : dval_col, 2)

// Cross / Touch Plots ----------------------------------------------------------------------------
plotshape(show_cross and poc_alert == 1 and close > open ? close : na, location = location.abovebar, style = shape.xcross,       color= color.green, size = size.small)
plotshape(show_cross and poc_alert == 1 and close < open ? close : na, location = location.belowbar, style = shape.xcross,       color= color.green, size = size.small)
plotshape(show_touch and poc_alert == 2 and close > open ? close : na, location = location.abovebar, style = shape.triangledown, color=color.yellow, size = size.small)
plotshape(show_touch and poc_alert == 2 and close < open ? close : na, location = location.belowbar, style = shape.triangleup,   color=color.yellow, size = size.small)

// Alerts --------------------------------------------------------------------------------------- 
alertcondition(poc_alert == 1, "nPOC Crossed", "Naked POC Crossed")
alertcondition(poc_alert == 2, "nPOC Touched", "Naked POC Touched")

// ════════════════════════════════════════════════════════════════════════════
// KEY LEVELS - INPUT SETTINGS
// ════════════════════════════════════════════════════════════════════════════
displayStyle = input.string(defval='Standard', title='Display Style', options=['Standard', 'Right Anchored'], inline='Display')
mergebool = input.bool(defval=true, title='Merge Levels?', inline='Display')
distanceright = input.int(defval=30, title='Distance', minval=5, maxval=500, inline='Dist')
radistance = input.int(defval=250, title='Anchor Distance', minval=5, maxval=500, inline='Dist')
labelsize = input.string(defval='Medium', title='Text Size', options=['Small', 'Medium', 'Large'])
linesize = input.string(defval='Small', title='Line Width', options=['Small', 'Medium', 'Large'], inline='Line')
linestyle = input.string(defval='Solid', title='Line Style', options=['Solid', 'Dashed', 'Dotted'], inline='Line')

GlobalTextType = input.bool(defval=true, title='Global Text ShortHand', tooltip='Enable for shorthand text on all text')
var globalcoloring = input.bool(defval=false, title='Global Coloring', tooltip='Enable for all color controls via one color', inline='GC')
GlobalColor = input.color(title='', defval=color.white, inline='GC')

// ════════════════════════════════════════════════════════════════════════════
// KEY LEVELS - SECURITY DATA REQUESTS
// ════════════════════════════════════════════════════════════════════════════
// Optimize: Group all security requests together
[daily_time, daily_open] = request.security(syminfo.tickerid, 'D', [time, open], lookahead=barmerge.lookahead_on)
[dailyh_time, dailyh_open] = request.security(syminfo.tickerid, 'D', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[dailyl_time, dailyl_open] = request.security(syminfo.tickerid, 'D', [time[1], low[1]], lookahead=barmerge.lookahead_on)

cdailyh_open = request.security(syminfo.tickerid, 'D', high, lookahead=barmerge.lookahead_on)
cdailyl_open = request.security(syminfo.tickerid, 'D', low, lookahead=barmerge.lookahead_on)
var monday_time = time
var monday_high = high
var monday_low = low

[weekly_time, weekly_open] = request.security(syminfo.tickerid, 'W', [time, open], lookahead=barmerge.lookahead_on)
[weeklyh_time, weeklyh_open] = request.security(syminfo.tickerid, 'W', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[weeklyl_time, weeklyl_open] = request.security(syminfo.tickerid, 'W', [time[1], low[1]], lookahead=barmerge.lookahead_on)

[monthly_time, monthly_open] = request.security(syminfo.tickerid, 'M', [time, open], lookahead=barmerge.lookahead_on)
[monthlyh_time, monthlyh_open] = request.security(syminfo.tickerid, 'M', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[monthlyl_time, monthlyl_open] = request.security(syminfo.tickerid, 'M', [time[1], low[1]], lookahead=barmerge.lookahead_on)

[yearly_time, yearly_open] = request.security(syminfo.tickerid, '12M', [time, open], lookahead=barmerge.lookahead_on)
[yearlyh_time, yearlyh_open] = request.security(syminfo.tickerid, '12M', [time, high], lookahead=barmerge.lookahead_on)
[yearlyl_time, yearlyl_open] = request.security(syminfo.tickerid, '12M', [time, low], lookahead=barmerge.lookahead_on)

[intra_time, intra_open] = request.security(syminfo.tickerid, '240', [time, open], lookahead=barmerge.lookahead_on)
[intrah_time, intrah_open] = request.security(syminfo.tickerid, '240', [time[1], high[1]], lookahead=barmerge.lookahead_on)
[intral_time, intral_open] = request.security(syminfo.tickerid, '240', [time[1], low[1]], lookahead=barmerge.lookahead_on)

// ════════════════════════════════════════════════════════════════════════════
// KEY LEVELS - TIMEFRAME INPUTS
// ════════════════════════════════════════════════════════════════════════════
var is_intra_enabled = input.bool(defval=false, title='Open', group='4H', inline='4H')
var is_intrarange_enabled = input.bool(defval=false, title='Prev H/L', group='4H', inline='4H')
var is_intram_enabled = input.bool(defval=false, title='Prev Mid', group='4H', inline='4H')
IntraTextType = input.bool(defval=false, title='ShortHand', group='4H', inline='4Hsh')

var is_daily_enabled = input.bool(defval=true, title='Open', group='Daily', inline='Daily')
var is_dailyrange_enabled = input.bool(defval=true, title='Prev H/L', group='Daily', inline='Daily')
var is_dailym_enabled = input.bool(defval=true, title='Prev Mid', group='Daily', inline='Daily')
DailyTextType = input.bool(defval=false, title='ShortHand', group='Daily', inline='Dailysh')

var is_monday_enabled = input.bool(defval=true, title='Range', group='Monday Range', inline='Monday')
var is_monday_mid = input.bool(defval=true, title='Mid', group='Monday Range', inline='Monday')
var untested_monday = false
MondayTextType = input.bool(defval=false, title='ShortHand', group='Monday Range', inline='Mondaysh')

var is_weekly_enabled = input.bool(defval=true, title='Open', group='Weekly', inline='Weekly')
var is_weeklyrange_enabled = input.bool(defval=true, title='Prev H/L', group='Weekly', inline='Weekly')
var is_weekly_mid = input.bool(defval=true, title='Prev Mid', group='Weekly', inline='Weekly')
WeeklyTextType = input.bool(defval=false, title='ShortHand', group='Weekly', inline='Weeklysh')

var is_monthly_enabled = input.bool(defval=true, title='Open', group='Monthly', inline='Monthly')
var is_monthlyrange_enabled = input.bool(defval=false, title='Prev H/L', group='Monthly', inline='Monthly')
var is_monthly_mid = input.bool(defval=false, title='Prev Mid', group='Monthly', inline='Monthly')
MonthlyTextType = input.bool(defval=false, title='ShortHand', group='Monthly', inline='Monthlysh')

var is_yearly_enabled = input.bool(defval=false, title='Open', group='Yearly', inline='Yearly')
var is_yearlyrange_enabled = input.bool(defval=false, title='Current H/L', group='Yearly', inline='Yearly')
var is_yearly_mid = input.bool(defval=false, title='Mid', group='Yearly', inline='Yearly')
YearlyTextType = input.bool(defval=false, title='ShortHand', group='Yearly', inline='Yearlysh')

DailyColor = input.color(title='', defval=color.aqua, group='Daily', inline='Dailysh')
MondayColor = input.color(title='', defval=color.purple, group='Monday Range', inline='Mondaysh')
WeeklyColor = input.color(title='', defval=color.orange, group='Weekly', inline='Weeklysh')
MonthlyColor = input.color(title='', defval=color.teal, group='Monthly', inline='Monthlysh')
YearlyColor = input.color(title='', defval=color.red, group='Yearly', inline='Yearlysh')
IntraColor = input.color(title='', defval=color.orange, group='4H', inline='4Hsh')

// ════════════════════════════════════════════════════════════════════════════
// KEY LEVELS - TEXT LABELS
// ════════════════════════════════════════════════════════════════════════════
// Optimize: Pre-calculate text labels based on settings
var string pdhtext = GlobalTextType or DailyTextType ? 'PDH' : 'Prev Day High'
var string pdltext = GlobalTextType or DailyTextType ? 'PDL' : 'Prev Day Low'
var string dotext = GlobalTextType or DailyTextType ? 'DO' : 'Daily Open'
var string pdmtext = GlobalTextType or DailyTextType ? 'PDM' : 'Prev Day Mid'

var string pwhtext = GlobalTextType or WeeklyTextType ? 'PWH' : 'Prev Week High'
var string pwltext = GlobalTextType or WeeklyTextType ? 'PWL' : 'Prev Week Low'
var string wotext = GlobalTextType or WeeklyTextType ? 'WO' : 'Weekly Open'
var string pwmtext = GlobalTextType or WeeklyTextType ? 'PWM' : 'Prev Week Mid'

var string pmhtext = GlobalTextType or MonthlyTextType ? 'PMH' : 'Prev Month High'
var string pmltext = GlobalTextType or MonthlyTextType ? 'PML' : 'Prev Month Low'
var string motext = GlobalTextType or MonthlyTextType ? 'MO' : 'Monthly Open'
var string pmmtext = GlobalTextType or MonthlyTextType ? 'PMM' : 'Prev Month Mid'

var string cyhtext = GlobalTextType or YearlyTextType ? 'CYH' : 'Current Year High'
var string cyltext = GlobalTextType or YearlyTextType ? 'CYL' : 'Current Year Low'
var string yotext = GlobalTextType or YearlyTextType ? 'YO' : 'Yearly Open'
var string cymtext = GlobalTextType or YearlyTextType ? 'CYM' : 'Current Year Mid'

var string pihtext = GlobalTextType or IntraTextType ? 'P-4H-H' : 'Prev 4H High'
var string piltext = GlobalTextType or IntraTextType ? 'P-4H-L' : 'Prev 4H Low'
var string iotext = GlobalTextType or IntraTextType ? '4H-O' : '4H Open'
var string pimtext = GlobalTextType or IntraTextType ? 'P-4H-M' : 'Prev 4H Mid'

var string pmonhtext = GlobalTextType or MondayTextType ? 'MDAY-H' : 'Monday High'
var string pmonltext = GlobalTextType or MondayTextType ? 'MDAY-L' : 'Monday Low'
var string pmonmtext = GlobalTextType or MondayTextType ? 'MDAY-M' : 'Monday Mid'

// Optimize: Simplify color assignment
if globalcoloring
    DailyColor := GlobalColor
    MondayColor := GlobalColor
    WeeklyColor := GlobalColor
    MonthlyColor := GlobalColor
    YearlyColor := GlobalColor
    IntraColor := GlobalColor

if weekly_time != weekly_time[1]
    untested_monday := false

// Optimize: Simplify boolean check
if is_monday_enabled and not untested_monday
    untested_monday := true
    monday_time := daily_time
    monday_high := cdailyh_open
    monday_low := cdailyl_open

// Optimize: Simplify line width selection
int linewidthint = linesize == 'Small' ? 1 : linesize == 'Medium' ? 2 : 3

var int DEFAULT_LINE_WIDTH = linewidthint
var int DEFAULT_TAIL_WIDTH = linewidthint

// Optimize: Simplify font size selection
string fontsize = labelsize == 'Small' ? size.small : labelsize == 'Medium' ? size.normal : size.large

// Optimize: Simplify line style selection
string linestyles = linestyle == 'Dashed' ? line.style_dashed : linestyle == 'Dotted' ? line.style_dotted : line.style_solid

var string DEFAULT_LABEL_SIZE = fontsize
var string DEFAULT_LABEL_STYLE = label.style_none
var int DEFAULT_EXTEND_RIGHT = distanceright

// ════════════════════════════════════════════════════════════════════════════
// KEY LEVELS - PLOTTING LOGIC
// ════════════════════════════════════════════════════════════════════════════
var array<float> pricearray = array.new_float(0)
var array<label> labelarray = array.new_label(0)

// Optimize: Add type declarations and improve label merging logic
f_LevelMerge(array<float> pricearray, array<label> labelarray, float currentprice, label currentlabel, color currentcolor) =>
    if array.includes(pricearray, currentprice)
        int whichindex = array.indexof(pricearray, currentprice)
        label labelhold = array.get(labelarray, whichindex)
        string whichtext = label.get_text(labelhold)

        label.set_text(labelhold, label.get_text(currentlabel) + ' / ' + whichtext)
        label.set_text(currentlabel, '')
        label.set_textcolor(labelhold, currentcolor)
    else
        array.push(pricearray, currentprice)
        array.push(labelarray, currentlabel)

// Optimize: Add type declarations for visibility checks
var bool can_show_daily = is_daily_enabled and timeframe.isintraday
var bool can_show_weekly = is_weekly_enabled and not timeframe.isweekly and not timeframe.ismonthly
var bool can_show_monthly = is_monthly_enabled and not timeframe.ismonthly

// Optimize: Add type declaration for helper function
get_limit_right(int bars) =>
    timenow + (time - time[1]) * bars

// Optimize: Process drawing logic only on last bar
if barstate.islast
    bool is_weekly_open = dayofweek == dayofweek.monday
    bool is_monthly_open = dayofmonth == 1
    bool can_draw_daily = (is_weekly_enabled ? not is_weekly_open : true) and (is_monthly_enabled ? not is_monthly_open : true)
    bool can_draw_weekly = is_monthly_enabled ? not(is_monthly_open and is_weekly_open) : true
    bool can_draw_intra = is_intra_enabled
    bool can_draw_intrah = is_intrarange_enabled
    bool can_draw_intral = is_intrarange_enabled
    bool can_draw_intram = is_intram_enabled
    pricearray := array.new_float(0)
    labelarray := array.new_label(0)

    // ════════════════════════════════════════════════════════════════════════════
    // 4H LEVEL DRAWING
    // ════════════════════════════════════════════════════════════════════════════
    if can_draw_intra
        int intra_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intra_time := get_limit_right(radistance)

        var line intra_line = line.new(x1=intra_time, x2=intra_limit_right, y1=intra_open, y2=intra_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label intra_label = label.new(x=intra_limit_right, y=intra_open, text=iotext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intra_line, intra_time)
        line.set_x2(intra_line, intra_limit_right)
        line.set_y1(intra_line, intra_open)
        line.set_y2(intra_line, intra_open)
        label.set_x(intra_label, intra_limit_right)
        label.set_y(intra_label, intra_open)
        label.set_text(intra_label, iotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intra_open, intra_label, IntraColor)
    // 4H High Level
    if can_draw_intrah
        int intrah_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intrah_time := get_limit_right(radistance)

        var line intrah_line = line.new(x1=intrah_time, x2=intrah_limit_right, y1=intrah_open, y2=intrah_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label intrah_label = label.new(x=intrah_limit_right, y=intrah_open, text=pihtext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intrah_line, intrah_time)
        line.set_x2(intrah_line, intrah_limit_right)
        line.set_y1(intrah_line, intrah_open)
        line.set_y2(intrah_line, intrah_open)
        label.set_x(intrah_label, intrah_limit_right)
        label.set_y(intrah_label, intrah_open)
        label.set_text(intrah_label, pihtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intrah_open, intrah_label, IntraColor)
    // 4H Low Level
    if can_draw_intral
        int intral_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            intral_time := get_limit_right(radistance)

        var line intral_line = line.new(x1=intral_time, x2=intral_limit_right, y1=intral_open, y2=intral_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label intral_label = label.new(x=intral_limit_right, y=intral_open, text=piltext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(intral_line, intral_time)
        line.set_x2(intral_line, intral_limit_right)
        line.set_y1(intral_line, intral_open)
        line.set_y2(intral_line, intral_open)
        label.set_x(intral_label, intral_limit_right)
        label.set_y(intral_label, intral_open)
        label.set_text(intral_label, piltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intral_open, intral_label, IntraColor)
    // 4H Mid Level
    if can_draw_intram
        int intram_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        int intram_time = intrah_time
        float intram_open = (intral_open + intrah_open) / 2
        if displayStyle == 'Right Anchored'
            intram_time := get_limit_right(radistance)

        var line intram_line = line.new(x1=intram_time, x2=intram_limit_right, y1=intram_open, y2=intram_open, color=IntraColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label intram_label = label.new(x=intram_limit_right, y=intram_open, text=pimtext, style=DEFAULT_LABEL_STYLE, textcolor=IntraColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(intram_line, intram_time)
        line.set_x2(intram_line, intram_limit_right)
        line.set_y1(intram_line, intram_open)
        line.set_y2(intram_line, intram_open)
        label.set_x(intram_label, intram_limit_right)
        label.set_y(intram_label, intram_open)
        label.set_text(intram_label, pimtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, intram_open, intram_label, IntraColor)
    // ════════════════════════════════════════════════════════════════════════════
    // MONDAY RANGE DRAWING
    // ════════════════════════════════════════════════════════════════════════════
    // Monday High
    if is_monday_enabled
        int monday_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)

        var line monday_line = line.new(x1=monday_time, x2=monday_limit_right, y1=monday_high, y2=monday_high, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label monday_label = label.new(x=monday_limit_right, y=monday_high, text=pmonhtext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monday_line, monday_time)
        line.set_x2(monday_line, monday_limit_right)
        line.set_y1(monday_line, monday_high)
        line.set_y2(monday_line, monday_high)
        label.set_x(monday_label, monday_limit_right)
        label.set_y(monday_label, monday_high)
        label.set_text(monday_label, pmonhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monday_high, monday_label, MondayColor)

    // Monday Low
    if is_monday_enabled
        int monday_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)

        var line monday_low_line = line.new(x1=monday_time, x2=monday_limit_right, y1=monday_low, y2=monday_low, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label monday_low_label = label.new(x=monday_limit_right, y=monday_low, text=pmonltext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monday_low_line, monday_time)
        line.set_x2(monday_low_line, monday_limit_right)
        line.set_y1(monday_low_line, monday_low)
        line.set_y2(monday_low_line, monday_low)
        label.set_x(monday_low_label, monday_limit_right)
        label.set_y(monday_low_label, monday_low)
        label.set_text(monday_low_label, pmonltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monday_low, monday_low_label, MondayColor)

    // Monday Mid
    if is_monday_mid
        int mondaym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        float mondaym_open = (monday_high + monday_low) / 2
        if displayStyle == 'Right Anchored'
            monday_time := get_limit_right(radistance)

        var line mondaym_line = line.new(x1=monday_time, x2=mondaym_limit_right, y1=mondaym_open, y2=mondaym_open, color=MondayColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label mondaym_label = label.new(x=mondaym_limit_right, y=mondaym_open, text=pmonmtext, style=DEFAULT_LABEL_STYLE, textcolor=MondayColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(mondaym_line, monday_time)
        line.set_x2(mondaym_line, mondaym_limit_right)
        line.set_y1(mondaym_line, mondaym_open)
        line.set_y2(mondaym_line, mondaym_open)
        label.set_x(mondaym_label, mondaym_limit_right)
        label.set_y(mondaym_label, mondaym_open)
        label.set_text(mondaym_label, pmonmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, mondaym_open, mondaym_label, MondayColor)
    // ════════════════════════════════════════════════════════════════════════════
    // DAILY LEVEL DRAWING
    // ════════════════════════════════════════════════════════════════════════════
    // Daily Open
    if is_daily_enabled
        int daily_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            daily_time := get_limit_right(radistance)

        var line daily_line = line.new(x1=daily_time, x2=daily_limit_right, y1=daily_open, y2=daily_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label daily_label = label.new(x=daily_limit_right, y=daily_open, text=dotext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(daily_line, daily_time)
        line.set_x2(daily_line, daily_limit_right)
        line.set_y1(daily_line, daily_open)
        line.set_y2(daily_line, daily_open)
        label.set_x(daily_label, daily_limit_right)
        label.set_y(daily_label, daily_open)
        label.set_text(daily_label, dotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, daily_open, daily_label, DailyColor)
    // Daily High
    if is_dailyrange_enabled
        int dailyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            dailyh_time := get_limit_right(radistance)

        var line dailyh_line = line.new(x1=dailyh_time, x2=dailyh_limit_right, y1=dailyh_open, y2=dailyh_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label dailyh_label = label.new(x=dailyh_limit_right, y=dailyh_open, text=pdhtext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(dailyh_line, dailyh_time)
        line.set_x2(dailyh_line, dailyh_limit_right)
        line.set_y1(dailyh_line, dailyh_open)
        line.set_y2(dailyh_line, dailyh_open)
        label.set_x(dailyh_label, dailyh_limit_right)
        label.set_y(dailyh_label, dailyh_open)
        label.set_text(dailyh_label, pdhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailyh_open, dailyh_label, DailyColor)
    // Daily Low
    if is_dailyrange_enabled
        int dailyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            dailyl_time := get_limit_right(radistance)

        var line dailyl_line = line.new(x1=dailyl_time, x2=dailyl_limit_right, y1=dailyl_open, y2=dailyl_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label dailyl_label = label.new(x=dailyl_limit_right, y=dailyl_open, text=pdltext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(dailyl_line, dailyl_time)
        line.set_x2(dailyl_line, dailyl_limit_right)
        line.set_y1(dailyl_line, dailyl_open)
        line.set_y2(dailyl_line, dailyl_open)
        label.set_x(dailyl_label, dailyl_limit_right)
        label.set_y(dailyl_label, dailyl_open)
        label.set_text(dailyl_label, pdltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailyl_open, dailyl_label, DailyColor)
    // Daily Mid
    if is_dailym_enabled
        int dailym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        int dailym_time = dailyh_time
        float dailym_open = (dailyl_open + dailyh_open) / 2
        if displayStyle == 'Right Anchored'
            dailym_time := get_limit_right(radistance)
        var line dailym_line = line.new(x1=dailym_time, x2=dailym_limit_right, y1=dailym_open, y2=dailym_open, color=DailyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label dailym_label = label.new(x=dailym_limit_right, y=dailym_open, text=pdmtext, style=DEFAULT_LABEL_STYLE, textcolor=DailyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(dailym_line, dailym_time)
        line.set_x2(dailym_line, dailym_limit_right)
        line.set_y1(dailym_line, dailym_open)
        line.set_y2(dailym_line, dailym_open)
        label.set_x(dailym_label, dailym_limit_right)
        label.set_y(dailym_label, dailym_open)
        label.set_text(dailym_label, pdmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, dailym_open, dailym_label, DailyColor)

    // ════════════════════════════════════════════════════════════════════════════
    // WEEKLY LEVEL DRAWING
    // ════════════════════════════════════════════════════════════════════════════
    // Weekly Open
    if is_weekly_enabled
        int weekly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        int cweekly_time = weekly_time
        if displayStyle == 'Right Anchored'
            cweekly_time := get_limit_right(radistance)

        var line weekly_line = line.new(x1=cweekly_time, x2=weekly_limit_right, y1=weekly_open, y2=weekly_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label weekly_label = label.new(x=weekly_limit_right, y=weekly_open, text=wotext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weekly_line, cweekly_time)
        line.set_x2(weekly_line, weekly_limit_right)
        line.set_y1(weekly_line, weekly_open)
        line.set_y2(weekly_line, weekly_open)
        label.set_x(weekly_label, weekly_limit_right)
        label.set_y(weekly_label, weekly_open)
        label.set_text(weekly_label, wotext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weekly_open, weekly_label, WeeklyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label
    // if is_weekly_open and can_show_daily
            // label.set_text(weekly_label, "DO / WO            ")
    // Weekly High
    if is_weeklyrange_enabled
        int weeklyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            weeklyh_time := get_limit_right(radistance)

        var line weeklyh_line = line.new(x1=weeklyh_time, x2=weeklyh_limit_right, y1=weeklyh_open, y2=weeklyh_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label weeklyh_label = label.new(x=weeklyh_limit_right, y=weeklyh_open, text=pwhtext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weeklyh_line, weeklyh_time)
        line.set_x2(weeklyh_line, weeklyh_limit_right)
        line.set_y1(weeklyh_line, weeklyh_open)
        line.set_y2(weeklyh_line, weeklyh_open)
        label.set_x(weeklyh_label, weeklyh_limit_right)
        label.set_y(weeklyh_label, weeklyh_open)
        label.set_text(weeklyh_label, pwhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklyh_open, weeklyh_label, WeeklyColor)
    // Weekly Low
    if is_weeklyrange_enabled
        int weeklyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            weeklyl_time := get_limit_right(radistance)

        var line weeklyl_line = line.new(x1=weeklyl_time, x2=weeklyl_limit_right, y1=weekly_open, y2=weekly_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label weeklyl_label = label.new(x=weeklyl_limit_right, y=weeklyl_open, text=pwltext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(weeklyl_line, weeklyl_time)
        line.set_x2(weeklyl_line, weeklyl_limit_right)
        line.set_y1(weeklyl_line, weeklyl_open)
        line.set_y2(weeklyl_line, weeklyl_open)
        label.set_x(weeklyl_label, weeklyl_limit_right)
        label.set_y(weeklyl_label, weeklyl_open)
        label.set_text(weeklyl_label, pwltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklyl_open, weeklyl_label, WeeklyColor)

    // Weekly Mid
    if is_weekly_mid
        int weeklym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        int weeklym_time = weeklyh_time
        float weeklym_open = (weeklyl_open + weeklyh_open) / 2
        if displayStyle == 'Right Anchored'
            weeklym_time := get_limit_right(radistance)

        var line weeklym_line = line.new(x1=weeklym_time, x2=weeklym_limit_right, y1=weeklym_open, y2=weeklym_open, color=WeeklyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label weeklym_label = label.new(x=weeklym_limit_right, y=weeklym_open, text=pwmtext, style=DEFAULT_LABEL_STYLE, textcolor=WeeklyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(weeklym_line, weeklym_time)
        line.set_x2(weeklym_line, weeklym_limit_right)
        line.set_y1(weeklym_line, weeklym_open)
        line.set_y2(weeklym_line, weeklym_open)
        label.set_x(weeklym_label, weeklym_limit_right)
        label.set_y(weeklym_label, weeklym_open)
        label.set_text(weeklym_label, pwmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, weeklym_open, weeklym_label, WeeklyColor)
    // ════════════════════════════════════════════════════════════════════════════
    // MONTHLY LEVEL DRAWING
    // ════════════════════════════════════════════════════════════════════════════
    // Monthly Low
    if is_monthlyrange_enabled
        int monthlyl_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthlyl_time := get_limit_right(radistance)

        var line monthlyl_line = line.new(x1=monthlyl_time, x2=monthlyl_limit_right, y1=monthlyl_open, y2=monthlyl_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label monthlyl_label = label.new(x=monthlyl_limit_right, y=monthlyl_open, text=pmltext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyl_line, monthlyl_time)
        line.set_x2(monthlyl_line, monthlyl_limit_right)
        line.set_y1(monthlyl_line, monthlyl_open)
        line.set_y2(monthlyl_line, monthlyl_open)
        label.set_x(monthlyl_label, monthlyl_limit_right)
        label.set_y(monthlyl_label, monthlyl_open)
        label.set_text(monthlyl_label, pmltext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlyl_open, monthlyl_label, MonthlyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label
    // Monthly High
    if is_monthlyrange_enabled
        int monthlyh_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthlyh_time := get_limit_right(radistance)

        var line monthlyh_line = line.new(x1=monthlyh_time, x2=monthlyh_limit_right, y1=monthlyh_open, y2=monthlyh_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label monthlyh_label = label.new(x=monthlyh_limit_right, y=monthlyh_open, text=pmhtext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyh_line, monthlyl_time)
        line.set_x2(monthlyh_line, monthlyh_limit_right)
        line.set_y1(monthlyh_line, monthlyh_open)
        line.set_y2(monthlyh_line, monthlyh_open)
        label.set_x(monthlyh_label, monthlyh_limit_right)
        label.set_y(monthlyh_label, monthlyh_open)
        label.set_text(monthlyh_label, pmhtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlyh_open, monthlyh_label, MonthlyColor)
        // the weekly open can be the daily open too (monday)
        // only the weekly will be draw, in these case we update its label
    // Monthly Mid
    if is_monthly_mid
        int monthlym_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        int monthlym_time = monthlyh_time
        float monthlym_open = (monthlyl_open + monthlyh_open) / 2
        if displayStyle == 'Right Anchored'
            monthlym_time := get_limit_right(radistance)
        var line monthlym_line = line.new(x1=monthlym_time, x2=monthlym_limit_right, y1=monthlym_open, y2=monthlym_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label monthlym_label = label.new(x=monthlym_limit_right, y=monthlym_open, text=pmmtext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)
        line.set_x1(monthlym_line, monthlym_time)
        line.set_x2(monthlym_line, monthlym_limit_right)
        line.set_y1(monthlym_line, monthlym_open)
        line.set_y2(monthlym_line, monthlym_open)
        label.set_x(monthlym_label, monthlym_limit_right)
        label.set_y(monthlym_label, monthlym_open)
        label.set_text(monthlym_label, pmmtext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthlym_open, monthlym_label, MonthlyColor)
    // Monthly Open
    if is_monthly_enabled
        int monthly_limit_right = get_limit_right(DEFAULT_EXTEND_RIGHT)
        if displayStyle == 'Right Anchored'
            monthly_time := get_limit_right(radistance)

        var line monthlyLine = line.new(x1=monthly_time, x2=monthly_limit_right, y1=monthly_open, y2=monthly_open, color=MonthlyColor, width=DEFAULT_LINE_WIDTH, xloc=xloc.bar_time, style=linestyles)
        var label monthlyLabel = label.new(x=monthly_limit_right, y=monthly_open, text=motext, style=DEFAULT_LABEL_STYLE, textcolor=MonthlyColor, size=DEFAULT_LABEL_SIZE, xloc=xloc.bar_time)

        line.set_x1(monthlyLine, monthly_time)
        line.set_x2(monthlyLine, monthly_limit_right)
        line.set_y1(monthlyLine, monthly_open)
        line.set_y2(monthlyLine, monthly_open)
        label.set_x(monthlyLabel, monthly_limit_right)
        label.set_y(monthlyLabel, monthly_open)
        label.set_text(monthlyLabel, motext)
        if mergebool
            f_LevelMerge(pricearray, labelarray, monthly_open, monthlyLabel, MonthlyColor)
/////////////////////////////////////////////////////////////////////////////
        // the monthly open can be the weekly open (monday 1st) and/or daily open too
        // only the monthly will be draw, in these case we update its label
        // if is_monthly_open
        //     if can_show_daily
        //         label.set_text(monthlyLabel, "DO / MO            ")
        //     if is_weekly_open
        //         if can_show_weekly
        //             label.set_text(monthlyLabel, "WO / MO            ")
        //         if can_show_daily and can_show_weekly
        //             label.set_text(monthlyLabel, "DO / WO / MO                ")

        // the start of the line is drew from the first week of the month
        // if the first day of the weekly candle (monday) is the 2nd of the month
        // we fix the start of the line position on the Prev weekly candle
        if timeframe.isweekly and dayofweek(monthly_time) != dayofweek.monday
            line.set_x1(monthlyLine, monthly_time - (weekly_time - weekly_time[1]))

//////////////////////////////////////////////////////////////////////////////////
// ════════════════════════════════════════════════════════════════════════════
// SMART MONEY CONCEPTS (SMC) - CONSTANTS & TOOLTIPS
// ════════════════════════════════════════════════════════════════════════════
color TRANSP_CSS = #ffffff00

// Optimize: Pre-define tooltip strings
string MODE_TOOLTIP          = 'Allows to display historical Structure or only the recent ones'
string STYLE_TOOLTIP         = 'Indicator color theme'
string COLOR_CANDLES_TOOLTIP = 'Display additional candles with a color reflecting the current trend detected by structure'
string SHOW_INTERNAL         = 'Display internal market structure'
string CONFLUENCE_FILTER     = 'Filter non significant internal structure breakouts'
string SHOW_SWING            = 'Display swing market Structure'
string SHOW_SWING_POINTS     = 'Display swing point as labels on the chart'
string SHOW_SWHL_POINTS      = 'Highlight most recent strong and weak high/low points on the chart'
string SHOW_FVG              = 'Display fair values gaps on the chart'
string AUTO_FVG              = 'Filter out non significant fair value gaps'
string FVG_TF                = 'Fair value gaps timeframe'
string EXTEND_FVG            = 'Determine how many bars to extend the Fair Value Gap boxes on chart'

// ════════════════════════════════════════════════════════════════════════════
// SMC - INPUT SETTINGS
// ════════════════════════════════════════════════════════════════════════════
// General Settings
string mode = input.string('Historical', options = ['Historical', 'Present'], group = 'Smart Money Concepts', tooltip = MODE_TOOLTIP)
string style = input.string('Colored', options = ['Colored', 'Monochrome'], group = 'Smart Money Concepts', tooltip = STYLE_TOOLTIP)
bool show_trend = input(true, 'Color Candles', group = 'Smart Money Concepts', tooltip = COLOR_CANDLES_TOOLTIP)

// Internal Structure Settings
bool show_internals = input(true, 'Show Internal Structure', group = 'Real Time Internal Structure', tooltip = SHOW_INTERNAL)
string show_ibull = input.string('All', 'Bullish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'ibull', group = 'Real Time Internal Structure')
color swing_ibull_css = input(#089981, '', inline = 'ibull', group = 'Real Time Internal Structure')
string show_ibear = input.string('All', 'Bearish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'ibear', group = 'Real Time Internal Structure')
color swing_ibear_css = input(#f23645, '', inline = 'ibear', group = 'Real Time Internal Structure')
bool ifilter_confluence = input(true, 'Confluence Filter', group = 'Real Time Internal Structure', tooltip = CONFLUENCE_FILTER)
string internal_structure_size = input.string('Tiny', 'Internal Label Size', options = ['Tiny', 'Small', 'Normal'], group = 'Real Time Internal Structure')

// Swing Structure Settings
bool show_Structure = input(true, 'Show Swing Structure', group = 'Real Time Swing Structure', tooltip = SHOW_SWING)

string show_bull = input.string('All', 'Bullish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'bull', group = 'Real Time Swing Structure')
color swing_bull_css = input(#089981, '', inline = 'bull', group = 'Real Time Swing Structure')
string show_bear = input.string('All', 'Bearish Structure', options = ['All', 'BOS', 'CHoCH'], inline = 'bear', group = 'Real Time Swing Structure')
color swing_bear_css = input(#f23645, '', inline = 'bear', group = 'Real Time Swing Structure')
string swing_structure_size = input.string('Small', 'Swing Label Size', options = ['Tiny', 'Small', 'Normal'], group = 'Real Time Swing Structure')

// Swing Points
bool show_swings = input(false, 'Show Swings Points', inline = 'swings', group = 'Real Time Swing Structure', tooltip = SHOW_SWING_POINTS)
int length = input.int(50, '', minval = 10, inline = 'swings', group = 'Real Time Swing Structure')
bool show_hl_swings = input(true, 'Show Strong/Weak High/Low', group = 'Real Time Swing Structure', tooltip = SHOW_SWHL_POINTS)

// Fair Value Gaps Settings
bool show_fvg = input(true, 'Fair Value Gaps', group = 'Fair Value Gaps', tooltip = SHOW_FVG)
bool fvg_auto = input(true, "Auto Threshold", group = 'Fair Value Gaps', tooltip = AUTO_FVG)
string fvg_tf = input.timeframe('', "Timeframe", group = 'Fair Value Gaps', tooltip = FVG_TF)
color bull_fvg_css = input.color(color.new(#00ff68, 70), 'Bullish FVG', group = 'Fair Value Gaps')
color bear_fvg_css = input.color(color.new(#ff0008, 70), 'Bearish FVG', group = 'Fair Value Gaps')
int fvg_extend = input.int(50, "Extend FVG", minval = 0, group = 'Fair Value Gaps', tooltip = EXTEND_FVG)

// ════════════════════════════════════════════════════════════════════════════
// SMC - HELPER FUNCTIONS
// ════════════════════════════════════════════════════════════════════════════
// Optimize: Add type declarations to all variables
int n = bar_index
float atr = ta.atr(200)
float cmean_range = ta.cum(high - low) / n

// HL Output function
hl() => [high, low]

// Get OHLC values function
get_ohlc() => [close[1], open[1], high, low, high[2], low[2]]

// Display Structure function - optimized with type declarations
display_Structure(int x, float y, string txt, color css, bool dashed, bool down, string lbl_size) =>
    line structure_line = line.new(x, y, n, y, color = css, style = dashed ? line.style_dashed : line.style_solid)
    label structure_lbl = label.new(int(math.avg(x, n)), y, txt, color = TRANSP_CSS, textcolor = css, style = down ? label.style_label_down : label.style_label_up, size = lbl_size)

    if mode == 'Present'
        line.delete(structure_line[1])
        label.delete(structure_lbl[1])

// Swings detection/measurements - optimized with type declarations
swings(int len) =>
    var int os = 0
    float upper = ta.highest(len)
    float lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    float top = os == 0 and os[1] != 0 ? high[len] : 0
    float btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]
        
// Line Style function
get_line_style(string style) =>
    string out = switch style
        '⎯⎯⎯'  => line.style_solid
        '----' => line.style_dashed
        '····' => line.style_dotted
    out

// ════════════════════════════════════════════════════════════════════════════
// SMC - GLOBAL VARIABLES
// ════════════════════════════════════════════════════════════════════════════
// Optimize: Add type declarations to all variables
var int trend = 0
var int itrend = 0

var float top_y = 0.
var int top_x = 0
var float btm_y = 0.
var int btm_x = 0

var float itop_y = 0.
var int itop_x = 0
var float ibtm_y = 0.
var int ibtm_x = 0

var float trail_up = high
var float trail_dn = low
var int trail_up_x = 0
var int trail_dn_x = 0

var bool top_cross = true
var bool btm_cross = true
var bool itop_cross = true
var bool ibtm_cross = true

var string txt_top = ''
var string txt_btm = ''

// Optimize: Simplify color assignments
var color bull_css = style == 'Monochrome' ? #b2b5be : swing_bull_css
var color bear_css = style == 'Monochrome' ? #b2b5be : swing_bear_css
var color ibull_css = style == 'Monochrome' ? #b2b5be : swing_ibull_css
var color ibear_css = style == 'Monochrome' ? #b2b5be : swing_ibear_css

// Optimize: Simplify label size assignment
var string internal_structure_lbl_size = internal_structure_size == 'Tiny' ? size.tiny : internal_structure_size == 'Small' ? size.small : size.normal 

var swing_structure_lbl_size = swing_structure_size == 'Tiny' 
  ? size.tiny 
  : swing_structure_size == 'Small' 
  ? size.small 
  : size.normal 

//Swings
[top, btm] = swings(length)

[itop, ibtm] = swings(5)

//-----------------------------------------------------------------------------}
//Pivot High
//-----------------------------------------------------------------------------{
var line extend_top = na

var label extend_top_lbl = label.new(na, na
  , color = TRANSP_CSS
  , textcolor = bear_css
  , style = label.style_label_down
  , size = size.tiny)

// Optimize: Check if top is not 0 (swings returns 0 when no pivot detected)
if top != 0
    top_cross := true
    txt_top := top > top_y ? 'HH' : 'LH'

    if show_swings
        top_lbl = label.new(n-length, top, txt_top
          , color = TRANSP_CSS
          , textcolor = bear_css
          , style = label.style_label_down
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(top_lbl[1])

    //Extend recent top to last bar
    line.delete(extend_top[1])
    extend_top := line.new(n-length, top, n, top
      , color = bear_css)

    top_y := top
    top_x := n - length

    trail_up := top
    trail_up_x := n - length

// Optimize: Check if itop is not 0
if itop != 0
    itop_cross := true

    itop_y := itop
    itop_x := n - 5

//Trailing maximum
trail_up := math.max(high, trail_up)
trail_up_x := trail_up == high ? n : trail_up_x

//Set top extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_top, trail_up_x, trail_up)
    line.set_xy2(extend_top, n + 20, trail_up)

    label.set_x(extend_top_lbl, n + 20)
    label.set_y(extend_top_lbl, trail_up)
    label.set_text(extend_top_lbl, trend < 0 ? 'Strong High' : 'Weak High')

//-----------------------------------------------------------------------------}
//Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na
  , color = TRANSP_CSS
  , textcolor = bull_css
  , style = label.style_label_up
  , size = size.tiny)

// Optimize: Check if btm is not 0
if btm != 0
    btm_cross := true
    txt_btm := btm < btm_y ? 'LL' : 'HL'
    
    if show_swings
        btm_lbl = label.new(n - length, btm, txt_btm
          , color = TRANSP_CSS
          , textcolor = bull_css
          , style = label.style_label_up
          , size = swing_structure_lbl_size)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    //Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(n - length, btm, n, btm
      , color = bull_css)

    btm_y := btm
    btm_x := n-length

    trail_dn := btm
    trail_dn_x := n-length

// Optimize: Check if ibtm is not 0
if ibtm != 0
    ibtm_cross := true

    ibtm_y := ibtm
    ibtm_x := n - 5

//Trailing minimum
trail_dn := math.min(low, trail_dn)
trail_dn_x := trail_dn == low ? n : trail_dn_x

//Set btm extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_btm, trail_dn_x, trail_dn)
    line.set_xy2(extend_btm, n + 20, trail_dn)

    label.set_x(extend_btm_lbl, n + 20)
    label.set_y(extend_btm_lbl, trail_dn)
    label.set_text(extend_btm_lbl, trend > 0 ? 'Strong Low' : 'Weak Low')

//-----------------------------------------------------------------------------}
//Pivot High BOS/CHoCH
//-----------------------------------------------------------------------------{
//Filtering
var bull_concordant = true

if ifilter_confluence
    bull_concordant := high - math.max(close, open) > math.min(close, open - low)

//Detect internal bullish Structure
bool ibull_structure_detected = ta.crossover(close, itop_y) and itop_cross and top_y != itop_y and bull_concordant
if ibull_structure_detected
    bool choch = false
    
    if itrend < 0
        choch := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    // Optimize: Extract display call outside nested scope for consistency
    bool should_display = show_internals and (show_ibull == 'All' or (show_ibull == 'BOS' and not choch) or (show_ibull == 'CHoCH' and choch))
    if should_display
        display_Structure(itop_x, itop_y, txt, ibull_css, true, true, internal_structure_lbl_size)
    
    itop_cross := false
    itrend := 1

//Detect bullish Structure
bool bull_structure_detected = ta.crossover(close, top_y) and top_cross
if bull_structure_detected
    bool choch = false
    
    if trend < 0
        choch := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    // Optimize: Extract display call outside nested scope for consistency
    bool should_display = show_Structure and (show_bull == 'All' or (show_bull == 'BOS' and not choch) or (show_bull == 'CHoCH' and choch))
    if should_display
        display_Structure(top_x, top_y, txt, bull_css, false, true, swing_structure_lbl_size)
    
    top_cross := false
    trend := 1

//-----------------------------------------------------------------------------}
//Pivot Low BOS/CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if ifilter_confluence
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

//Detect internal bearish Structure
bool ibear_structure_detected = ta.crossunder(close, ibtm_y) and ibtm_cross and btm_y != ibtm_y and bear_concordant
if ibear_structure_detected
    bool choch = false
    
    if itrend > 0
        choch := true
    
    txt = choch ? 'CHoCH' : 'BOS'

    // Optimize: Extract display call outside nested scope for consistency
    bool should_display = show_internals and (show_ibear == 'All' or (show_ibear == 'BOS' and not choch) or (show_ibear == 'CHoCH' and choch))
    if should_display
        display_Structure(ibtm_x, ibtm_y, txt, ibear_css, true, false, internal_structure_lbl_size)
    
    ibtm_cross := false
    itrend := -1

//Detect bearish Structure
bool bear_structure_detected = ta.crossunder(close, btm_y) and btm_cross
if bear_structure_detected
    bool choch = false
    
    if trend > 0
        choch := true

    txt = choch ? 'CHoCH' : 'BOS'
    
    // Optimize: Extract display call outside nested scope for consistency
    bool should_display = show_Structure and (show_bear == 'All' or (show_bear == 'BOS' and not choch) or (show_bear == 'CHoCH' and choch))
    if should_display
        display_Structure(btm_x, btm_y, txt, bear_css, false, false, swing_structure_lbl_size)

    btm_cross := false
    trend := -1

// ════════════════════════════════════════════════════════════════════════════
// FAIR VALUE GAPS (FVG)
// ════════════════════════════════════════════════════════════════════════════
// Optimize: Add type declarations for FVG arrays and variables
var array<box> bullish_fvg_max = array.new_box(0)
var array<box> bullish_fvg_min = array.new_box(0)
var array<box> bearish_fvg_max = array.new_box(0)
var array<box> bearish_fvg_min = array.new_box(0)

float bullish_fvg_avg = na
float bearish_fvg_avg = na

bool bullish_fvg_cnd = false
bool bearish_fvg_cnd = false

// Optimize: Get OHLC values from security request (types inferred from function return)
[src_c1, src_o1, src_h, src_l, src_h2, src_l2] = request.security(syminfo.tickerid, fvg_tf, get_ohlc())

if show_fvg
    // Optimize: Add type declarations and cache calculations
    float delta_per = (src_c1 - src_o1) / src_o1 * 100
    bool change_tf = timeframe.change(fvg_tf)
    float threshold = fvg_auto ? ta.cum(math.abs(change_tf ? delta_per : 0)) / n * 2 : 0

    // Optimize: Cache threshold check for both conditions
    bool bullish_above_threshold = delta_per > threshold
    bool bearish_above_threshold = -delta_per > threshold

    // FVG conditions - optimized with cached values
    bullish_fvg_cnd := src_l > src_h2 and src_c1 > src_h2 and bullish_above_threshold and change_tf
    bearish_fvg_cnd := src_h < src_l2 and src_c1 < src_l2 and bearish_above_threshold and change_tf

    //FVG Areas
    if bullish_fvg_cnd
        array.unshift(bullish_fvg_max, box.new(n-1, src_l, n + fvg_extend, math.avg(src_l, src_h2)
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
        
        array.unshift(bullish_fvg_min, box.new(n-1, math.avg(src_l, src_h2), n + fvg_extend, src_h2
          , border_color = bull_fvg_css
          , bgcolor = bull_fvg_css))
    
    if bearish_fvg_cnd
        array.unshift(bearish_fvg_max, box.new(n-1, src_h, n + fvg_extend, math.avg(src_h, src_l2)
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))
        
        array.unshift(bearish_fvg_min, box.new(n-1, math.avg(src_h, src_l2), n + fvg_extend, src_l2
          , border_color = bear_fvg_css
          , bgcolor = bear_fvg_css))

    for bx in bullish_fvg_min
        if low < box.get_bottom(bx)
            box.delete(bx)
            box.delete(array.get(bullish_fvg_max, array.indexof(bullish_fvg_min, bx)))
    
    for bx in bearish_fvg_max
        if high > box.get_top(bx)
            box.delete(bx)
            box.delete(array.get(bearish_fvg_min, array.indexof(bearish_fvg_max, bx)))

// ════════════════════════════════════════════════════════════════════════════
// TREND COLORING
// ════════════════════════════════════════════════════════════════════════════
var color trend_css = na

if show_trend
    // Optimize: Simplify color assignment
    trend_css := style == 'Colored' ? (itrend == 1 ? bull_css : bear_css) : (itrend == 1 ? #b2b5be : #5d606b)

plotcandle(open, high, low, close, color = trend_css, wickcolor = trend_css, bordercolor = trend_css, editable = false)