//@version=5
indicator("RVWAP", "RVWAP", true)

// ———————————————————— Constants and Inputs {

int MS_IN_MIN   = 60 * 1000
int MS_IN_HOUR  = MS_IN_MIN  * 60
int MS_IN_DAY   = MS_IN_HOUR * 24

string TT_SRC     = "The source used to calculate the VWAP. The default is the average of high, low, and close prices."
string TT_TF      = "The timeframe used to calculate all RVWAPs. This ensures consistency across chart timeframes."

// Inputs
float srcInput    = input.source(hlc3, "Source", tooltip = TT_SRC)
string tfInput    = input.timeframe("1D", "RVWAP Timeframe", tooltip = TT_TF)

// Fetch data from fixed timeframe
float fixedSrc = request.security(syminfo.tickerid, tfInput, hlc3, lookahead = barmerge.lookahead_off)
float fixedVol = request.security(syminfo.tickerid, tfInput, volume, lookahead = barmerge.lookahead_off)

// Time periods
int time_1w       = 7   * MS_IN_DAY
int time_1m       = 30  * MS_IN_DAY
int time_3m       = 90  * MS_IN_DAY
int time_1y       = 365 * MS_IN_DAY

// Toggle for each period
bool show_1w      = input.bool(true, "Show weekly RVWAP", inline = "1w1")
color color_1w    = input.color(color.new(color.white, 25), "", inline = "1w1")
bool show_1m      = input.bool(true, "Show monthly RVWAP", inline = "1m1")
color color_1m    = input.color(color.new(color.white, 25), "", inline = "1m1")
bool show_3m      = input.bool(true, "Show quarterly RVWAP", inline = "3m1")
color color_3m    = input.color(color.new(color.white, 25), "", inline = "3m1")
bool show_1y      = input.bool(true, "Show yearly RVWAP", inline = "1y1")
color color_1y    = input.color(color.new(color.white, 25), "", inline = "1y1")

int minBarsInput    = input.int(10, "Minimum Bars", tooltip = "Minimum number of bars to keep in the window.")

// ———————————————————— Calculations {

import PineCoders/ConditionalAverages/1 as pc

// Stop the indicator on charts with no volume
if barstate.islast and ta.cum(nz(fixedVol)) == 0
    runtime.error("No volume is provided by the data vendor.")

// Function to calculate RVWAP
rvwap_calc(int timeInMs) =>
    float sumSrcVol    = pc.totalForTimeWhen(fixedSrc * fixedVol, timeInMs, true, minBarsInput)
    float sumVol       = pc.totalForTimeWhen(fixedVol, timeInMs, true, minBarsInput)
    sumSrcVol / sumVol

// Calculate RVWAP for each period
float rvwap_1w   = rvwap_calc(time_1w)
float rvwap_1m   = rvwap_calc(time_1m)
float rvwap_3m   = rvwap_calc(time_3m)
float rvwap_1y   = rvwap_calc(time_1y)

// ———————————————————— Plots {

plot(show_1w ? rvwap_1w : na, "Weekly RVWAP", color_1w, linewidth = 1)
plot(show_1m ? rvwap_1m : na, "Monthly RVWAP", color_1m, linewidth = 2)
plot(show_3m ? rvwap_3m : na, "Quarterly RVWAP", color_3m, linewidth = 3)
plot(show_1y ? rvwap_1y : na, "Yearly RVWAP", color_1y, linewidth = 4)

// Create label variables that persist across bars
var label label_1w = na
var label label_1m = na
var label label_3m = na
var label label_1y = na

// Update or create labels on the last bar
if barstate.islast
    if show_1w
        label.delete(label_1w)
        label_1w := label.new(bar_index, rvwap_1w, "w-RVWAP", color=color.new(color.white, 100), textcolor=color.new(color.white, 25), style=label.style_label_left)
    
    if show_1m
        label.delete(label_1m)
        label_1m := label.new(bar_index, rvwap_1m, "m-RVWAP", color=color.new(color.white, 100), textcolor=color.new(color.white, 25), style=label.style_label_left)
    
    if show_3m
        label.delete(label_3m)
        label_3m := label.new(bar_index, rvwap_3m, "q-RVWAP", color=color.new(color.white, 100), textcolor=color.new(color.white, 25), style=label.style_label_left)
    
    if show_1y
        label.delete(label_1y)
        label_1y := label.new(bar_index, rvwap_1y, "y-RVWAP", color=color.new(color.white, 100), textcolor=color.new(color.white, 25), style=label.style_label_left)