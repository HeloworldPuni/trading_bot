//@version=6
strategy("Intraday Modular Scoring Strategy", overlay=true, margin_long=100, margin_short=100,
default_qty_type=strategy.percent_of_equity, default_qty_value=10, calc_on_every_tick=false)

// =============================================================
//                    CUSTOM ADX FUNCTION
// =============================================================
// Computes ADX using Wilder's smoothing technique.
adx_calc(len) =>
// Calculate directional movements
up_move   = high - high[1]
down_move = low[1] - low
plus_dm   = (up_move > down_move and up_move > 0) ? up_move : 0.0
minus_dm  = (down_move > up_move and down_move > 0) ? down_move : 0.0
// True range calculation
tr = ta.tr(true)
// Wilder smoothing (using RMA) for ATR and DMs
atr      = ta.rma(tr, len)
plus_dm_rma  = ta.rma(plus_dm, len)
minus_dm_rma = ta.rma(minus_dm, len)
// Calculate DI values
plus_di   = 100 * plus_dm_rma / atr
minus_di  = 100 * minus_dm_rma / atr
// Compute DX and then ADX
dx       = 100 * math.abs(plus_di - minus_di) / (plus_di + minus_di)
adx_val  = ta.rma(dx, len)
adx_val

// =============================================================
//                       GENERAL INPUTS
// =============================================================
execution_tf          = input.string("chart", "Execution timeframe", options = ["chart", "1", "5"], group = "01-General")
mtf_confirmation      = input.string("Off", "Higher-TF confirmation", options = ["Off", "15", "60", "D"], group = "01-General")
signal_mode           = input.string("Scoring", "Signal mode", options = ["Scoring", "Strict"], group = "01-General", tooltip = "Scoring sums weighted module signals; Strict requires all enabled modules to agree in direction.")
intrabar_preview      = input.bool(false, "Intrabar preview (may repaint)", group = "01-General", tooltip = "If enabled, signals may trigger inside the bar (repainting). Disabled uses barstate.isconfirmed to avoid repainting.")
score_threshold_long  = input.float(1.5, "Score threshold long", step = 0.1, group = "01-General")
score_threshold_short = input.float(-1.5, "Score threshold short", step = 0.1, group = "01-General")

// =============================================================
//                       TREND MODULE
// =============================================================
trend_enabled   = input.bool(true, "Enable trend module", group = "02-Trend")
trend_weight    = input.int(2, "Trend weight (−3..+3)", minval = -3, maxval = 3, group = "02-Trend")
ema_fast_len    = input.int(9, "Fast EMA length", group = "02-Trend")
ema_slow_len    = input.int(21, "Slow EMA length", group = "02-Trend")
adx_len         = input.int(14, "ADX length", group = "02-Trend")
adx_threshold   = input.float(25, "ADX trend threshold", group = "02-Trend", tooltip = "Above this value market is considered trending.")
htf_confirm     = input.bool(false, "Require higher-TF alignment", group = "02-Trend")

// =============================================================
//                       MOMENTUM MODULE
// =============================================================
momo_enabled     = input.bool(true, "Enable momentum module", group = "03-Momentum")
momo_weight      = input.int(2, "Momentum weight (−3..+3)", minval = -3, maxval = 3, group = "03-Momentum")
rsi_len          = input.int(14, "RSI length", group = "03-Momentum")
stoch_len        = input.int(14, "StochRSI length", group = "03-Momentum")
stoch_k_smooth   = input.int(3, "StochRSI K smooth", group = "03-Momentum")
stoch_d_smooth   = input.int(3, "StochRSI D smooth", group = "03-Momentum")
momo_overbought  = input.float(0.8, "StochRSI overbought", group = "03-Momentum")
momo_oversold    = input.float(0.2, "StochRSI oversold", group = "03-Momentum")

// =============================================================
//                       LOCATION MODULE
// =============================================================
location_enabled = input.bool(true, "Enable location module", group = "04-Location")
location_weight  = input.int(1, "Location weight (−3..+3)", minval = -3, maxval = 3, group = "04-Location")

// =============================================================
//                       FLOW MODULE
// =============================================================
flow_enabled     = input.bool(true, "Enable flow module (MFI)", group = "05-Flow")
flow_weight      = input.int(1, "Flow weight (−3..+3)", minval = -3, maxval = 3, group = "05-Flow")
mfi_len          = input.int(14, "MFI length", group = "05-Flow")
flow_overbought  = input.float(80, "MFI overbought", group = "05-Flow")
flow_oversold    = input.float(20, "MFI oversold", group = "05-Flow")

// =============================================================
//                       REGIME MODULE
// =============================================================
regime_enabled   = input.bool(true, "Enable regime module", group = "06-Regime")
regime_weight    = input.int(1, "Regime weight (−3..+3)", minval = -3, maxval = 3, group = "06-Regime")
atr_regime_len   = input.int(21, "ATR regime length", group = "06-Regime")
atr_ma_len       = input.int(50, "ATR moving average length", group = "06-Regime")
regime_factor    = input.float(1.0, "ATR expansion factor", group = "06-Regime", tooltip = "If current ATR is this multiple above its SMA, market is considered expanding/trending.")

// =============================================================
//                       STRUCTURE MODULE
// =============================================================
structure_enabled = input.bool(true, "Enable structure module (fractals)", group = "07-Structure")
structure_weight  = input.int(2, "Structure weight (−3..+3)", minval = -3, maxval = 3, group = "07-Structure")
fractal_left      = input.int(2, "Fractal left bars", group = "07-Structure")
fractal_right     = input.int(2, "Fractal right bars", group = "07-Structure")

// =============================================================
//                       QUALITY FILTERS
// =============================================================
quality_enabled    = input.bool(true, "Enable quality filters", group = "08-Quality")
use_session        = input.bool(true, "Use RTH session filter", group = "08-Quality")
session_str        = input.session("0930-1600", "RTH session", group = "08-Quality")
min_volume         = input.float(0, "Min volume per bar", group = "08-Quality")
min_dollar         = input.float(0, "Min $/bar (price*volume)", group = "08-Quality")
max_spread_pct     = input.float(1.0, "Max spread %", group = "08-Quality", tooltip = "(high-low)/close * 100 must be below this.")
skip_first_minutes = input.int(0, "Skip first N minutes of session", group = "08-Quality")
skip_last_minutes  = input.int(0, "Skip last N minutes of session", group = "08-Quality")

// =============================================================
//                       RISK MANAGEMENT
// =============================================================
risk_enabled  = input.bool(true, "Enable risk management", group = "09-Risk")
atr_stop_len  = input.int(14, "ATR length for stops", group = "09-Risk")
stop_mult     = input.float(1.5, "Stop multiplier (ATR)", group = "09-Risk")
tp1_mult      = input.float(1.0, "Take-profit 1 multiple", group = "09-Risk")
tp2_mult      = input.float(2.0, "Take-profit 2 multiple", group = "09-Risk")
tp1_percent   = input.float(50.0, "Percent to close at TP1", step = 1.0, group = "09-Risk")
tp2_percent   = input.float(50.0, "Percent to close at TP2", step = 1.0, group = "09-Risk")
trail_enabled = input.bool(false, "Enable trailing stop", group = "09-Risk")
trail_mult    = input.float(1.0, "Trailing stop multiple (ATR)", group = "09-Risk")

risk_mode     = input.string("Fixed", "Position sizing mode", options = ["Fixed", "Risk%"], group = "09-Risk")
fixed_qty     = input.float(1.0, "Fixed quantity", group = "09-Risk")
risk_percent  = input.float(1.0, "Risk % of equity per trade", group = "09-Risk")

// =============================================================
//                    UTILITY FUNCTIONS
// =============================================================

// Use barstate.isconfirmed unless intrabar preview is allowed
bar_confirmed() =>
intrabar_preview ? true : barstate.isconfirmed

// Non-repainting MTF helper (lookahead OFF, gaps OFF)
no_repaint_security(_symbol, _timeframe, _expr) =>
request.security(_symbol, _timeframe, _expr, gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_off)

f_quality() =>
// ── Session filter ───────────────────────────────────────
inSession = not use_session or not na(time(timeframe.period, session_str))
// ── Volume & $/bar filters ───────────────────────────────
volOk    = min_volume <= 0 or volume >= min_volume
dollarOk = min_dollar <= 0 or (close * volume) >= min_dollar
// ── Spread filter ────────────────────────────────────────
spreadPct = (high - low) / math.max(close, 1e-10) * 100
spreadOk  = spreadPct <= max_spread_pct
// ── Final verdict ────────────────────────────────────────
inSession and volOk and dollarOk and spreadOk

// ------------------------- TREND ------------------------------
f_trend() =>
// ── Current-time-frame trend ─────────────────────────────
emaFast = ta.ema(close, ema_fast_len)
emaSlow = ta.ema(close, ema_slow_len)
// Replace built-in ta.adx() with custom adx_calc()
adxVal  = adx_calc(adx_len)
int dir = emaFast > emaSlow and adxVal > adx_threshold ? 1 :
emaFast < emaSlow and adxVal > adx_threshold ? -1 : 0
// ── Optional higher-TF confirmation ──────────────────────
if htf_confirm and mtf_confirmation != "Off"
  emaFastHTF = no_repaint_security(syminfo.tickerid, mtf_confirmation, ta.ema(close, ema_fast_len))
emaSlowHTF = no_repaint_security(syminfo.tickerid, mtf_confirmation, ta.ema(close, ema_slow_len))
adxHTF     = no_repaint_security(syminfo.tickerid, mtf_confirmation, adx_calc(adx_len))
int htfDir = emaFastHTF > emaSlowHTF and adxHTF > adx_threshold ? 1 :
emaFastHTF < emaSlowHTF and adxHTF > adx_threshold ? -1 : 0
// Keep the signal only if both TFs agree
dir := dir == htfDir ? dir : 0
dir

// --------------------------- MOMENTUM ---------------------------
f_momentum() =>
rsiVal   = ta.rsi(close, rsi_len)
stochRSI = (rsiVal - ta.lowest(rsiVal, stoch_len)) / math.max(ta.highest(rsiVal, stoch_len) - ta.lowest(rsiVal, stoch_len), 1e-10)
k = ta.sma(stochRSI, stoch_k_smooth)
d = ta.sma(k, stoch_d_smooth)
crossUp   = ta.crossover(k, d)
crossDown = ta.crossunder(k, d)
float momoScore = 0.0
if crossUp and k > 0.5 and bar_confirmed()
  momoScore := 1.0
else if crossDown and k < 0.5 and bar_confirmed()
  momoScore := -1.0
else if k > momo_overbought and bar_confirmed()
  momoScore := -1.0
else if k < momo_oversold and bar_confirmed()
  momoScore := 1.0
else
momoScore := 0.0
momoScore

// --------------------------- LOCATION ---------------------------
f_location() =>
vwapVal = ta.vwap
int result = close > vwapVal ? 1 : close < vwapVal ? -1 : 0
result

// ----------------------------- FLOW -----------------------------
f_flow() =>
mfiVal = ta.mfi(high, low, close, volume, mfi_len)
float res = 0.0
if mfiVal > flow_overbought
  res := -1.0
else if mfiVal < flow_oversold
  res := 1.0
else if mfiVal > 50
  res := 1.0
else
res := -1.0
res

// ---------------------------- REGIME ----------------------------
f_regime() =>
atrVal = ta.atr(atr_regime_len)
atrAvg = ta.sma(atrVal, atr_ma_len)
atrAvg > 0 and atrVal > atrAvg * regime_factor ? 1 : atrAvg > 0 and atrVal < atrAvg / math.max(regime_factor, 1e-10) ? -1 : 0

// -------------------------- STRUCTURE ---------------------------
var float lastPivotHigh = na
var float lastPivotLow  = na

f_structure() =>
ph = ta.pivothigh(high, fractal_left, fractal_right)
pl = ta.pivotlow(low, fractal_left, fractal_right)
if not na(ph)
  lastPivotHigh := ph
if not na(pl)
  lastPivotLow := pl
float structScore = 0.0
if not na(lastPivotHigh) and close > lastPivotHigh
  structScore := 1.0
else if not na(lastPivotLow) and close < lastPivotLow
  structScore := -1.0
structScore

// =============================================================
//                       MAIN CALCULATIONS
// =============================================================
qualityOk   = not quality_enabled or f_quality()

trendSig    = trend_enabled     ? f_trend()     : na
momoSig     = momo_enabled      ? f_momentum()  : na
locationSig = location_enabled  ? f_location()  : na
flowSig     = flow_enabled      ? f_flow()      : na
regSig      = regime_enabled    ? f_regime()    : na
structSig   = structure_enabled ? f_structure() : na

float aggregatedScore = 0.0
if trend_enabled
  aggregatedScore += trend_weight * nz(trendSig)
if momo_enabled
  aggregatedScore += momo_weight * nz(momoSig)
if location_enabled
  aggregatedScore += location_weight * nz(locationSig)
if flow_enabled
  aggregatedScore += flow_weight * nz(flowSig)
if regime_enabled
  aggregatedScore += regime_weight * nz(regSig)
if structure_enabled
  aggregatedScore += structure_weight * nz(structSig)

// -------------------------- SIGNALS ----------------------------
var bool longCond  = false
var bool shortCond = false

if qualityOk
  if signal_mode == "Scoring"
    longCond  := aggregatedScore >= score_threshold_long
shortCond := aggregatedScore <= score_threshold_short
else
bool allLong  = true
bool allShort = true
if trend_enabled
  allLong  := allLong  and nz(trendSig) > 0
allShort := allShort and nz(trendSig) < 0
if momo_enabled
  allLong  := allLong  and nz(momoSig) > 0
allShort := allShort and nz(momoSig) < 0
if location_enabled
  allLong  := allLong  and nz(locationSig) > 0
allShort := allShort and nz(locationSig) < 0
if flow_enabled
  allLong  := allLong  and nz(flowSig) > 0
allShort := allShort and nz(flowSig) < 0
if regime_enabled
  allLong  := allLong  and nz(regSig) > 0
allShort := allShort and nz(regSig) < 0
if structure_enabled
  allLong  := allLong  and nz(structSig) > 0
allShort := allShort and nz(structSig) < 0
longCond  := allLong
shortCond := allShort
else
longCond  := false
shortCond := false

canTrade = bar_confirmed()

// ---------------------------- ENTRIES --------------------------
if canTrade and longCond and strategy.position_size <= 0
  float qtyL = fixed_qty
if risk_enabled and risk_mode == "Risk%"
  atrStop   = ta.atr(atr_stop_len) * stop_mult
capital   = strategy.equity * (risk_percent / 100.0)
posSize   = atrStop > 0 ? capital / (atrStop * syminfo.pointvalue) : fixed_qty
qtyL := posSize
strategy.entry("Long", strategy.long, qty = qtyL)

if canTrade and shortCond and strategy.position_size >= 0
  float qtyS = fixed_qty
if risk_enabled and risk_mode == "Risk%"
  atrStop   = ta.atr(atr_stop_len) * stop_mult
capital   = strategy.equity * (risk_percent / 100.0)
posSize   = atrStop > 0 ? capital / (atrStop * syminfo.pointvalue) : fixed_qty
qtyS := posSize
strategy.entry("Short", strategy.short, qty = qtyS)

// ----------------------------- EXITS ---------------------------
if risk_enabled and canTrade
  atrStopNow = ta.atr(atr_stop_len) * stop_mult

// ---- Manage long positions ----
if strategy.position_size > 0
  stopPriceL = strategy.position_avg_price - atrStopNow
tp1L = strategy.position_avg_price + atrStopNow * tp1_mult
tp2L = strategy.position_avg_price + atrStopNow * tp2_mult
strategy.exit("L-TP1", from_entry = "Long", qty_percent = tp1_percent, limit = tp1L, stop = stopPriceL)
strategy.exit("L-TP2", from_entry = "Long", qty_percent = tp2_percent, limit = tp2L, stop = stopPriceL)
if trail_enabled
  strategy.exit("L-Trail", from_entry = "Long", trail_points = atrStopNow * trail_mult)

// ---- Manage short positions ----
if strategy.position_size < 0
  stopPriceS = strategy.position_avg_price + atrStopNow
tp1S = strategy.position_avg_price - atrStopNow * tp1_mult
tp2S = strategy.position_avg_price - atrStopNow * tp2_mult
strategy.exit("S-TP1", from_entry = "Short", qty_percent = tp1_percent, limit = tp1S, stop = stopPriceS)
strategy.exit("S-TP2", from_entry = "Short", qty_percent = tp2_percent, limit = tp2S, stop = stopPriceS)
if trail_enabled
  strategy.exit("S-Trail", from_entry = "Short", trail_points = atrStopNow * trail_mult)

// =============================================================
//                       PLOTTING & ALERTS
// =============================================================
plot(aggregatedScore, "Score", color = color.blue, linewidth = 2, style = plot.style_stepline)

plotshape(longCond and canTrade, title = "Long Signal", style = shape.triangleup, location = location.belowbar,
size = size.small, color = color.new(color.green, 0), text = "BUY")

plotshape(shortCond and canTrade, title = "Short Signal", style = shape.triangledown, location = location.abovebar,
size = size.small, color = color.new(color.red, 0), text = "SELL")

plot(trend_enabled ? trendSig : na, "Trend score", color = color.teal, linewidth = 1)
plot(momo_enabled ? momoSig : na, "Momentum score", color = color.orange, linewidth = 1)
plot(location_enabled ? locationSig : na, "Location score", color = color.purple, linewidth = 1)
plot(flow_enabled ? flowSig : na, "Flow score", color = color.yellow, linewidth = 1)
plot(regime_enabled ? regSig : na, "Regime score", color = color.gray, linewidth = 1)
plot(structure_enabled ? structSig : na, "Structure score", color = color.fuchsia, linewidth = 1)

alertcondition(longCond and canTrade, title = "Long Alert", message = "BUY: Score={{plot_0}}")
alertcondition(shortCond and canTrade, title = "Short Alert", message = "SELL: Score={{plot_0}}")