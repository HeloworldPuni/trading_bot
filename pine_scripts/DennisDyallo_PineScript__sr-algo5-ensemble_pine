//@version=5
indicator("MKN: S/R Ensemble Detector (ALPHA v1.1)", shorttitle="MKN: S/R A5 Ensemble", overlay=true, max_lines_count=100, max_labels_count=30)

// ============================================================================
// ⚠️ ALPHA STATUS: THEORETICAL DESIGN - EMPIRICAL VALIDATION PENDING ⚠️
// ============================================================================
// Combines 4 S/R algorithms with weighted voting and agreement-based filtering
// DEFAULT: Equal weights 25% each (DeMiguel 2009 - safest without testing)
// OPTIONAL: Original weights VP(35%) MTF(30%) STAT(20%) OB(15%) (UNVALIDATED)
// ⚠️ ZERO empirical testing - Use paper trading before risking capital
// ============================================================================

// ============================= LABEL DOCUMENTATION ==========================
//
// WHAT THE LABELS MEAN:
//
// Primary Number: Ensemble Strength Score (0-100)
//   - Weighted combination of all contributing algorithms
//   - Higher = stronger S/R level
//   - Weights (Equal - DEFAULT): 25% each (DeMiguel 2009 - RECOMMENDED)
//   - Weights (Original - OPTIONAL): VP(35%) MTF(30%) STAT(20%) OB(15%) (UNVALIDATED)
//   - Agreement bonuses: 4/4 (+15%), 3/4 (+10%), 2/4 (+5%)
//
// Sources (in parentheses): Which algorithms detected this level
//   - VP   = Volume Profile algorithm
//   - STAT = Statistical Peaks algorithm
//   - MTF  = Multi-Timeframe algorithm
//   - OB   = Order Book algorithm
//
// Examples:
//   - "85 (VP+MTF+STAT)"     = Strength 85, 3/4 agreement
//   - "72 (VP+STAT+MTF+OB)"  = Strength 72, perfect 4/4 agreement
//   - "68 (MTF+STAT)"        = Strength 68, 2/4 agreement
//
// Visual Cues:
//   - Label Size: Normal (3-4 algorithms) or Small (1-2 algorithms)
//   - Label Style: Up arrow (Support) or Down arrow (Resistance)
//   - Label Color: Matches line (green for Support, red for Resistance)
//   - Line Width: Thicker = more agreement (3 for 4/4, 2 for 3/4, 1 for 2/4)
//
// ============================================================================

// ============================= LIBRARY IMPORTS ==============================
import redshad0ww/CoreMath/3 as math_lib
import redshad0ww/RegimeDetection/3 as regime_lib
import redshad0ww/LevelUtils/2 as level_lib
import redshad0ww/MTFUtils/3 as mtf_lib
import redshad0ww/VolumeAnalysis/4 as vol_lib

// ============================= TYPE DEFINITIONS =============================

type SRLevel
    float price
    string levelType        // "Support" or "Resistance"
    float strength          // 0-100
    string source           // "VP", "STAT", "MTF", "OB"

type EnsembleLevel
    float price
    string levelType
    float ensembleStrength
    int agreementCount      // 1-4
    string sources
    string confidence
    color levelColor

// ============================= INPUTS =======================================

// Ensemble
maxLevels = input.int(15, "Max Levels", minval=5, maxval=30, group="Ensemble")
minAgreement = input.int(2, "Min Agreement", minval=1, maxval=4, group="Ensemble")
minStrength = input.int(50, "Min Strength", minval=30, maxval=90, group="Ensemble")
mergeTolerance = input.float(0.015, "Merge Tolerance %", minval=0.005, maxval=0.03, step=0.005, group="Ensemble")
useEqualWeights = input.bool(true, "Use Equal Weights (RECOMMENDED)", group="Ensemble", tooltip="TRUE = Equal weighting 25% each (DeMiguel 2009 - safest without empirical testing)\nFALSE = Original weights VP:35% MTF:30% STAT:20% OB:15% (UNVALIDATED)")

// Algorithm toggles
enableVP = input.bool(true, "Volume Profile", group="Algorithms")
enableStat = input.bool(true, "Statistical", group="Algorithms")
enableMTF = input.bool(true, "MTF", group="Algorithms")
enableOB = input.bool(true, "Order Book", group="Algorithms")

// Algorithm 1: Volume Profile
vpLookback = input.int(100, "VP Lookback", minval=50, maxval=500, group="Volume Profile")
vpBins = input.int(30, "VP Bins", minval=20, maxval=60, group="Volume Profile")
vpMinStrength = input.int(60, "VP Min Strength", minval=40, maxval=85, group="Volume Profile")

// Algorithm 2: Statistical
statSwing = input.int(10, "Stat Swing", minval=5, maxval=20, group="Statistical")
statMinCluster = input.int(2, "Stat Min Cluster", minval=1, maxval=5, group="Statistical")
statDecay = input.float(0.9942, "Stat Decay", minval=0.85, maxval=0.998, step=0.0002, group="Statistical")

// Algorithm 3: MTF (Import from standalone sr-algo3-mtf-confluence)
useMTFImport = input.bool(false, "Use MTF Import (requires Algo3 indicator)", group="MTF Import", tooltip="Enable to import levels from standalone sr-algo3-mtf-confluence indicator")
mtfLevel1Source = input.source(close, "MTF Level 1", group="MTF Import", tooltip="Add sr-algo3-mtf-confluence to chart, then select its Level1 plot")
mtfLevel2Source = input.source(close, "MTF Level 2", group="MTF Import")
mtfLevel3Source = input.source(close, "MTF Level 3", group="MTF Import")
mtfLevel4Source = input.source(close, "MTF Level 4", group="MTF Import")
mtfLevel5Source = input.source(close, "MTF Level 5", group="MTF Import")
mtfLevel6Source = input.source(close, "MTF Level 6", group="MTF Import")
mtfLevel7Source = input.source(close, "MTF Level 7", group="MTF Import")
mtfLevel8Source = input.source(close, "MTF Level 8", group="MTF Import")
mtfLevel9Source = input.source(close, "MTF Level 9", group="MTF Import")
mtfLevel10Source = input.source(close, "MTF Level 10", group="MTF Import")

// Fallback: Simple pivot detection (if not using import)
mtfSwing = input.int(8, "MTF Swing (fallback)", minval=5, maxval=20, group="MTF Fallback", tooltip="Only used if MTF Import is disabled")

// Algorithm 4: Order Book
obLookback = input.int(100, "OB Lookback", minval=50, maxval=500, group="Order Book")
obMinWick = input.float(0.3, "OB Min Wick", minval=0.1, maxval=2.0, step=0.1, group="Order Book")
obMinReject = input.int(2, "OB Min Rejections", minval=1, maxval=5, group="Order Book")

// Display
showLabels = input.bool(true, "Show Labels", group="Display")
showSources = input.bool(true, "Show Sources", group="Display")
showTable = input.bool(true, "Show Table", group="Display")

// Regime
useRegime = input.bool(true, "Enable Regime", group="Regime")
atrLen = input.int(14, "ATR Length", minval=7, maxval=50, group="Regime")
atrLook = input.int(50, "ATR Lookback", minval=20, maxval=100, group="Regime")

// ============================= SHARED CALCULATIONS ==========================

regimeData = regime_lib.detectRegime(atrLen, atrLook)
regimeMult = regimeData.multiplier
currentATR = ta.atr(atrLen)

// ============================= HELPER FUNCTIONS =============================

// Object-based clustering - NO parallel arrays = NO synchronization bugs!
// Takes array of SRLevel objects, returns clustered array of SRLevel objects
f_clusterLevels(array<SRLevel> levels, float tolerance) =>
    array<SRLevel> result = array.new<SRLevel>()  // No 'var' - create new array each call!

    levelCount = array.size(levels)

    if levelCount == 0
        result  // Return empty array immediately
    else
        // Create fresh visited array for THIS call (no 'var' = no persistent state bug)
        array<bool> visited = array.new_bool()

        // Initialize visited array
        for i = 0 to levelCount - 1
            array.push(visited, false)

        // Cluster levels
        for i = 0 to levelCount - 1
            if not array.get(visited, i)
                currentLevel = array.get(levels, i)

                // Start cluster
                clusterPrice = currentLevel.price
                clusterLevelType = currentLevel.levelType
                clusterStrength = currentLevel.strength
                clusterSource = currentLevel.source
                clusterCount = 1

                array.set(visited, i, true)

                // Find neighbors (same type only)
                for j = i + 1 to levelCount - 1
                    // Defensive bounds check (should be redundant but prevents edge cases)
                    if j >= 0 and j < levelCount
                        if not array.get(visited, j)
                            otherLevel = array.get(levels, j)
                            distance = math.abs(clusterPrice - otherLevel.price) / clusterPrice

                            if distance <= tolerance and clusterLevelType == otherLevel.levelType
                                // Weighted average by strength
                                totalStrength = clusterStrength * clusterCount + otherLevel.strength
                                clusterPrice := (clusterPrice * clusterCount + otherLevel.price) / (clusterCount + 1)
                                clusterCount += 1
                                clusterStrength := totalStrength / clusterCount

                                // Merge sources
                                if not str.contains(clusterSource, otherLevel.source)
                                    clusterSource += "+" + otherLevel.source

                                array.set(visited, j, true)

                // Add clustered level
                array.push(result, SRLevel.new(clusterPrice, clusterLevelType, clusterStrength, clusterSource))

        result

// ============================= ALGORITHM 1: VOLUME PROFILE ==================

var array<SRLevel> vpLevels = array.new<SRLevel>()

// Extract ta functions outside conditional for consistency
highestPrice = ta.highest(high, vpLookback)
lowestPrice = ta.lowest(low, vpLookback)

if enableVP and barstate.isconfirmed
    array.clear(vpLevels)

    priceRange = highestPrice - lowestPrice

    if priceRange > 0
        binSize = priceRange / vpBins

        array<float> volAtPrice = array.new_float()
        for i = 0 to vpBins - 1
            array.push(volAtPrice, 0.0)

        // Build volume profile
        for i = 0 to math.min(vpLookback - 1, bar_index)
            barClosePrice = close[i]
            barVol = volume[i]

            bin = math.floor((barClosePrice - lowestPrice) / binSize)
            bin := math.max(0, math.min(vpBins - 1, bin))

            array.set(volAtPrice, bin, array.get(volAtPrice, bin) + barVol)

        // Find POC
        pocIndex = 0
        pocVol = 0.0
        for i = 0 to vpBins - 1
            vol = array.get(volAtPrice, i)
            if vol > pocVol
                pocVol := vol
                pocIndex := i

        pocPrice = lowestPrice + (pocIndex * binSize) + (binSize / 2)
        pocLevel = SRLevel.new(pocPrice, close > pocPrice ? "Support" : "Resistance", 100.0, "VP")
        array.push(vpLevels, pocLevel)

        // Find HVN levels
        hvnThreshold = array.percentile_nearest_rank(volAtPrice, 85)

        for i = 1 to vpBins - 2
            vol = array.get(volAtPrice, i)
            leftVol = array.get(volAtPrice, i - 1)
            rightVol = array.get(volAtPrice, i + 1)

            if vol > leftVol and vol > rightVol and vol >= hvnThreshold
                if math.abs(i - pocIndex) > 2
                    hvnPrice = lowestPrice + (i * binSize) + (binSize / 2)
                    hvnStrength = 70.0 + (vol / pocVol) * 15

                    if hvnStrength >= vpMinStrength
                        hvnLevel = SRLevel.new(hvnPrice, close > hvnPrice ? "Support" : "Resistance", hvnStrength, "VP")
                        array.push(vpLevels, hvnLevel)

// ============================= ALGORITHM 2: STATISTICAL =====================

var array<SRLevel> statLevels = array.new<SRLevel>()

if enableStat and barstate.isconfirmed
    array.clear(statLevels)

    // Build array of SRLevel objects directly (no parallel arrays!)
    array<SRLevel> rawSwingLevels = array.new<SRLevel>()

    // Find pivots (only look back max 100 bars for performance)
    if bar_index >= statSwing * 2
        maxLookback = math.min(100, bar_index - statSwing)
        for i = statSwing to maxLookback
            // Pivot high
            isPH = true
            for j = i - statSwing to i + statSwing
                if j != i and j >= 0
                    if high[j] >= high[i]
                        isPH := false
                        break

            if isPH
                barsAgo = i
                decayFactor = math.pow(statDecay, barsAgo)
                strength = 50.0 * decayFactor * (useRegime ? regimeMult : 1.0)
                // Create SRLevel object directly
                level = SRLevel.new(high[i], "Resistance", strength, "STAT")
                array.push(rawSwingLevels, level)

            // Pivot low
            isPL = true
            for j = i - statSwing to i + statSwing
                if j != i and j >= 0
                    if low[j] <= low[i]
                        isPL := false
                        break

            if isPL
                barsAgo = i
                decayFactor = math.pow(statDecay, barsAgo)
                strength = 50.0 * decayFactor * (useRegime ? regimeMult : 1.0)
                // Create SRLevel object directly
                level = SRLevel.new(low[i], "Support", strength, "STAT")
                array.push(rawSwingLevels, level)

    // Cluster using object-based function (no parallel arrays!)
    statLevels := f_clusterLevels(rawSwingLevels, 0.015)

    // Apply min/max strength constraints
    if array.size(statLevels) > 0
        for i = 0 to array.size(statLevels) - 1
            level = array.get(statLevels, i)
            level.strength := math.max(40, math.min(100, level.strength))

// ============================= ALGORITHM 3: MTF =============================

var array<SRLevel> mtfLevels = array.new<SRLevel>()

if enableMTF and barstate.isconfirmed
    array.clear(mtfLevels)

    if useMTFImport
        // IMPORT MODE: Use levels from standalone sr-algo3-mtf-confluence indicator
        // Imported levels already have proper MTF analysis, touch tracking, etc.

        // Collect all valid (non-na) imported levels with graduated strength
        // Levels 1-3: strength=85 (likely 3-TF, highest quality)
        // Levels 4-7: strength=70 (likely 2-TF, medium quality)
        // Levels 8-10: strength=60 (likely 1-TF, higher relevance)

        // Process each level with position-based strength
        if not na(mtfLevel1Source)
            levelType = mtfLevel1Source > close ? "Resistance" : "Support"
            strength = 85.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel1Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel2Source)
            levelType = mtfLevel2Source > close ? "Resistance" : "Support"
            strength = 85.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel2Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel3Source)
            levelType = mtfLevel3Source > close ? "Resistance" : "Support"
            strength = 85.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel3Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel4Source)
            levelType = mtfLevel4Source > close ? "Resistance" : "Support"
            strength = 70.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel4Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel5Source)
            levelType = mtfLevel5Source > close ? "Resistance" : "Support"
            strength = 70.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel5Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel6Source)
            levelType = mtfLevel6Source > close ? "Resistance" : "Support"
            strength = 70.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel6Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel7Source)
            levelType = mtfLevel7Source > close ? "Resistance" : "Support"
            strength = 70.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel7Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel8Source)
            levelType = mtfLevel8Source > close ? "Resistance" : "Support"
            strength = 60.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel8Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel9Source)
            levelType = mtfLevel9Source > close ? "Resistance" : "Support"
            strength = 60.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel9Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)

        if not na(mtfLevel10Source)
            levelType = mtfLevel10Source > close ? "Resistance" : "Support"
            strength = 60.0 * (useRegime ? regimeMult : 1.0)
            level = SRLevel.new(mtfLevel10Source, levelType, strength, "MTF")
            array.push(mtfLevels, level)
    else
        // FALLBACK MODE: Simple pivot detection (for standalone use)
        array<SRLevel> rawMtfLevels = array.new<SRLevel>()

        // Current TF pivots (only look back max 50 bars for performance)
        if bar_index >= mtfSwing * 2
            maxLookback = math.min(50, bar_index - mtfSwing)
            for i = mtfSwing to maxLookback
                // Pivot high
                isPH = true
                for j = i - mtfSwing to i + mtfSwing
                    if j != i and j >= 0
                        if high[j] >= high[i]
                            isPH := false
                            break

                if isPH
                    strength = 50.0 * (useRegime ? regimeMult : 1.0)
                    level = SRLevel.new(high[i], "Resistance", strength, "MTF")
                    array.push(rawMtfLevels, level)

                // Pivot low
                isPL = true
                for j = i - mtfSwing to i + mtfSwing
                    if j != i and j >= 0
                        if low[j] <= low[i]
                            isPL := false
                            break

                if isPL
                    strength = 50.0 * (useRegime ? regimeMult : 1.0)
                    level = SRLevel.new(low[i], "Support", strength, "MTF")
                    array.push(rawMtfLevels, level)

        // Cluster using object-based function
        mtfLevels := f_clusterLevels(rawMtfLevels, 0.015)

        // Apply min/max strength constraints
        if array.size(mtfLevels) > 0
            for i = 0 to array.size(mtfLevels) - 1
                level = array.get(mtfLevels, i)
                level.strength := math.max(40, math.min(100, level.strength))

// ============================= ALGORITHM 4: ORDER BOOK ======================

var array<SRLevel> obLevels = array.new<SRLevel>()

// Extract ta function outside conditional for consistency
avgVol = ta.sma(volume, 20)

if enableOB and barstate.isconfirmed
    array.clear(obLevels)

    // Build array of SRLevel objects directly
    array<SRLevel> rawRejectionLevels = array.new<SRLevel>()

    for i = 0 to math.min(obLookback, bar_index)
        barHigh = high[i]
        barLow = low[i]
        barOpen = open[i]
        barClose = close[i]
        barVol = volume[i]

        bodyTop = math.max(barOpen, barClose)
        bodyBottom = math.min(barOpen, barClose)
        bodySize = bodyTop - bodyBottom

        upperWick = barHigh - bodyTop
        lowerWick = bodyBottom - barLow

        if bodySize > 0 and barVol > avgVol * 0.8
            // Upper wick rejection
            if upperWick / bodySize > obMinWick
                strength = 40.0 + (upperWick / bodySize) * 20
                level = SRLevel.new(barHigh, "Resistance", strength, "OB")
                array.push(rawRejectionLevels, level)

            // Lower wick rejection
            if lowerWick / bodySize > obMinWick
                strength = 40.0 + (lowerWick / bodySize) * 20
                level = SRLevel.new(barLow, "Support", strength, "OB")
                array.push(rawRejectionLevels, level)

    // Cluster using object-based function
    epsilon = currentATR > 0 ? math.min(0.03, (currentATR / close) * 1.5) : 0.015
    obLevels := f_clusterLevels(rawRejectionLevels, epsilon)

    // Apply min/max strength constraints
    if array.size(obLevels) > 0
        for i = 0 to array.size(obLevels) - 1
            level = array.get(obLevels, i)
            level.strength := math.max(40, math.min(100, level.strength))

// ============================= ENSEMBLE MERGING =============================

var array<EnsembleLevel> ensembleLevels = array.new<EnsembleLevel>()

if barstate.isconfirmed
    array.clear(ensembleLevels)

    // Collect all levels
    array<SRLevel> allLevels = array.new<SRLevel>()

    // Safe collection with size checks
    if enableVP
        vpSize = array.size(vpLevels)
        if vpSize > 0
            for i = 0 to vpSize - 1
                array.push(allLevels, array.get(vpLevels, i))

    if enableStat
        statSize = array.size(statLevels)
        if statSize > 0
            for i = 0 to statSize - 1
                array.push(allLevels, array.get(statLevels, i))

    if enableMTF
        mtfSize = array.size(mtfLevels)
        if mtfSize > 0
            for i = 0 to mtfSize - 1
                array.push(allLevels, array.get(mtfLevels, i))

    if enableOB
        obSize = array.size(obLevels)
        if obSize > 0
            for i = 0 to obSize - 1
                array.push(allLevels, array.get(obLevels, i))

    // Merge nearby levels
    totalLevels = array.size(allLevels)

    if totalLevels > 0
        // Fresh merge tracking for THIS bar (no 'var' = no state persistence bug)
        array<bool> merged = array.new_bool()
        for i = 0 to totalLevels - 1
            array.push(merged, false)

        for i = 0 to totalLevels - 1
            if i < array.size(merged) and i < array.size(allLevels)
                if not array.get(merged, i)
                    currentLevel = array.get(allLevels, i)

                    // Start ensemble cluster
                    clusterPrice = currentLevel.price
                    clusterType = currentLevel.levelType
                    clusterCount = 1

                    vpScore = currentLevel.source == "VP" ? currentLevel.strength : 0.0
                    statScore = currentLevel.source == "STAT" ? currentLevel.strength : 0.0
                    mtfScore = currentLevel.source == "MTF" ? currentLevel.strength : 0.0
                    obScore = currentLevel.source == "OB" ? currentLevel.strength : 0.0

                    sources = currentLevel.source

                    array.set(merged, i, true)

                    // Find nearby levels
                    for j = i + 1 to totalLevels - 1
                        // Defensive bounds check (prevents PineScript loop edge case)
                        if j >= 0 and j < totalLevels
                            if not array.get(merged, j)
                                otherLevel = array.get(allLevels, j)
                                distance = level_lib.calculateDistance(currentLevel.price, otherLevel.price)

                                if distance <= mergeTolerance and currentLevel.levelType == otherLevel.levelType
                                    // Merge
                                    clusterPrice := (clusterPrice * clusterCount + otherLevel.price) / (clusterCount + 1)
                                    clusterCount += 1

                                    if otherLevel.source == "VP" and vpScore == 0.0
                                        vpScore := otherLevel.strength
                                        sources := sources + "+VP"
                                    else if otherLevel.source == "STAT" and statScore == 0.0
                                        statScore := otherLevel.strength
                                        sources := sources + "+STAT"
                                    else if otherLevel.source == "MTF" and mtfScore == 0.0
                                        mtfScore := otherLevel.strength
                                        sources := sources + "+MTF"
                                    else if otherLevel.source == "OB" and obScore == 0.0
                                        obScore := otherLevel.strength
                                        sources := sources + "+OB"

                                    array.set(merged, j, true)

                    // Calculate ensemble score
                    agreement = (vpScore > 0 ? 1 : 0) + (statScore > 0 ? 1 : 0) + (mtfScore > 0 ? 1 : 0) + (obScore > 0 ? 1 : 0)

                    // Algorithm weights based on user toggle
                    // Equal weights (RECOMMENDED for ALPHA - DeMiguel et al. 2009)
                    // Original weights (UNVALIDATED - requires empirical testing)
                    vpWeight = useEqualWeights ? 0.25 : 0.35
                    statWeight = useEqualWeights ? 0.25 : 0.20
                    mtfWeight = useEqualWeights ? 0.25 : 0.30
                    obWeight = useEqualWeights ? 0.25 : 0.15

                    totalWeight = (vpScore > 0 ? vpWeight : 0.0) + (statScore > 0 ? statWeight : 0.0) +
                                 (mtfScore > 0 ? mtfWeight : 0.0) + (obScore > 0 ? obWeight : 0.0)

                    // Normalize weights based on participating algorithms
                    baseScore = totalWeight > 0 ?
                               ((vpScore * vpWeight) + (statScore * statWeight) + (mtfScore * mtfWeight) + (obScore * obWeight)) / totalWeight :
                               0.0

                    // Agreement bonus (less aggressive)
                    agreementBonus = agreement == 4 ? 1.15 : agreement == 3 ? 1.10 : agreement == 2 ? 1.05 : 1.0

                    ensembleStrength = math.min(100, baseScore * agreementBonus)

                    confidence = agreement == 4 ? "VERY HIGH" : agreement == 3 ? "HIGH" : agreement == 2 ? "MODERATE" : "LOW"

                    levelColor = clusterType == "Support" ?
                         (ensembleStrength >= 80 ? color.new(color.green, 0) : color.new(color.green, 30)) :
                         (ensembleStrength >= 80 ? color.new(color.red, 0) : color.new(color.red, 30))

                    // Filter and add
                    if agreement >= minAgreement and ensembleStrength >= minStrength
                        ensembleLevel = EnsembleLevel.new(clusterPrice, clusterType, ensembleStrength, agreement, sources, confidence, levelColor)
                        array.push(ensembleLevels, ensembleLevel)

    // Sort by strength
    ensembleSize = array.size(ensembleLevels)
    if ensembleSize > 1
        for i = 0 to ensembleSize - 2
            for j = i + 1 to ensembleSize - 1
                // Defensive bounds check
                if i >= 0 and i < ensembleSize and j >= 0 and j < ensembleSize
                    if array.get(ensembleLevels, j).ensembleStrength > array.get(ensembleLevels, i).ensembleStrength
                        temp = array.get(ensembleLevels, i)
                        array.set(ensembleLevels, i, array.get(ensembleLevels, j))
                        array.set(ensembleLevels, j, temp)

// ============================= VISUALIZATION ================================

// Track visualization objects for cleanup
var array<line> drawnLines = array.new<line>()
var array<label> drawnLabels = array.new<label>()

// Draw levels (only on confirmed bars to avoid redrawing every tick)
if barstate.isconfirmed and array.size(ensembleLevels) > 0
    // Delete old lines and labels
    if array.size(drawnLines) > 0
        for i = 0 to array.size(drawnLines) - 1
            line.delete(array.get(drawnLines, i))
        array.clear(drawnLines)

    if array.size(drawnLabels) > 0
        for i = 0 to array.size(drawnLabels) - 1
            label.delete(array.get(drawnLabels, i))
        array.clear(drawnLabels)

    // Draw new levels
    levelsToShow = math.min(maxLevels, array.size(ensembleLevels))

    for i = 0 to levelsToShow - 1
        level = array.get(ensembleLevels, i)

        lineWidth = level.agreementCount == 4 ? 3 : level.agreementCount == 3 ? 2 : 1

        newLine = line.new(bar_index - 50, level.price, bar_index + 50, level.price,
             color=level.levelColor, width=lineWidth, extend=extend.right)
        array.push(drawnLines, newLine)

        if showLabels
            labelText = str.tostring(math.round(level.ensembleStrength))
            if showSources
                labelText += " (" + level.sources + ")"

            labelStyle = level.levelType == "Support" ? label.style_label_up : label.style_label_down

            newLabel = label.new(bar_index + 10, level.price, labelText,
                 style=labelStyle, color=level.levelColor, textcolor=color.white,
                 size=level.agreementCount >= 3 ? size.normal : size.small)
            array.push(drawnLabels, newLabel)

// Info table (update when data changes or on last bar)
if showTable
    var table info = table.new(position.top_right, 2, 7, border_width=1)

    if barstate.islast or barstate.isconfirmed
        table.cell(info, 0, 0, "S/R Ensemble", text_color=color.white,
             bgcolor=color.new(color.blue, 30), text_size=size.normal)
        table.merge_cells(info, 0, 0, 1, 0)

        // Debug: Show algorithm level counts
        table.cell(info, 0, 1, "Algo Counts:", text_color=color.white,
             bgcolor=color.new(color.gray, 60), text_size=size.tiny)
        debugText = "VP:" + str.tostring(array.size(vpLevels)) + " ST:" + str.tostring(array.size(statLevels)) +
                   " MTF:" + str.tostring(array.size(mtfLevels)) + " OB:" + str.tostring(array.size(obLevels)) +
                   " Bar:" + str.tostring(bar_index)
        table.cell(info, 1, 1, debugText,
             text_color=color.yellow, bgcolor=color.new(color.gray, 60), text_size=size.tiny)

        table.cell(info, 0, 2, "Total Levels:", text_color=color.white,
             bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(info, 1, 2, str.tostring(array.size(ensembleLevels)),
             text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

        table.cell(info, 0, 3, "Showing:", text_color=color.white,
             bgcolor=color.new(color.gray, 70), text_size=size.small)
        table.cell(info, 1, 3, str.tostring(math.min(maxLevels, array.size(ensembleLevels))),
             text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)

        if array.size(ensembleLevels) > 0
            topLevel = array.get(ensembleLevels, 0)

            table.cell(info, 0, 4, "Strongest:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 4, str.tostring(topLevel.price, format.mintick),
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)

            table.cell(info, 0, 5, "Strength:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 5, str.tostring(math.round(topLevel.ensembleStrength)),
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)

            table.cell(info, 0, 6, "Agreement:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 6, str.tostring(topLevel.agreementCount) + "/4",
                 text_color=topLevel.levelColor, bgcolor=color.new(color.gray, 80), text_size=size.small)
        else
            table.cell(info, 0, 4, "Status:", text_color=color.white,
                 bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.cell(info, 1, 4, "No levels found",
                 text_color=color.orange, bgcolor=color.new(color.gray, 80), text_size=size.small)
            table.merge_cells(info, 0, 4, 1, 4)

// ============================= LEVEL EXPORTS FOR HMA/OTHER INDICATORS =======
// Export top 10 ensemble levels for import into mkn-hma-alt.pine via input.source()
// Sorted by ensemble strength (already sorted in ensembleLevels array)

var float topSRLevel1 = na
var float topSRLevel2 = na
var float topSRLevel3 = na
var float topSRLevel4 = na
var float topSRLevel5 = na
var float topSRLevel6 = na
var float topSRLevel7 = na
var float topSRLevel8 = na
var float topSRLevel9 = na
var float topSRLevel10 = na

if barstate.isconfirmed and array.size(ensembleLevels) > 0
    // Export levels (already sorted by strength)
    topSRLevel1 := array.size(ensembleLevels) > 0 ? array.get(ensembleLevels, 0).price : na
    topSRLevel2 := array.size(ensembleLevels) > 1 ? array.get(ensembleLevels, 1).price : na
    topSRLevel3 := array.size(ensembleLevels) > 2 ? array.get(ensembleLevels, 2).price : na
    topSRLevel4 := array.size(ensembleLevels) > 3 ? array.get(ensembleLevels, 3).price : na
    topSRLevel5 := array.size(ensembleLevels) > 4 ? array.get(ensembleLevels, 4).price : na
    topSRLevel6 := array.size(ensembleLevels) > 5 ? array.get(ensembleLevels, 5).price : na
    topSRLevel7 := array.size(ensembleLevels) > 6 ? array.get(ensembleLevels, 6).price : na
    topSRLevel8 := array.size(ensembleLevels) > 7 ? array.get(ensembleLevels, 7).price : na
    topSRLevel9 := array.size(ensembleLevels) > 8 ? array.get(ensembleLevels, 8).price : na
    topSRLevel10 := array.size(ensembleLevels) > 9 ? array.get(ensembleLevels, 9).price : na

// Plot levels (invisible, for import only)
plot(topSRLevel1, "Top S/R Level 1", display=display.none)
plot(topSRLevel2, "Top S/R Level 2", display=display.none)
plot(topSRLevel3, "Top S/R Level 3", display=display.none)
plot(topSRLevel4, "Top S/R Level 4", display=display.none)
plot(topSRLevel5, "Top S/R Level 5", display=display.none)
plot(topSRLevel6, "Top S/R Level 6", display=display.none)
plot(topSRLevel7, "Top S/R Level 7", display=display.none)
plot(topSRLevel8, "Top S/R Level 8", display=display.none)
plot(topSRLevel9, "Top S/R Level 9", display=display.none)
plot(topSRLevel10, "Top S/R Level 10", display=display.none)

// ============================= ALERTS =======================================

highConfNearby = false
ensembleSize = array.size(ensembleLevels)
if ensembleSize > 0
    maxCheck = math.min(3, ensembleSize - 1)
    if maxCheck >= 0
        for i = 0 to maxCheck
            level = array.get(ensembleLevels, i)
            if level.agreementCount >= 3
                distance = level_lib.calculateDistance(level.price, close)
                if distance < 0.01
                    highConfNearby := true
                    break

if highConfNearby and not highConfNearby[1]
    alert("Price near high-confidence S/R on " + syminfo.ticker, alert.freq_once_per_bar_close)

perfectAgree = false
if array.size(ensembleLevels) > 0
    topLevel = array.get(ensembleLevels, 0)
    if topLevel.agreementCount == 4
        distance = level_lib.calculateDistance(topLevel.price, close)
        if distance < 0.015
            perfectAgree := true

if perfectAgree and not perfectAgree[1]
    topLevel = array.get(ensembleLevels, 0)
    alert("PERFECT AGREEMENT: " + topLevel.levelType + " at " + str.tostring(topLevel.price, format.mintick) +
          " on " + syminfo.ticker, alert.freq_once_per_bar_close)