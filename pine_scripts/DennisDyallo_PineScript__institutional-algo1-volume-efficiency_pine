//@version=5
indicator(title='MKN: Institutional Algo 1: Volume Efficiency Detector', shorttitle = 'IA1-VED', overlay = false, format = format.price, precision = 0, max_labels_count = 500)

// ============================================================================
// LABEL DOCUMENTATION
// ============================================================================
//
// WHAT THE LABELS MEAN:
//
// Format: "[Score]\n[Pattern]"
//   Example: "85\nACCUM" or "72\nDIST"
//
// Score (0-100): Institutional activity strength
//   - Base components:
//     ‚Ä¢ Volume Score (0-30): Relative volume vs 20-bar average
//     ‚Ä¢ Efficiency Score (0-30): Volume-to-price-range ratio
//     ‚Ä¢ Wick Score (0-20): Rejection wicks indicating absorption
//     ‚Ä¢ Control Score (0-12): Pattern-specific price action
//   - Trend filter adjustments:
//     ‚Ä¢ Weak filter: √ó0.85 penalty if counter-trend
//     ‚Ä¢ Medium filter: √ó0.50 penalty if counter-trend
//     ‚Ä¢ Strong filter: Rejects counter-trend signals entirely
//   - Threshold: ‚â•70 = institutional (default)
//
// Pattern Types:
//   - ACCUM (Accumulation) = Institutional buying
//     ‚Ä¢ Pattern 1: Mid-close + high volume after decline (classic absorption)
//     ‚Ä¢ Pattern 2: Upper close + extreme volume after decline (aggressive)
//     ‚Ä¢ Must be trend-aligned (uptrend or ranging market)
//
//   - DIST (Distribution) = Institutional selling
//     ‚Ä¢ Pattern 3: Upper close + extreme volume at local high (into strength)
//     ‚Ä¢ Pattern 4: Lower close + extreme volume at local high (stealth)
//     ‚Ä¢ Must be trend-aligned (downtrend or at resistance)
//
//   - MIXED = Ambiguous or counter-trend signal
//     ‚Ä¢ Detected pattern but not trend-aligned
//     ‚Ä¢ Lower confidence, use with caution
//
// Visual Cues:
//   - Histogram Color: Green (‚â•70), Yellow (50-69), Orange (30-49), Red (<30)
//   - Label Color: Green (ACCUM), Red (DIST), Orange (MIXED)
//   - Background Tint: Light green (ACCUM) or light red (DIST) when ‚â•threshold
//   - Threshold Line: White dashed line at your configured level
//
// Trend Alignment (Critical):
//   - Uses 50 EMA + ADX for trend detection
//   - Only flags signals that align with market direction
//   - Counter-trend signals are penalized or rejected
//   - Ensures institutional activity matches market structure
//
// ============================================================================

// ============================================================================
// LIBRARY IMPORTS
// ============================================================================
import redshad0ww/CoreMath/3 as math_lib
import redshad0ww/VolumeAnalysis/4 as vol_lib
import redshad0ww/TrendDetection/2 as trend_lib

// ============================================================================
// INPUTS
// ============================================================================
i_volumeLookback = input.int(20, 'Volume Lookback Period', minval = 10, maxval = 100, group = 'Core Settings', tooltip = 'Period for calculating average volume and efficiency metrics')

i_volumeThreshold = input.float(1.5, 'Volume Threshold (x Avg)', minval = 1.0, maxval = 5.0, step = 0.1, group = 'Core Settings', tooltip = 'Minimum volume multiplier vs average to trigger detection')

i_efficiencyThreshold = input.float(1.3, 'Efficiency Threshold', minval = 1.0, maxval = 3.0, step = 0.1, group = 'Core Settings', tooltip = 'Volume-to-range ratio multiplier for high efficiency detection')

i_scoreThreshold = input.int(70, 'Score Threshold', minval = 50, maxval = 90, group = 'Core Settings', tooltip = 'Minimum score (0-100) to flag as institutional candle')

// Trend Filter Settings
i_useTrendFilter = input.bool(true, 'Enable Trend Filter', group = 'Trend Filter', tooltip = 'Only flag signals aligned with trend direction')

i_trendFilterStrength = input.string('Medium', 'Filter Strength', options = ['Weak', 'Medium', 'Strong'], group = 'Trend Filter', tooltip = 'Weak=Small penalty, Medium=50% penalty, Strong=Reject counter-trend')

i_minADX = input.int(20, 'Minimum ADX', minval = 10, maxval = 50, group = 'Trend Filter', tooltip = 'Minimum ADX to consider market trending (lower = less strict)')

// Visual Settings
i_showTable = input.bool(true, 'Show Metrics Table', group = 'Display')
i_showLabels = input.bool(true, 'Show Score Labels', group = 'Display')
i_showBackground = input.bool(true, 'Highlight High Scores', group = 'Display')
i_debugMode = input.bool(false, 'Debug Mode', group = 'Advanced', tooltip = 'Show all intermediate calculations')

// ============================================================================
// VOLUME METRICS (using VolumeAnalysis library)
// ============================================================================
volMetrics = vol_lib.calculateVolumeMetrics(i_volumeLookback)
relativeVolume = volMetrics.relativeVolume
volumeEfficiency = volMetrics.volumeEfficiency
efficiencyRatio = volMetrics.efficiencyRatio
volumeScore = volMetrics.volumeScore

// Calculate efficiency score based on threshold
efficiencyScore = efficiencyRatio >= i_efficiencyThreshold and efficiencyRatio <= 4.0 ? math.min(30, (efficiencyRatio - 1.0) * 15.0) : 0.0

// ============================================================================
// PRICE METRICS (for wick analysis and close position)
// ============================================================================
priceRange = high - low

// ============================================================================
// WICK ANALYSIS
// ============================================================================
bodySize = math.abs(close - open)
upperWick = high - math.max(open, close)
lowerWick = math.min(open, close) - low
totalWickSize = upperWick + lowerWick
wickRatio = math_lib.safeDivide(totalWickSize, priceRange, 0.0)

wickScore = wickRatio > 0.3 ? math.min(20, wickRatio * 40.0) : 0.0

// ============================================================================
// CLOSE POSITION ANALYSIS WITH PRICE CONTEXT
// ============================================================================
closePosition = math_lib.safeDivide(close - low, priceRange, 0.5)

// Determine if at local high/low (last 10 bars)
highest10 = ta.highest(high, 10)
lowest10 = ta.lowest(low, 10)
atLocalHigh = high >= highest10[1] // Current high is highest in last 10
atLocalLow = low <= lowest10[1] // Current low is lowest in last 10

// Price momentum (3-bar change)
priceChange3 = (close - close[3]) / close[3] * 100
isRising = priceChange3 > 1.0
isFalling = priceChange3 < -1.0

controlScore = 0.0
accumulationPattern = false
distributionPattern = false

// ACCUMULATION PATTERNS:
// 1. Mid-close with volume after decline (classic absorption)
if closePosition >= 0.35 and closePosition <= 0.65 and relativeVolume > 1.3 and (isFalling or atLocalLow)
    controlScore := 12.0
    accumulationPattern := true
    accumulationPattern

// 2. Upper close with volume after decline (buying pressure overwhelming sellers)
else if closePosition > 0.65 and relativeVolume > 1.8 and (isFalling or atLocalLow)
    controlScore := 10.0
    accumulationPattern := true
    accumulationPattern

// DISTRIBUTION PATTERNS:
// 3. Upper close with volume at local high (selling into strength)
else if closePosition > 0.70 and relativeVolume > 1.8 and (isRising or atLocalHigh)
    controlScore := 8.0
    distributionPattern := true
    distributionPattern

// 4. Mid-close with volume at local high (resistance/rejection)
else if closePosition >= 0.40 and closePosition <= 0.60 and relativeVolume > 1.8 and atLocalHigh
    controlScore := 7.0
    distributionPattern := true
    distributionPattern

// 5. Lower close with volume (panic selling/capitulation - can be accumulation opportunity)
else if closePosition < 0.30 and relativeVolume > 2.0 and isFalling
    controlScore := 6.0
    distributionPattern := true // Marking as distribution but could be climax
    distributionPattern

// ============================================================================
// TREND CONTEXT FILTER (using TrendDetection library)
// ============================================================================
// Get EMA-based trend direction
[isUptrend, isDowntrend, isRanging] = trend_lib.detectEMATrend(20, 50, 200)

// Get ADX-based trend strength
trendData = trend_lib.detectADXTrend(14, i_minADX, 35.0)
adx = trendData.adxValue
isTrending = trendData.isTrending
isStrongTrend = trendData.isStrongTrend

// Preserve ema50 for later use in trend logic
ema50 = ta.ema(close, 50)

// ============================================================================
// FINAL SCORE WITH TREND FILTERING
// ============================================================================

rawScore = volumeScore + efficiencyScore + wickScore + controlScore
baseScore = math.min(100, math.max(0, rawScore))

// Apply trend filter
institutionalScore = baseScore
trendAligned = false

if i_useTrendFilter
    // Determine penalty/boost based on filter strength
    penaltyMultiplier = i_trendFilterStrength == 'Strong' ? 0.0 : i_trendFilterStrength == 'Medium' ? 0.5 : 0.7
    boostMultiplier = 1.1

    // ACCUMULATION signals
    if accumulationPattern
        if isUptrend or isRanging and not isDowntrend
            // Aligned: accumulation in uptrend or ranging market
            institutionalScore := baseScore * boostMultiplier
            trendAligned := true
            trendAligned
        else if isDowntrend and isTrending
            // Counter-trend: accumulation in strong downtrend
            institutionalScore := baseScore * penaltyMultiplier
            trendAligned := false
            trendAligned
        else // Weak trend, allow signal
            trendAligned := true
            trendAligned

    // DISTRIBUTION signals
    else if distributionPattern
        if isDowntrend or isRanging and close > ema50
            // Aligned: distribution in downtrend or at resistance
            institutionalScore := baseScore * boostMultiplier
            trendAligned := true
            trendAligned
        else if isUptrend and isTrending
            // Counter-trend: distribution in strong uptrend
            institutionalScore := baseScore * penaltyMultiplier
            trendAligned := false
            trendAligned
        else // Weak trend, allow signal
            trendAligned := true
            trendAligned
    else // MIXED pattern - no strong directional bias
        trendAligned := true
        trendAligned
else // No filter enabled
    trendAligned := true
    trendAligned

// Cap final score
institutionalScore := math.min(100, institutionalScore)

// Binary classification
isInstitutional = institutionalScore >= i_scoreThreshold and trendAligned

// Pattern classification
patternType = accumulationPattern and trendAligned ? 'ACCUM' : distributionPattern and trendAligned ? 'DIST' : 'MIXED'

// ============================================================================
// BACKTESTING REMOVED
// ============================================================================
// NOTE: The original backtesting code has been removed because it was
// fundamentally broken. In PineScript, close[n] looks BACKWARD n bars,
// not FORWARD. Indicators cannot access future data, so true backtesting
// of forward returns is impossible in this context.
//
// For proper backtesting, you would need to:
// 1. Convert this to a strategy (not an indicator)
// 2. Use strategy.entry/strategy.exit with proper order logic
// 3. Or export signals and backtest in external software
// ============================================================================

// ============================================================================
// VISUALIZATION
// ============================================================================

hline(i_scoreThreshold, 'Threshold', color = color.white, linestyle = hline.style_dashed, linewidth = 1)
hline(0, 'Zero', color = color.gray, linestyle = hline.style_solid, linewidth = 1)

scoreColor = institutionalScore >= 70 ? color.new(color.green, 0) : institutionalScore >= 50 ? color.new(color.yellow, 0) : institutionalScore >= 30 ? color.new(color.orange, 0) : color.new(color.red, 0)

plot(institutionalScore, 'Institutional Score', color = scoreColor, style = plot.style_histogram, linewidth = 3)

// Debug plots
plot(i_debugMode ? volumeScore : na, 'Volume Score', color = color.new(color.blue, 50), style = plot.style_line, linewidth = 1)
plot(i_debugMode ? efficiencyScore : na, 'Efficiency Score', color = color.new(color.purple, 50), style = plot.style_line, linewidth = 1)
plot(i_debugMode ? wickScore : na, 'Wick Score', color = color.new(color.aqua, 50), style = plot.style_line, linewidth = 1)

// ADX plot for trend strength
plot(i_debugMode ? adx : na, 'ADX', color = color.new(color.white, 30), style = plot.style_line, linewidth = 1)

// ============================================================================
// CHART MARKERS
// ============================================================================

if i_showLabels and isInstitutional
    labelColor = accumulationPattern ? color.new(color.green, 20) : distributionPattern ? color.new(color.red, 20) : color.new(color.orange, 20)

    labelText = str.tostring(math.round(institutionalScore)) + '\n' + patternType

    label.new(bar_index, institutionalScore, text = labelText, style = label.style_label_up, color = labelColor, textcolor = color.white, size = size.small)

bgcolor(i_showBackground and isInstitutional ? accumulationPattern ? color.new(color.green, 92) : color.new(color.red, 92) : na, title = 'Signal Background')

// ============================================================================
// METRICS TABLE
// ============================================================================

if i_showTable
    maxRows = i_debugMode ? 13 : 12
    var table metricsTable = table.new(position.top_right, 2, maxRows, border_width = 2, border_color = color.new(color.gray, 50), frame_width = 1, frame_color = color.new(color.gray, 50))

    // Header
    table.cell(metricsTable, 0, 0, 'Institutional Detection', bgcolor = color.new(color.blue, 70), text_color = color.white, text_size = size.normal)
    table.merge_cells(metricsTable, 0, 0, 1, 0)

    // Current metrics
    table.cell(metricsTable, 0, 1, 'Current Score:', text_halign = text.align_left, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 1, str.tostring(math.round(institutionalScore)), text_color = scoreColor, text_size = size.normal)

    table.cell(metricsTable, 0, 2, 'Pattern Type:', text_halign = text.align_left, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 2, patternType, text_color = accumulationPattern ? color.lime : distributionPattern ? color.red : color.orange)

    table.cell(metricsTable, 0, 3, 'Status:', text_halign = text.align_left, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 3, isInstitutional ? '‚úì ACTIVE' : '‚óã Inactive', text_color = isInstitutional ? color.lime : color.new(color.white, 50))

    // Trend information
    table.cell(metricsTable, 0, 4, 'Trend:', text_halign = text.align_left, text_color = color.new(color.white, 20))
    trendText = isUptrend ? '‚Üë UP' : isDowntrend ? '‚Üì DOWN' : '‚Üî RANGE'
    trendColor = isUptrend ? color.lime : isDowntrend ? color.red : color.orange
    table.cell(metricsTable, 1, 4, trendText, text_color = trendColor)

    table.cell(metricsTable, 0, 5, 'ADX:', text_halign = text.align_left, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 5, str.tostring(math.round(adx, 1)), text_color = isTrending ? color.lime : color.new(color.white, 50))

    table.cell(metricsTable, 0, 6, 'Aligned:', text_halign = text.align_left, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 6, trendAligned ? '‚úì YES' : '‚úó NO', text_color = trendAligned ? color.lime : color.red)

    // Component scores header
    table.cell(metricsTable, 0, 7, 'Components:', bgcolor = color.new(color.gray, 70), text_color = color.white, text_size = size.small)
    table.merge_cells(metricsTable, 0, 7, 1, 7)

    table.cell(metricsTable, 0, 8, 'Volume:', text_halign = text.align_left, text_size = size.small, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 8, str.tostring(math.round(relativeVolume, 2)) + 'x (' + str.tostring(math.round(volumeScore)) + ')', text_color = relativeVolume > i_volumeThreshold ? color.lime : color.new(color.white, 50), text_size = size.small)

    table.cell(metricsTable, 0, 9, 'Efficiency:', text_halign = text.align_left, text_size = size.small, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 9, str.tostring(math.round(efficiencyRatio, 2)) + 'x (' + str.tostring(math.round(efficiencyScore)) + ')', text_color = efficiencyScore > 0 ? color.lime : color.new(color.white, 50), text_size = size.small)

    table.cell(metricsTable, 0, 10, 'Wick Ratio:', text_halign = text.align_left, text_size = size.small, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 10, str.tostring(math.round(wickRatio * 100)) + '% (' + str.tostring(math.round(wickScore)) + ')', text_color = wickScore > 0 ? color.lime : color.new(color.white, 50), text_size = size.small)

    table.cell(metricsTable, 0, 11, 'Close Pos:', text_halign = text.align_left, text_size = size.small, text_color = color.new(color.white, 20))
    table.cell(metricsTable, 1, 11, str.tostring(math.round(closePosition * 100)) + '% (' + str.tostring(math.round(controlScore)) + ')', text_color = controlScore > 0 ? color.lime : color.new(color.white, 50), text_size = size.small)

    // Add price context indicators
    if i_debugMode
        table.cell(metricsTable, 0, 12, 'Context:', text_halign = text.align_left, text_size = size.small, text_color = color.new(color.white, 20))
        contextText = (atLocalHigh ? 'üìàTop ' : '') + (atLocalLow ? 'üìâBot ' : '') + (isRising ? '‚¨ÜÔ∏èUp ' : '') + (isFalling ? '‚¨áÔ∏èDn' : '')
        table.cell(metricsTable, 1, 12, contextText, text_size = size.small, text_color = color.new(color.white, 10))

// ============================================================================
// ALERTS
// ============================================================================

// Alert 1: Trend-aligned institutional signal
if ta.crossover(institutionalScore, i_scoreThreshold) and trendAligned
    alert('Institutional activity detected with trend alignment on ' + syminfo.ticker + ' (Score: ' + str.tostring(math.round(institutionalScore)) + ', Type: ' + patternType + ')', alert.freq_once_per_bar_close)

// Alert 2: Accumulation in uptrend
if isInstitutional and accumulationPattern and isUptrend and not (isInstitutional[1] and accumulationPattern[1] and isUptrend[1])
    alert('Strong accumulation signal in established uptrend on ' + syminfo.ticker + ' (Score: ' + str.tostring(math.round(institutionalScore)) + ')', alert.freq_once_per_bar_close)

// Alert 3: Distribution in downtrend
if isInstitutional and distributionPattern and isDowntrend and not (isInstitutional[1] and distributionPattern[1] and isDowntrend[1])
    alert('Strong distribution signal in established downtrend on ' + syminfo.ticker + ' (Score: ' + str.tostring(math.round(institutionalScore)) + ')', alert.freq_once_per_bar_close)
