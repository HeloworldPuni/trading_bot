// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ACCESS ALGO ‚Äì AlgoPoint | Reversal Master
// ¬© Hc_Sunt_Lucrum | access-algo.com
// This script is subject to the terms of the Mozilla Public License 2.0
// https://mozilla.org/MPL/2.0/
//
// Description:AlgoPoint | Reversal Master script, useful indicator to do some investigation on for possible strategies. 
// 
//
// Usage:
// Designed for TradingView. Compatible with Pine Script v5.
// Free to use under invite-only rules or for educational purposes.
//
// Version:         v1
// Last Updated:    2025-05-02
// Author:          Hc_Sunt_Lucrum
// Contact:         access-algo.com | TradingView: @Hc_Sunt_Lucrum
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ¬© Hc_Sunt_Lucrum


//@version=5
indicator('AlgoPoint | Reversal Master', overlay=true, precision = 0, linktoseries = true, max_bars_back = 1000, max_lines_count = 500, max_labels_count=500)

aisensitivitysetter = input.int(defval=4, minval=1, maxval = 6, step = 1, title="Contrarian Sensitivity | 1-6", group="Contrarƒ±an Sƒ±gnals")
Strengthfilter = input.int(defval=0, minval=0, maxval = 5, step = 1, title="Strength Filter | 1-5", group="Contrarƒ±an Sƒ±gnals") -0.1
stability = aisensitivitysetter == 1 ? 0.4 : aisensitivitysetter == 2 ? 0.5 : aisensitivitysetter == 3 ? 0.6 : aisensitivitysetter == 4 ? 0.7 : aisensitivitysetter == 5 ? 0.8 : aisensitivitysetter == 6 ? 0.9 : 1
rsiindex = 50
candledelta = 5



//
stable_candle = math.abs(close - open) / ta.tr > stability
rsi = ta.rsi(close, 14)

bullish_engulfing = close[1] < open[1] and close > open and close > open[1]
rsi_below_50 = rsi < rsiindex
decrease_over_5 = close < close[candledelta]

bull = bullish_engulfing and stable_candle and rsi_below_50 and decrease_over_5


bearish_engulfing = close[1] > open[1] and close < open and close < open[1]
rsi_above_50 = rsi > rsiindex
increase_over_5 = close > close[candledelta]

bear = bearish_engulfing and stable_candle and rsi_above_50 and increase_over_5


lblsz = 'tiny'
sizy = lblsz == 'tiny' ? size.tiny : lblsz == 'small' ? size.small : lblsz == 'normal' ? size.normal : lblsz == 'large' ? size.large : lblsz == 'huge' ? size.huge : na

labystyly = 'text bubble'
labelystylybear = labystyly == 'text bubble' ? label.style_label_down : labystyly == 'triangle' ? label.style_triangledown :  labystyly == 'arrow' ? label.style_arrowdown : na
labelystylybear1 = labystyly == 'text bubble' ? label.style_label_up : labystyly == 'triangle' ? label.style_triangleup :  labystyly == 'arrow' ? label.style_arrowup : na

buylbl = #00dbff
selllbl = #b2b5be
txtcl = #ffffff

//=============================================================================
// INDICATOR 11 - Trend Confidence
//============================================================================
 
 
// CCI 
 
TM_Long = ta.cci(close, 20) < -140
TM_Short = ta.cci(close, 20) > 140
 
 
 
//color1 = ta.cci(close, 5) >= 0 ? #0022FC : #FC0400
//plot(MagicTrend, color=color1, linewidth=3)
 
 
// ADX
lenadx = 14
lensig = 14
limadx = 18
 
 
ADX_up = ta.change(high)
ADX_down = -ta.change(low)
trur = ta.rma(ta.tr, lenadx)
plus = fixnan(100 * ta.rma(ADX_up > ADX_down and ADX_up > 0 ? ADX_up : 0, lenadx) / trur)
minus = fixnan(100 * ta.rma(ADX_down > ADX_up and ADX_down > 0 ? ADX_down : 0, lenadx) / trur)
sum = plus + minus
adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), lensig)
 
macol = adx > limadx and plus > minus ? buylbl : adx > limadx and plus < minus ? selllbl  : color.black

ADX_Long = adx > limadx and plus > minus
ADX_Short = adx > limadx and plus < minus
 
 
//Acumulation/Distribution
RSI_Dist = ta.rsi(close, 14)
 
ACC_Long = RSI_Dist < 40
ACC_Short = RSI_Dist > 60
 
 
// MFI
 
 
MFI = ta.mfi(close , 14)
MFI_SMA = ta.sma (MFI, 9)
 
MFI_Long = MFI < 40
MFI_Short = MFI > 60
 
// Relative Volatility Index

lengthrvi = 10
srcrvi = close
lenrvi = 14
stddev = ta.stdev(srcrvi, lengthrvi)
upperrvi = ta.ema(ta.change(srcrvi) <= 0 ? 0 : stddev, lenrvi)
lowerrvi = ta.ema(ta.change(srcrvi) > 0 ? 0 : stddev, lenrvi)
rvi = upperrvi / (upperrvi + lowerrvi) * 100

MOML_Long = rvi < 40
MOML_Short = rvi > 60
//
entry_long = true
entry_short = true

Long_Signal_Strength = 0
Short_Signal_Strength = 0 
 
if entry_long
    if TM_Long 
        Long_Signal_Strength += 1
    if ADX_Long
        Long_Signal_Strength += 1
    if ACC_Long
        Long_Signal_Strength += 1
    if MFI_Long
        Long_Signal_Strength += 1
    if MOML_Long
        Long_Signal_Strength += 1
 
if entry_short
    if TM_Short 
        Short_Signal_Strength += 1
    if ADX_Short
        Short_Signal_Strength += 1
    if ACC_Short
        Short_Signal_Strength += 1
    if MFI_Short
        Short_Signal_Strength += 1
    if MOML_Short
        Short_Signal_Strength += 1
//Plot Buy/Sell Signals on chart
 
enter_Long_Text = "Buy " + str.tostring(Long_Signal_Strength)
enter_Short_Text = "Sell " + str.tostring(Short_Signal_Strength)
 
frost = bull and Long_Signal_Strength >= Strengthfilter ? label.new(bar_index , low, enter_Long_Text, color=buylbl, style=labelystylybear1, textcolor=txtcl, size=sizy) : na
frost1 = bear and Short_Signal_Strength >= Strengthfilter ? label.new(bar_index , high, enter_Short_Text, color=selllbl, style=labelystylybear, textcolor=txtcl, size=sizy) : na

// Support Resistance
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Showasdas = input.bool(true, 'Supply & Demand Blocks', group='Supply & Demand', inline='Supply Demand 2')
ShowSD2 = false
ShowSZ2 = Showasdas == true ? true : false
ShowRZ2 = Showasdas == true ? true : false

RSI2Length = input.int(14, minval=1, title='Senstivity', group='Supply & Demand', inline = 'af1')
RSI2OBOSIn = '70 / 30'
NumberOfConfirmationBarsRSI2 = input.int(3, title='Confirmation', group='Supply & Demand', inline = 'af1')

RSI2SDColorIn = color.new(color.purple, 85)
RSI2SupportColorIn = color.new(selllbl, 88)
RSI2ResistanceColorIn = color.new(buylbl, 88)

RSI2 = ta.rsi(close, RSI2Length)

RSI2OB = RSI2OBOSIn == '70 / 30' ? 70 : RSI2OBOSIn == '75 / 25' ? 75 : RSI2OBOSIn == '80 / 20' ? 80 : RSI2OBOSIn == '90 / 10' ? 90 : RSI2OBOSIn == '95 / 5' ? 95 : 100
RSI2OS = RSI2OBOSIn == '70 / 30' ? 30 : RSI2OBOSIn == '75 / 25' ? 25 : RSI2OBOSIn == '80 / 20' ? 20 : RSI2OBOSIn == '90 / 10' ? 10 : RSI2OBOSIn == '95 / 5' ? 5 : 0


RSI2incrementer_up = RSI2 > RSI2OB ? 1 : 0
RSI2incrementer_down = RSI2 < RSI2OS ? 1 : 0
RSI2incrementer_both = RSI2 > RSI2OB or RSI2 < RSI2OS ? 1 : 0


RSI2rsx = 0


if RSI2incrementer_both
    RSI2rsx := nz(RSI2rsx[1], 0) + RSI2incrementer_both
    RSI2rsx
else
    RSI2rsx = 0
    RSI2rsx

RSI2rxH = if RSI2rsx >= NumberOfConfirmationBarsRSI2
    RSI2x = high
    RSI2x
RSI2rxL = if RSI2rsx >= NumberOfConfirmationBarsRSI2
    RSI2y = low
    RSI2y

RSI2rH = fixnan(RSI2rxH)
RSI2rL = fixnan(RSI2rxL)



///////////////////////////////////////////////////////


RSI2rsu = 0


if RSI2incrementer_up
    RSI2rsu := nz(RSI2rsu[1], 0) + RSI2incrementer_up
    RSI2rsu
else
    RSI2rsu = 0
    RSI2rsu


RSI2rssH = if RSI2rsu >= NumberOfConfirmationBarsRSI2
    RSI2x = high
    RSI2x


RSI2rssL = if RSI2rsu >= NumberOfConfirmationBarsRSI2
    RSI2y = low
    RSI2y

RSI2ResistanceZoneHigh = fixnan(RSI2rssH)
RSI2ResistanceZoneLow = fixnan(RSI2rssL)


////////////////////////////////////////////////////////


RSI2rsd = 0


if RSI2incrementer_down
    RSI2rsd := nz(RSI2rsd[1], 0) + RSI2incrementer_down
    RSI2rsd
else
    RSI2rsd = 0
    RSI2rsd

RSI2rsrH = if RSI2rsd >= NumberOfConfirmationBarsRSI2
    RSI2x = high
    RSI2x

RSI2rsrL = if RSI2rsd >= NumberOfConfirmationBarsRSI2
    RSI2y = low
    RSI2y


RSI2SupportZoneHigh = fixnan(RSI2rsrH)
RSI2SupportZoneLow = fixnan(RSI2rsrL)


////////////////////////////////////////////////////////

RSI2_ResZoneColor = RSI2ResistanceZoneHigh != RSI2ResistanceZoneHigh[1] ? na : RSI2ResistanceColorIn
RSI2_SupZoneColor = RSI2SupportZoneLow != RSI2SupportZoneLow[1] ? na : RSI2SupportColorIn

RSI2SDColor = RSI2rH != RSI2rH[1] ? na : RSI2SDColorIn

////////////////////////////////////////////////////////


RSI2RZHigh = plot(ShowRZ2 ? RSI2ResistanceZoneHigh : na, style=plot.style_cross, title='Resistance Zone - 2 - High', transp=100)
RSI2RZLow = plot(ShowRZ2 ? RSI2ResistanceZoneLow : na, style=plot.style_cross, title='Resistance Zone - 2 - Low', transp=100)
fill(RSI2RZHigh, RSI2RZLow, color=RSI2_ResZoneColor, title='Support Zone - 2 - Fill', transp=90)

RSI2SZHigh = plot(ShowSZ2 ? RSI2SupportZoneHigh : na, style=plot.style_cross, title='Support Zone - 2 - High', transp=100)
RSI2SZLow = plot(ShowSZ2 ? RSI2SupportZoneLow : na, style=plot.style_cross, title='Support Zone - 2 - Low', transp=100)
fill(RSI2SZHigh, RSI2SZLow, color=RSI2_SupZoneColor, title='Support Zone - 2 - Fill', transp=90)


PlotRSI2rH = plot(ShowSD2 ? RSI2rH : na, style=plot.style_cross, linewidth=1, title='Supply Demand - 2 - High')
PlotRSI2rL = plot(ShowSD2 ? RSI2rL : na, style=plot.style_cross, linewidth=1, title='Supply Demand - 2 - Low')
fill(PlotRSI2rH, PlotRSI2rL, color=RSI2SDColor, title='Supply Demand - 2 - Fill', transp=90)

// Order Blocks Settings
show_order_blocks=input.bool(true,"Order Blocks", inline = "ob1", group = 'Order Blocks')
ibull_ob_css = input.color(color.new(selllbl, 90), '', inline = 'ob1', group = 'Order Blocks')
ibear_ob_css = input.color(color.new(buylbl, 90), '', inline = 'ob1', group = 'Order Blocks')
mode = input.bool(true, 'Auto-Optimizer  |', group='Order Blocks', inline = 'Autohtd')
HTF_manual = input.timeframe('Chart', title='Timeframe', group='Order Blocks', inline = 'Autohtd')

//auto higher time frame
HTF_auto = timeframe.period == '1' ? '15' : 
           timeframe.period == '2' ? '15' : 
           timeframe.period == '3' ? '30' : 
           timeframe.period == '5' ? '30' : 
           timeframe.period == '15' ? '45' : 
           timeframe.period == '30' ? '120' : 
           timeframe.period == '45' ? '180' : 
           timeframe.period == '60' ? '240' : 
           timeframe.period == '120' ? '480' : 
           timeframe.period == '180' ? '720' : 
           timeframe.period == '240' ? 'D' : 
           timeframe.period == '360' ? 'D' : 
           timeframe.period == '480' ? '2D' : 
           timeframe.period == '720' ? '3D' : 
           timeframe.period == 'D' ? '3D' : 
           timeframe.period == '3D' ? 'W' : ''

//
i_tf_ob = mode == true ? HTF_auto : HTF_manual


// Dashboard

bullish = buylbl
bearish = selllbl
// Dashboard
gr_dashboard = "DASHBOARD SETTINGS"
showDash  = input(true, "Dashboard", group = gr_dashboard)
dashLoc  = input.string('Bottom Right', 'Location', options = ['Top Right', 'Bottom Right', 'Bottom Left'], group = gr_dashboard)
textSize = input.string('Normal', 'Size', options = ['Tiny', 'Small', 'Normal'], group = gr_dashboard)
// # ========================================================================= #
//                                DASHBOARD
// # ========================================================================= #
// Predicted Reversal
predictedreversal = Long_Signal_Strength > Short_Signal_Strength ? 0 : Short_Signal_Strength > Long_Signal_Strength ? 1 : Short_Signal_Strength == Long_Signal_Strength ? 2 : na
predictedtext = predictedreversal == 0 ? '‚ñ≤' : predictedreversal == 1 ? '‚ñº' : predictedreversal == 2 ? 'Undetected' : 'Undetected'
predictedtextcolor = predictedtext == '‚ñ≤' ? buylbl : predictedtext == '‚ñº' ? selllbl : color.white
predictedtext2 = Long_Signal_Strength > Short_Signal_Strength ? Long_Signal_Strength : Short_Signal_Strength > Long_Signal_Strength ? Short_Signal_Strength : na
//Short_Signal_Strength
//Long_Signal_Strength

// Trend Strength Function
rsilength = 14
overboughtlevel = 70 
oversoldlevel = 30

rsiValue = ta.rsi(close, rsilength)

trendStrength = rsiValue > overboughtlevel ? 100 : rsiValue < oversoldlevel ? 0 : ((rsiValue - oversoldlevel) / (overboughtlevel - oversoldlevel)) * 100

isTrending = trendStrength > 50
trendStrengthPercentage = math.round(trendStrength, 2)
trendIndication = isTrending ? "üî•" : "‚ùÑÔ∏è"
trendemote = isTrending ? "üêÆ" : "üêª"
trendtext = isTrending ? "Bullish" : "Bearish"
textColorstrength = trendStrengthPercentage < 50 ? bearish : bullish

// Volume Function
vollength = 20
buyThreshold = 0.7
sellThreshold = -0.7

volumeRatio = volume / ta.sma(volume, vollength)

volumeSentiment = (math.min(math.max(volumeRatio - 0.5, -0.5), 0.5) * 200)

isBuySentiment = volumeSentiment > buyThreshold
isSellSentiment = volumeSentiment < sellThreshold
textcolorvolu = isBuySentiment ? bullish : bearish

// Volatility Function
volatilength = 20
lowVolatilityThreshold = 0.5
highVolatilityThreshold = 1.5

Volatility = ta.atr(1) / ta.atr(volatilength)

isRisingVolatility = Volatility > ta.sma(Volatility, volatilength)
isFallingVolatility = Volatility < ta.sma(Volatility, volatilength)

isLowVolatility = Volatility < lowVolatilityThreshold
isHighVolatility = Volatility > highVolatilityThreshold

volatilityPercentage = math.min(Volatility * 100, 100)
volatilityIndication = isRisingVolatility ? "üìà" : isFallingVolatility ? "üìâ" : ""
volatilitycolor = isHighVolatility ? bearish : bullish

// Drawing Dashboard
var table_position = dashLoc == 'Bottom Left' ? position.bottom_left 
  : dashLoc == 'Top Right' ? position.top_right 
  : position.bottom_right

var table_size = textSize == 'Tiny' ? size.tiny 
  : textSize == 'Small' ? size.small 
  : size.normal

var tb = table.new(table_position, 8, 8
  , bgcolor = #1e222d
  , border_color = #373a46
  , border_width = 1
  , frame_color = #373a46
  , frame_width = 1)

if showDash
    if barstate.isfirst
        tb.cell(0, 0, "AlgoPoint | www.algopoint.co", text_color = color.white, text_size = table_size)
        tb.merge_cells(0,0,1,0)

    if barstate.islast
        tb.cell(0, 3, str.tostring(trendIndication) + "Trend Strenght", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(0, 4, "üí† Volume", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(0, 5, str.tostring(volatilityIndication) + " Volatility", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(0, 6, str.tostring(trendemote) + " Trend", text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(1, 3, str.tostring(trendStrengthPercentage, format.percent), text_color=textColorstrength, text_size=table_size)
        tb.cell(1, 4, str.tostring(volumeSentiment, format.percent), text_color = textcolorvolu, text_size = table_size)
        tb.cell(1, 5, str.tostring(volatilityPercentage, format.percent), text_color=volatilitycolor, text_size=table_size)
        tb.cell(1, 6, str.tostring(trendtext), text_color = textColorstrength, text_size = table_size)
        tb.cell(0, 7, 'Predicted Reversal', text_color = color.white, text_size = table_size, text_halign = text.align_left)
        tb.cell(1, 7, str.tostring(predictedtext) + ' | ' + str.tostring(predictedtext2), text_color = predictedtextcolor, text_size = table_size)

// Smart Money Concepts

//----------------------------------------}
//Order Blocks
//----------------------------------------{

v_buy = selllbl
v_sell = buylbl

timeframe1=' : '
show_iob = 'All'=='All' or 'All'=='Internal' //input(true, 'Internal', inline = 'ob', group = 'Order Blocks')
show_ob = 'All'=='All' or 'All'=='External' //input(false, 'External', inline = 'ob', group = 'Order Blocks')
ob_showlast = 5//input.int(10, 'LookBack', minval = 1, inline = 'ob', group = 'Order Blocks')
iob_showlast = 5//input.int(5, 'LookBack', minval = 1, inline = 'iob', group = 'Order Blocks')

style = 'Colored'
v_lookback= 10
ob_loockback=10
timediff=(time[1]-time[101])/100

//----------------------------------------}
//Liquidity Levels
//----------------------------------------{

currentTF  = false
htfTF  = ""
_highLineStyleHTF  = "Solid"//input.string("Solid", title = "Line Style", options=["Solid", "Dashed", "Dotted"], group=liquidity_level_group,inline='5')
highLineStyleHTF = _highLineStyleHTF=="Solid" ? line.style_solid : _highLineStyleHTF=="Dashed" ? line.style_dashed : line.style_dotted
box_width  = 2.5//input.float(3.0, title = "Width", group=liquidity_level_group,inline='5', minval = 1, maxval = 10, step = 0.5)
lineWidthHTF=2
lowLineColorHTF = #00bbf94d
highLineColorHTF = #e91e624d
highBoxBorderColorHTF = color.new(highLineColorHTF,90)
lowBoxBorderColorHTF = color.new(lowLineColorHTF,90)
displayStyle_liq  = "Boxes"//'Lines'

//----------------------------------------}
//Fair Value Gaps (FVG
//----------------------------------------{

show_fvg = false
i_tf = ""
i_mtfbearishfvgcolor = #ffffff20 
i_mtfbullishfvgcolor = #ffffff20

i_bullishfvgcolor = color.new(color.green,100)
i_bearishfvgcolor = color.new(color.green,90)
i_fillByMid = true
i_deleteonfill = true
i_textColor = color.white
i_mtf = "HTF"
i_tfos = 10
i_mtfos = 50

//----------------------------------------}
//BOS and ChoCH
//----------------------------------------{

// Constants
color CLEAR = color.rgb(0,0,0,100)

// Inputs
showms=false
bosColor1 = #787b86
bosColor2 = #787b86
swingSize = 3

//-----------------------------------------------------------------------------}
//Global variables
//-----------------------------------------------------------------------------{
color transparent = #ffffff00
length = 50
is_newbar(res) =>
    t = time(res)
    not na(t) and (na(t[1]) or t > t[1])

Show_MS(x, y, txt, css, dashed, down, lbl_size)=>
    label.new(int(math.avg(x, bar_index)), y, txt, color = transparent, textcolor = css, style = down ? label.style_label_down : label.style_label_up, size = lbl_size)
    line.new(x, y, bar_index, y, color = css, style = dashed ? line.style_dashed : line.style_solid)

f_barssince(_cond, _count) =>
    _barssince = bar_index - ta.valuewhen(_cond, bar_index, _count)
    _barssince

//Swings detection/measurements
calculate_swing_points(length)=>
    var prev = 0
    prev := high[length] > ta.highest(length) ? 0 : low[length] < ta.lowest(length) ? 1 : prev[1]
    t = prev == 0 and prev[1] != 0 ? high[length] : 0
    b = prev == 1 and prev[1] != 1 ? low[length] : 0
    [t, b]

var t_MS = 0, var int_t_MS = 0
var internal_y_up = 0., var internal_x_up = 0, var internal_y_dn = 0., var internal_x_dn = 0
var y_up = 0., var x_up = 0 , var y_dn = 0., var x_dn = 0
var crossed_up = true,  var crossed_down = true
var internal_up_broke = true, var internal_dn_broke = true
var up_trailing = high, var down_trailing = low
var up_trailing_x = 0,  var down_trailing_x = 0
var high_text = '',  var low_text = ''
bullish_OB_Break = false 
bearish_OB_Break = false


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------       Market Structure
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



bosConfType = 'Candle High'//input.string('Candle Close', 'BOS Confirmation', ['Candle Close', 'Wicks'], tooltip='Choose whether candle close/wick above previous swing point counts as a BOS.')
ChoCH = true//input.bool(false, 'Show ChoCH', tooltip='Renames the first counter t_MS BOS to ChoCH' )
// showSwing = false//input.bool(true, 'Show Swing Points', tooltip='Show or hide HH, LH, HL, LL')

// Functions
lineStyle(x) =>
    switch x
        'Solid' => line.style_solid
        'Dashed' => line.style_dashed
        'Dotted' => line.style_dotted
pivot_high_found = ta.pivothigh(high, 10, 10)
pivot_low_found = ta.pivotlow(low, 10, 10)

var float prevHigh_s = na,var float prevLow_s = na,var int prevHighIndex_s = na,var int prevLowIndex_s = na
bool higher_highs = false, bool lower_highs = false, bool higher_lows = false, bool lower_lows = false

var int prevSwing_s = 0

if not na(pivot_high_found)
    if pivot_high_found >= prevHigh_s
        higher_highs := true
        prevSwing_s := 2
    else
        lower_highs := true
        prevSwing_s := 1
    prevHigh_s := pivot_high_found
    prevHighIndex_s := bar_index - 10

if not na(pivot_low_found)
    if pivot_low_found >= prevLow_s
        higher_lows := true
        prevSwing_s := -1
    else
        lower_lows := true
        prevSwing_s := -2
    prevLow_s := pivot_low_found
    prevLowIndex_s := bar_index - 10


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------       Fair Value Gaps
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// }

// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Global data {
//Using current bar data for HTF highs and lows instead of security to prevent future leaking
var htfH = open
var htfL = open

if close > htfH 
    htfH:= close
if close < htfL
    htfL := close


//Security Data, used for HTF Bar Data reference


sClose = request.security(ticker.standard(syminfo.tickerid), i_tf, close[1], barmerge.gaps_off, barmerge.lookahead_on)
sHighP2 = request.security(ticker.standard(syminfo.tickerid), i_tf, high[2], barmerge.gaps_off, barmerge.lookahead_on)
sLowP2 = request.security(ticker.standard(syminfo.tickerid), i_tf, low[2], barmerge.gaps_off, barmerge.lookahead_on)
sOpen = request.security(ticker.standard(syminfo.tickerid), i_tf, open[1], barmerge.gaps_off, barmerge.lookahead_on)
sBar = request.security(ticker.standard(syminfo.tickerid), i_tf, bar_index, barmerge.gaps_off, barmerge.lookahead_on)

// }

//var keyword can be used to hold data in memory, with pinescript all data is lost including variables unless the var keyword is used to preserve this data
var bullishgapholder = array.new_box(0)
var bearishgapholder = array.new_box(0)

var bullishgapholder_fill = array.new_box(0)
var bearishgapholder_fill = array.new_box(0)

var bullish_high_holder = array.new_line(0)
var bearish_high_holder = array.new_line(0)
var bullish_low_holder = array.new_line(0)
var bearish_low_holder = array.new_line(0)
var bullishmidholder = array.new_line(0)
var bearishmidholder = array.new_line(0)
var bullishlabelholder = array.new_label(0)
var bearishlabelholder = array.new_label(0)
var transparentcolor = color.new(color.white,100)

var fvg_apper=false
var fvg_break=false


fvg_apper:=false
fvg_break:=false
// ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî Functions {

//function paramaters best declared with '_' this helps defer from variables in the function scope declaration and elsewhere e.g. close => _close
create_fvg_func(_upperlimit,_lowerlimit,_midlimit,_bar,_boxholder,_boxholder_fill,_midholder,_highholder,_lowholder,_labelholder,_boxcolor,_mtfboxcolor, _htf)=>
    timeholder = str.tostring(i_tf)
    offset = i_mtfos
    boxbgcolor = _mtfboxcolor
    bg_color = color.new(_mtfboxcolor,90)
    if _htf == false
        timeholder := str.tostring(timeframe.period)
        offset := i_tfos
        boxbgcolor := _boxcolor
    array.push(_boxholder,box.new(_bar,_upperlimit,_bar+(timediff)*20,_lowerlimit,border_color=true? bg_color : na,bgcolor = true? bg_color : na, extend = false ? extend.right:extend.none,xloc = xloc.bar_time,text='',text_color=#787b86,text_halign=text.align_right,text_size=size.small))
    array.push(_boxholder_fill,box.new(_bar,_upperlimit,_bar+(timediff)*20,_lowerlimit,border_color=true? bg_color : na ,bgcolor = true? bg_color : na, extend = false ? extend.right:extend.none,xloc = xloc.bar_time))
    array.push(_midholder,line.new(_bar,(_lowerlimit+_upperlimit)/2.0,_bar+(timediff)*20,_midlimit,color = #787b86, extend = false ? extend.right:extend.none,style=line.style_solid,width=1,xloc = xloc.bar_time))
    array.push(_lowholder,line.new(_bar,_lowerlimit,_bar+(timediff)*20,_lowerlimit,color = i_fillByMid?boxbgcolor:na, extend = false ? extend.right:extend.none,width=1,xloc = xloc.bar_time))
    array.push(_highholder,line.new(_bar,_upperlimit,_bar+(timediff)*20,_upperlimit,color = i_fillByMid?boxbgcolor:na, extend = false ? extend.right:extend.none,width=1,xloc = xloc.bar_time))


//checks for gap between current candle and 2 previous candle e.g. low of current candle and high of the candle before last, this is the fair value gap.
check_fvg_func(_close,_high,_highp2,_low,_lowp2,_open,_bar,_htf)=>
    gap=0
    thold_ = (ta.highest(_high,300) - ta.lowest(_low,300)) * math.max(1.5, 0.1) / 100.
    if _open > _close // red

        if _lowp2>_high
            if not(true) or math.abs(_lowp2 -_high) > thold_
                upperlimit = _high//_close - (_close - _lowp2 )
                lowerlimit = _lowp2//_close - (_close-_high)
                midlimit = lowerlimit + ((upperlimit - lowerlimit) / 2.)
                gap:=1
                create_fvg_func(upperlimit,lowerlimit,midlimit,_bar,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder,i_bullishfvgcolor,i_mtfbullishfvgcolor,_htf)
            
    else
        
        if _low>_highp2
            if not(true) or math.abs(_low - _highp2) > thold_
                upperlimit = _low//_close - (_close-_low)
                lowerlimit = _highp2//_close- (_close - _highp2),
                midlimit = lowerlimit + ((upperlimit - lowerlimit) / 2.)
                gap:=-1
                create_fvg_func(upperlimit,lowerlimit,midlimit,_bar,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder,i_bearishfvgcolor,i_mtfbearishfvgcolor,_htf)
            
    gap

//Used to remove the gap from its relevant array as a result of it being filled.
delete_fvg_func(_currentgap,_currentgap_fill,_i,_boxholder,_boxholder_fill,_midholder,_highholder,_lowholder,_labelholder)=>
   
    array.remove(_boxholder,_i)
    array.remove(_boxholder_fill,_i)

    currentmid=array.get(_midholder,_i)
    currenthigh=array.get(_highholder,_i)
    currentlow=array.get(_lowholder,_i)
    array.remove(_midholder,_i)
    array.remove(_highholder,_i)
    array.remove(_lowholder,_i)
    
    if i_deleteonfill
        line.delete(currentmid)
        line.delete(currenthigh)
        line.delete(currentlow)
    else
        line.set_extend(currentmid, extend.none)
        line.set_x2(currentmid,time)
        line.set_extend(currenthigh, extend.none)
        line.set_x2(currenthigh,time)
        line.set_extend(currentlow, extend.none)
        line.set_x2(currentlow,time)

    if i_deleteonfill
        box.delete(_currentgap)
        box.delete(_currentgap_fill)
        
        
    else
        box.set_extend(_currentgap,extend.none)
        box.set_right(_currentgap,time)


//checks if gap has been filled either by 0.5 fill (i_fillByMid) or SHRINKS the gap to reflect the true value gap left.
validate_fvg_func(_high,_low)=>

    fvg_removed=0
    if array.size(bullishgapholder) > 0

        for i = array.size(bullishgapholder)-1 to 0
            currentgap_fill = array.get(bullishgapholder_fill,i)
            currentgap = array.get(bullishgapholder,i)
            cmid = array.get(bullishmidholder,i)
            chigh = array.get(bullish_high_holder,i)
            clow = array.get(bullish_low_holder,i)
            line.set_x2(cmid,timenow+(timediff)*20)
            line.set_x2(chigh,timenow+(timediff)*20)
            line.set_x2(clow,timenow+(timediff)*20)
            box.set_right(currentgap_fill,timenow+(timediff)*20)
            box.set_right(currentgap,timenow+(timediff)*20)

              
            currentmid = array.get(bullishmidholder,i)
            currenthigh = array.get(bullish_high_holder,i)
            currentlow = array.get(bullish_low_holder,i)
            currenttop = box.get_top(currentgap)

            if high > currenttop
                fvg_removed:=1
                delete_fvg_func(currentgap,currentgap_fill,i,bullishgapholder,bullishgapholder_fill,bullishmidholder,bullish_high_holder,bullish_low_holder,bullishlabelholder)
            
       
    if array.size(bearishgapholder) > 0
            
        for i = array.size(bearishgapholder)-1 to 0
            
            currentgap_fill = array.get(bearishgapholder_fill,i)
            currentgap = array.get(bearishgapholder,i)
            cmid = array.get(bearishmidholder,i)
            chigh = array.get(bearish_high_holder,i)
            clow = array.get(bearish_low_holder,i)
            line.set_x2(cmid,timenow+(timediff)*20)
            line.set_x2(chigh,timenow+(timediff)*20)
            line.set_x2(clow,timenow+(timediff)*20)
            box.set_right(currentgap_fill,timenow+(timediff)*20)
            box.set_right(currentgap,timenow+(timediff)*20)


            currenttop = box.get_top(currentgap)
            currentmid = array.get(bearishmidholder,i)
            currenthigh = array.get(bearish_high_holder,i)
            currentlow = array.get(bearish_low_holder,i)
    
            if low < currenttop
                fvg_removed:=-1
                delete_fvg_func(currentgap,currentgap_fill,i,bearishgapholder,bearishgapholder_fill,bearishmidholder,bearish_high_holder,bearish_low_holder,bearishlabelholder)
       
    fvg_removed
                
// pine provided function to determine a new bar

if is_newbar(i_tf)
    htfH := high
    htfL := low

// }

fvg_gap=0

// User Input, allow MTF data calculations
if is_newbar(i_tf) and (i_mtf == "Current + HTF" or i_mtf == "HTF") and show_fvg and barstate.isconfirmed
    fvg_gap:=check_fvg_func(sClose,htfH,sHighP2,htfL,sLowP2,sOpen,time[2],true)
    

alertcondition(fvg_gap==1,"Bullish FVG","Bullish FVG Found Harmony Algo")
alertcondition(fvg_gap==-1,"Bearish FVG","Bearish FVG Found Harmony Algo")


fvg_removed=validate_fvg_func(high,low)

alertcondition(fvg_removed==1,"Bullish FVG Break","Bullish FVG Broken Harmony Algo")
alertcondition(fvg_removed==-1,"Bearish FVG Break","Bearish FVG Broken Harmony Algo")

if array.size(bullishgapholder) > 4
    d_box=array.shift(bullishgapholder)
    box.delete(d_box)

if array.size(bullishgapholder_fill) > 4
    d_box=array.shift(bullishgapholder_fill)
    box.delete(d_box)

if array.size(bullishmidholder) > 4
    d_line=array.shift(bullishmidholder)
    line.delete(d_line)

if array.size(bullish_high_holder) > 4
    d_line=array.shift(bullish_high_holder)
    line.delete(d_line)

if array.size(bullish_low_holder) > 4
    d_line=array.shift(bullish_low_holder)
    line.delete(d_line)

if array.size(bearishgapholder) > 4
    d_box_=array.shift(bearishgapholder)
    box.delete(d_box_)

if array.size(bearishgapholder_fill) > 4
    d_box_=array.shift(bearishgapholder_fill)
    box.delete(d_box_)

if array.size(bearishmidholder) > 4
    d_line_=array.shift(bearishmidholder)
    line.delete(d_line_)

if array.size(bearish_high_holder) > 4
    d_line_=array.shift(bearish_high_holder)
    line.delete(d_line_)

if array.size(bearish_low_holder) > 4
    d_line_=array.shift(bearish_low_holder)
    line.delete(d_line_)
    


n=bar_index



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------       Liquidity Levels
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


// --
highLineColor = highLineColorHTF//input.color(#1f4ef5, "High Line‚Äá‚Äá‚Äá", group = liquidity_level_group, inline = "1")
lowLineColor = lowLineColorHTF//input.color(#fd441c, "Low Line", group = liquidity_level_group, inline = "1")
highBoxBgColor = highLineColorHTF//input.color(color.new(#1f4ef5, 80), "High Box Bg‚Äá", group = liquidity_level_group, inline = "2")
highBoxBorderColor = highBoxBorderColorHTF//input.color(color.new(#1f4ef5, 80), "Box Border", group = liquidity_level_group, inline = "2")
lowBoxBgColor = lowLineColorHTF//input.color(color.new(#fd441c, 80), "Low Box Bg‚Äá‚Äá", group = liquidity_level_group, inline = "3")
lowBoxBorderColor = lowBoxBorderColorHTF//input.color(color.new(#fd441c, 80), "Box Border", group = liquidity_level_group, inline = "3")
atr_liq = ta.atr(300)

float thold_liq = atr_liq * (box_width / 10)
// --
// --
// --
// ----------------------------------------------------
// Functions 
// ----------------------------------------------------

tf_multi(tf) =>
    ts = timeframe.in_seconds("")
    htfs = timeframe.in_seconds(tf)
    htfs/ts

display_limit_line(_array) =>
    if array.size(_array) > 6/2
        a = array.shift(_array)
        line.delete(a)

display_limit_box(_array) =>
    if array.size(_array) > 6/2
        a = array.shift(_array)
        box.delete(a)

remove_mitigated_lines(_array, _hl) =>
    m = false
    if array.size(_array) > 0      
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = "Close" == "Close" ? close[1] : high
            ll = "Close" == "Close" ? close[1] : low
            if _hl == "High" and hh > line.get_y1(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = highLineColorHTF, style=highLineStyleHTF, width = lineWidthHTF)
                line.delete(l)
                m := true
            if _hl == "Low" and ll < line.get_y1(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    line.new(line.get_x1(l),line.get_y1(l),time,line.get_y1(l), xloc=xloc.bar_time, color = lowLineColorHTF, style=highLineStyleHTF, width = lineWidthHTF)
                line.delete(l) 
                m := true  
    display_limit_line(_array) 
    m

remove_mitigated_boxes(_array, _hl) =>
    m = false
    if array.size(_array) > 0
        for i = array.size(_array) - 1 to 0 by 1
            l = array.get(_array, i)
            hh = "Close" == "Close" ? close[1] : high
            ll = "Close" == "Close" ? close[1] : low
            if _hl == "High" and hh > box.get_top(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(highBoxBgColor, 90), border_color = color.new(highBoxBorderColor, 90), border_style = highLineStyleHTF)
                box.delete(l)
                m := true
            if _hl == "Low" and ll < box.get_top(l)
                array.remove(_array, i)
                if "Remove" == "Show"
                    box.new(box.get_left(l),box.get_top(l),time,box.get_bottom(l), xloc=xloc.bar_time, bgcolor = color.new(lowBoxBgColor, 90), border_color = color.new(lowBoxBorderColor, 90), border_style = highLineStyleHTF)
                box.delete(l)
                m := true
    display_limit_box(_array) 
    m

extend_line_to_current(lineArray) =>
    if array.size(lineArray) > 0
        for i = array.size(lineArray) - 1 to 0 by 1
            l = array.get(lineArray, i)
            timeExt = timenow + ((timediff)*20)
            line.set_x2(l, timeExt)

extend_box_to_current(boxArray) =>
    if array.size(boxArray) > 0
        for i = array.size(boxArray) - 1 to 0 by 1
            b = array.get(boxArray, i)
            timeExt = timenow + ((timediff)*20)
            box.set_right(b, timeExt)

// ----------------------------------------------------
// Higher TimeFrame
// ----------------------------------------------------
// Varibles 
// Lines
var highLineArrayHTF = array.new_line()
var lowLineArrayHTF = array.new_line()

// Boxes
var highBoxArrayHTF = array.new_box()
var lowBoxArrayHTF = array.new_box()

// Get HTF
[_time, _open, _high, _low, _close] = request.security(syminfo.tickerid, htfTF, [time, open, high, low, close])

// Pivots
pivotHighHTF = ta.pivothigh(_high, 8*tf_multi(htfTF), 8+tf_multi(htfTF))
pivotLowHTF = ta.pivotlow(_low, 8*tf_multi(htfTF), 8+tf_multi(htfTF))

if currentTF
    timeExt = time+((time[1]-time[2])*10)
    dis = 8+tf_multi(htfTF)
    if pivotHighHTF
        if displayStyle_liq == "Lines"
            array.push(highLineArrayHTF, line.new(_time[dis],_high[dis],_time[+1],_high[dis],color = highLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, width = lineWidthHTF))
        else
            y1 = _high[dis]-thold_liq//math.max(_open[dis], _close[dis])
            array.push(highBoxArrayHTF, box.new(_time[dis],_high[dis],_time[+1],y1,bgcolor = highLineColorHTF, border_color=highBoxBorderColorHTF, xloc=xloc.bar_time, border_style = highLineStyleHTF, border_width = lineWidthHTF))  
    if pivotLowHTF
        if displayStyle_liq == "Lines"
            array.push(lowLineArrayHTF, line.new(_time[dis],_low[dis],_time[+1],_low[dis],color = lowLineColorHTF, style=highLineStyleHTF, xloc=xloc.bar_time, width = lineWidthHTF))
        else
            y1 = _low[dis]+thold_liq//math.min(_open[dis], _close[dis])
            array.push(lowBoxArrayHTF, box.new(_time[dis],_low[dis],_time[+1],y1,bgcolor = lowLineColorHTF, border_color=lowBoxBorderColorHTF, xloc=xloc.bar_time, border_style = highLineStyleHTF, border_width = lineWidthHTF))

// ----------------------------------------------------
// Run Functions
// ----------------------------------------------------
highLineAlertHTF = remove_mitigated_lines(highLineArrayHTF, "High")
lowLineAlertHTF = remove_mitigated_lines(lowLineArrayHTF, "Low")
highBoxAlertHTF = remove_mitigated_boxes(highBoxArrayHTF, "High")
lowBoxAlertHTF = remove_mitigated_boxes(lowBoxArrayHTF, "Low")


extend_line_to_current(highLineArrayHTF)
extend_line_to_current(lowLineArrayHTF)
extend_box_to_current(highBoxArrayHTF)
extend_box_to_current(lowBoxArrayHTF)

// Alerts
alertcondition(pivotHighHTF, "High Liquidity Level", "High Liquidity Level Found Ez-SMC")
alertcondition(pivotLowHTF, "Low Liquidity Level", "Low Liquidity Level Found Ez-SMC")

alertcondition(highLineAlertHTF or highBoxAlertHTF, "High Liquidity Level Break", "High Liquidity Level Broken Ez-SMC")
alertcondition(lowLineAlertHTF or lowBoxAlertHTF, "Low Liquidity Level Break", "Low Liquidity Level Broken Ez-SMC")



swing_bull_css = bosColor1
swing_bear_css = bosColor2 
var bullish_col_ChoCH = swing_bull_css
var bearish_col_ChoCH = swing_bear_css
var internal_bullish_col_ChoCH = bosColor1
var internal_bearish_col_ChoCH = bosColor2
[high_ms, low_ms] = calculate_swing_points(length)
n := bar_index
//HL Output function
hl() => [high, low]
var float thold = (ta.highest(300) - ta.lowest(300)) * math.max(0.5, 0.1) / 100.
internal_structure_lbl_size=size.small
[int_high_ms, int_low_ms] = calculate_swing_points(swingSize)
swing_structure_lbl_size=size.small
if low_ms
    crossed_down := true
    y_dn := low_ms
    x_dn := n-length
if high_ms
    crossed_up := true
    y_up := high_ms
    x_up := n - length
if int_low_ms
    internal_dn_broke := true
    internal_y_dn := int_low_ms
    internal_x_dn := n - swingSize
if int_high_ms
    internal_up_broke := true
    internal_y_up := int_high_ms
    internal_x_up := n - swingSize
bull_ChoCH=false,bull_ChoCH_=false,bull_bos=false,bull_bos_=false,bear_ChoCH=false,bear_ChoCH_=false,bear_bos=false,bear_bos_=false
if ta.crossover(close, internal_y_up) and internal_up_broke and y_up != internal_y_up
    bool ChoCH = na
    ChoCH := int_t_MS < 0
    internal_up_broke := false
    int_t_MS := 1
    bull_ChoCH:=ChoCH?true:false
    bull_bos:=ChoCH?false:true
    if showms
        Show_MS(internal_x_up, internal_y_up, ChoCH ? 'ChoCH' : 'BOS', internal_bullish_col_ChoCH, true, true, internal_structure_lbl_size)
if ta.crossunder(close, internal_y_dn) and internal_dn_broke and y_dn != internal_y_dn 
    bool ChoCH = false
    ChoCH := int_t_MS > 0    
    internal_dn_broke := false
    int_t_MS := -1
    bear_ChoCH:=ChoCH?true:false
    bear_bos:=ChoCH?false:true
    if showms
        Show_MS(internal_x_dn, internal_y_dn, ChoCH ? 'ChoCH' : 'BOS', internal_bearish_col_ChoCH, true, false, internal_structure_lbl_size)

alertcondition(bull_ChoCH,"Bullish ChoCH",'Bullish ChoCH Found Ez-SMC')
alertcondition(bear_ChoCH,"Bearish ChoCH",'Bearish ChoCH Found Ez-SMC')
alertcondition(bull_bos,"Bullish BOS",'Bullish BOS Found Ez-SMC')
alertcondition(bear_bos,"Bearish BOS",'Bearish ChoCH Found Ez-SMC')



if ta.crossover(close, y_up) and crossed_up
    bool ChoCH = na
    ChoCH := t_MS < 0
    crossed_up := false
    t_MS := 1
    bull_ChoCH_:=ChoCH?true:false
    bull_bos_:=ChoCH?false:true
    if showms
        Show_MS(x_up, y_up, ChoCH ? 'ChoCH+' : 'BOS+', bullish_col_ChoCH, false, true, swing_structure_lbl_size)
if ta.crossunder(close, y_dn) and crossed_down
    bool ChoCH = na
    ChoCH := t_MS > 0
    crossed_down := false
    t_MS := -1
    bear_ChoCH_:=ChoCH?true:false
    bear_bos_:=ChoCH?false:true
    if showms
        Show_MS(x_dn, y_dn, ChoCH ? 'ChoCH+' : 'BOS+', bearish_col_ChoCH, false, false, swing_structure_lbl_size)

alertcondition(bull_ChoCH_,"Bullish ChoCH+",'Bullish ChoCH+ Found Harmony Algo')
alertcondition(bear_ChoCH_,"Bearish ChoCH+",'Bearish ChoCH+ Found Harmony Algo')
alertcondition(bear_bos_,"Bearish BOS+",'Bearish BOS+ Found Harmony Algo')
alertcondition(bull_bos_,"Bullish BOS+",'Bullish BOS+ Found Harmony Algo')

//-----------------------------------------------------------------------------}
//Order Blocks
//-----------------------------------------------------------------------------{
first_nonzero_digit(n) => 
    s = str.tostring(n)

    int r=int (str.tonumber(s[0]))
    for c=0 to str.length(s)-1
        if s[c] != '0'
            r:=int (str.tonumber(s[c]))
    r 

//Order block coordinates function
ob_found(loc,b_index,show_ob,show_iob)=>
    
    type_obs="none"
    valid=false
    H=high
    L=low
    O=open
    C=close
    V=volume
    idx=1
    volume_=0.0
    b_volume=0
    s_volume=0
    use_max=false
    min = 99999999.
    max = 0.

    if open[5]>close[5] and close[4]>=open[5] and low[1]>high[5] and low>high[5] and show_iob
        if low[5]>low[4]
            type_obs:="Internal Bearish"
            H:=math.min(high[4],high[5])
            L:=low[4]
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=false
        else
            type_obs:="Internal Bearish"
            H:=high[5]
            L:=low[5]
            O:=open[5]        
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=false
    
    else if open[5]<close[5] and close[4]<=open[5] and high[1]<low[5] and high<low[5] and show_iob
        if high[4]>high[5]
            type_obs:="Internal Bullish"
            H:=high[4]
            L:=math.max(low[4],low[5])
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=true
        else
            type_obs:="Internal Bullish"
            H:=high[5]
            L:=low[5]
            O:=open[5]        
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=true

    else if open[5]>close[5] and close[4]>close[5] and close[3]>=open[5] and low>high[5] and show_iob
        if low[5]>low[4]
            type_obs:="Internal Bearish"
            H:=math.min(high[4],high[5])
            L:=low[4]
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=false
        else
            type_obs:="Internal Bearish"
            H:=high[5]
            L:=low[5]
            O:=open[5]        
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=false

    else if open[5]<close[5] and close[4]<close[5] and close[3]<=open[5] and high<low[5] and show_iob
        if high[4]>high[5]
            type_obs:="Internal Bullish"
            H:=high[4]
            L:=math.max(low[4],low[5])
            O:=open[4]        
            C:=close[4]
            V:=volume[4]
            idx:=time[4]
            valid:=true
            use_max:=true
        else
            type_obs:="Internal Bullish"
            H:=high[5]
            L:=low[5]
            O:=open[5]      
            C:=close[5]
            V:=volume[5]
            idx:=time[5]
            valid:=true
            use_max:=true
    else
        valid:=false

    if valid
        
        ind=0
        thold_ = (ta.highest(300) - ta.lowest(300)) * (3/2.) / 100.

        buyingVolume = math.round(V * (C - L) / (H - L))
        sellingVolume = math.round(V * (H - C) / (H - L))
        t_volume = (buyingVolume+sellingVolume)/2.
        b_volume:=int ((buyingVolume/ta.highest(t_volume,300))*100)
        s_volume:=int ((sellingVolume/ta.highest(t_volume,300))*100)

        volume_:=V
        //Search for highest/lowest high within the structure interval and get range
        if use_max
            max:=H//[idx]
            min_1=L//[idx]//H[1]-math.min(open[1],close[1])>ob_threshold
            min:=math.max(min_1,max-thold_)
        else
            max_1=H//[idx]//math.max(open[idx],close[idx])
            min:=L//[idx]
            max:=math.min(max_1,min+thold_)

    [valid,volume_,b_volume,s_volume,max,min,idx,use_max ? -1 : 1,type_obs]


//Set order blocks
show_orderblock(boxes,lines, target_top, target_btm, target_left, target_type, show_last, swing, size,vol,col_1,col_2,length_extend_ob,ob_extend,tf_text,tf_text_2,ob_text_size,vol_text,perct_text,text_color_ob,show_line_obs,line_style_obs)=>
    for x = 0 to show_last-1
        get_box = array.get(boxes, x)
        box.set_lefttop(get_box, na, na)
        box.set_rightbottom(get_box, na , na)
        box.set_border_color(get_box, na)
        box.set_bgcolor(get_box, na)
        get_line = array.get(lines, x)
        line.set_color(get_line,na)
        line.set_xy1(get_line,na,na)
        line.set_xy2(get_line,na,na)

    for i = 0 to size-1
        get_box = array.get(boxes, i)
        get_line = array.get(lines, i)
        max_left=bar_index-750
        volume_sum=array.sum(vol)
        volume_=array.get(vol, i)>100000000 ? array.get(vol, i)/100000000.: array.get(vol, i)>1000000 ? array.get(vol, i)/1000000. : array.get(vol, i)/1000.
        volume_per=(array.get(vol, i)/volume_sum)*100
        unit=array.get(vol, i)>100000000 ?' B': array.get(vol, i)>1000000 ?' M' : ' K'
        text_vol=vol_text and perct_text ? tf_text +  str.tostring(volume_,'#.##')+ unit + ' ('+ str.tostring(volume_per,'#.##')+'%)' : vol_text and not(perct_text) ? tf_text +  str.tostring(volume_,'#.##')+ unit : not(vol_text) and perct_text ? tf_text +   ' '+ str.tostring(volume_per,'#.##')+'%' : tf_text_2+  ''
        if true//max_left<array.get(target_left, i)
            box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
            box.set_rightbottom(get_box,timenow+((timediff)*length_extend_ob) , array.get(target_btm, i))
            box.set_text(get_box,text_vol)
            box.set_text_color(get_box,text_color_ob)
            box.set_border_color(get_box,color.gray)
            box.set_border_width(get_box,2)
            box.set_text_halign(get_box,text.align_right)
            box.set_text_valign(get_box,text.align_center)
            box.set_text_size(get_box,ob_text_size)
            fully_extend=not(vol_text) and not(perct_text) and ob_extend? extend.right : extend.none
            len_ext=not(vol_text) and not(perct_text)?length_extend_ob : length_extend_ob/2
            line.set_extend(get_line,fully_extend)
            line.set_style(get_line,line_style_obs)
            line.set_xy1(get_line,array.get(target_left, i),array.get(target_top, i)-(array.get(target_top, i) - array.get(target_btm, i))/2)
            line.set_xy2(get_line,time+((timediff)*(len_ext)),array.get(target_top, i)-(array.get(target_top, i) - array.get(target_btm, i))/2)
            if show_line_obs
                line.set_color(get_line,color.gray)

            if ob_extend
                box.set_extend(get_box, extend.right)

            color css = na
            css := array.get(target_type, i) == 1 ? col_1 : col_2
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
            box.set_border_color(get_box, css)
            
display_sub_ob_buy(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size,right1,right2)=>
    for x = 0 to show_last-1
        get_box = array.get(boxes, x)
        box.set_lefttop(get_box, na, na)
        box.set_rightbottom(get_box, na , na)
        box.set_border_color(get_box, na)
        box.set_bgcolor(get_box, na)

    for i = 0 to math.min(show_last-1, size-1)
        get_box = array.get(boxes, i)
        x=1000000000000
        max_left=bar_index-750
        right=math.max(array.get(right1, i),array.get(right2, i))
        max_right=array.get(target_left, i)+(((timediff)*right+10)) //> time+((time[1]-time[2])*20 ? time+((time[1]-time[2])*20) : array.get(target_left, i)+(time+((time[1]-time[2])*(array.get(right, i)+10))))
        if true//max_left<array.get(target_left, i)
            box.set_lefttop(get_box, math.max(array.get(target_left, i),max_left), array.get(target_top, i)-(array.get(target_top, i) - array.get(target_btm, i))/10)
            box.set_rightbottom(get_box, math.min(max_right,timenow+((timediff)*20)), array.get(target_btm, i)+(array.get(target_top, i) - array.get(target_btm, i))/10)
            //box.set_right(get_box, array.get(target_left, i)+100)
            //box.set_extend(get_box, extend.right)
            color css = na
            if true//max_left<array.get(target_left, i)
                css := array.get(right1, i)>array.get(right2, i)? v_sell : v_buy
                box.set_border_color(get_box, color.new(css,100))
                box.set_bgcolor(get_box, css)

remove_ob(target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    del_index=0
    deleted=false
    for i = 0 to size-1
        if i>0
            for x=i-1 to 0
                if array.get(target_top,i)>=array.get(target_btm,x) and array.get(target_top,i)<=array.get(target_top,x)
                    deleted:=true
                    del_index:=i
                if array.get(target_btm,i)>=array.get(target_btm,x) and array.get(target_btm,i)<=array.get(target_top,x)
                    deleted:=true
                    del_index:=i
                if array.get(target_btm,i)==array.get(target_btm,x) and array.get(target_top,i)==array.get(target_top,x)
                    deleted:=true
                    del_index:=i
                if array.get(target_btm,i)<=array.get(target_btm,x) and array.get(target_top,i)>=array.get(target_top,x)
                    deleted:=true
                    del_index:=i
    [deleted,del_index]

time_diff()=>((time[1]-time[101])/100)


//-----------------------------------------------------------------------------}
//Order Blocks Arrays
//-----------------------------------------------------------------------------{

var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)
var ob_sell_vol = array.new_int(0)
var ob_buy_vol = array.new_int(0)
var ob_vol = array.new_float(0)

bar_merge=barmerge.gaps_off
look_bars=barmerge.lookahead_on

[valid_ob,volume_,b_volume,s_volume,top_ob,btm_ob,left_ob,type_ob,_type]=request.security(ticker.standard(syminfo.tickerid), i_tf_ob, ob_found(x_up,bar_index,show_ob,show_iob), bar_merge,look_bars)


tf1_time=request.security(ticker.standard(syminfo.tickerid),i_tf_ob,time_diff(), bar_merge,look_bars)

if valid_ob and not(valid_ob[1]) and barstate.isconfirmed
    array.unshift(ob_vol, volume_)
    array.unshift(ob_buy_vol, b_volume)
    array.unshift(ob_sell_vol, s_volume)
    array.unshift(ob_top, top_ob)
    array.unshift(ob_btm, btm_ob)
    array.unshift(ob_left, left_ob)
    array.unshift(ob_type, type_ob)


alertcondition(_type=="External Bearish",'Bearish External OB','Bearish External OB Found Harmony Algo')
alertcondition(_type=="External Bullish",'Bullish External OB','Bullish External OB Found Harmony Algo')
alertcondition(_type=="Internal Bearish",'Bearish Internal OB','Bearish Internal OB Found Harmony Algo')
alertcondition(_type=="Internal Bullish",'Bullish Internal OB','Bullish Internal OB Found Harmony Algo')

//Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

var ob_volume = array.new_line(0)
var ob_volume_labels = array.new_label(0)

var iob_boxes_buy = array.new_box(0)
var ob_boxes_buy = array.new_box(0)

var iob_boxes_sell = array.new_box(0)
var ob_boxes_sell = array.new_box(0)


if array.size(ob_top)>4// or array.get(ob_left,array.size(ob_left)-1)>bar_index-400
    array.pop(ob_top)
    array.pop(ob_btm)
    array.pop(ob_left)
    array.pop(ob_type)
    array.pop(ob_buy_vol)
    array.pop(ob_sell_vol)
    array.pop(ob_vol)

// //Delete internal order blocks box coordinates if high_ms/bottom is broken

if array.size(ob_top)>1
    for index=0 to array.size(ob_top)-1
        src1= low
        src2= high
        up= array.get(ob_btm, index)
        dn= array.get(ob_top, index)

        if (src1 < up or src1[1] < up) and array.get(ob_type, index) == 1
            array.remove(ob_top, index) 
            array.remove(ob_btm, index) 
            array.remove(ob_left, index) 
            array.remove(ob_type, index)
            array.remove(ob_buy_vol, index)
            array.remove(ob_sell_vol, index)
            array.remove(ob_vol, index)
            bullish_OB_Break := true
            break

        else if (src2 > dn or src2[1] > dn) and array.get(ob_type, index) == -1
            array.remove(ob_top, index) 
            array.remove(ob_btm, index)
            array.remove(ob_left, index) 
            array.remove(ob_type, index)
            array.remove(ob_buy_vol, index)
            array.remove(ob_sell_vol, index)
            array.remove(ob_vol, index)
            bearish_OB_Break := true
            break

alertcondition(bullish_OB_Break,'Bullish OB Break','Bullish OB Broken Harmony Algo')
alertcondition(bearish_OB_Break,'Bearish OB Break','Bearish OB Broken Harmony Algo')



// iob_size = array.size(iob_type)
ob_size = array.size(ob_type)


if barstate.islast
    if true
        for i = 0 to 4-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
            array.push(ob_boxes_buy, box.new(na,na,na,na, xloc = xloc.bar_time))
            array.push(ob_boxes_sell, box.new(na,na,na,na, xloc = xloc.bar_time))
            array.push(ob_volume, line.new(na,na,na,na,xloc = xloc.bar_time,color=color.gray,style=line.style_solid,width = 1))


if ob_size > 1
    [deleted_ob,del_index]=remove_ob(ob_top, ob_btm, ob_left, ob_type, 4, false, ob_size)
    if deleted_ob
        array.remove(ob_top, del_index)
        array.remove(ob_btm, del_index)
        array.remove(ob_left, del_index)
        array.remove(ob_type, del_index)
        array.remove(ob_buy_vol, del_index)
        array.remove(ob_sell_vol, del_index)
        array.remove(ob_vol, del_index)


// iob_size := array.size(iob_type)
ob_size := array.size(ob_type)

if ob_size > 0 and barstate.islast
    if show_order_blocks
        show_orderblock(ob_boxes,ob_volume, ob_top, ob_btm, ob_left, ob_type, 4, false, ob_size,ob_vol,ibull_ob_css,ibear_ob_css,30,false,'','',size.small,false,true,#787b86,true,line.style_solid)
        // if v_filter
        //     display_sub_ob_buy(ob_boxes_buy, ob_top, ob_btm, ob_left, ob_type, max_obs, false, ob_size,ob_buy_vol,ob_sell_vol)
        //     display_sub_ob_sell(ob_boxes_sell, ob_top, ob_btm, ob_left, ob_type, max_obs, false, ob_size,ob_sell_vol)




//-----------------------------------------------------------------------------}
//TradingView standard RSI calculation
srrc = close
leen = 14
uup = ta.rma(math.max(ta.change(srrc), 0), leen)
dowwn = ta.rma(-math.min(ta.change(srrc), 0), leen)
rsiiaa = dowwn == 0 ? 100 : uup == 0 ? 0 : 100 - 100 / (1 + uup / dowwn)

//Defining ranges by 10% increments
tier1 = rsiiaa <= 14
tier2 = rsiiaa > 14 and rsiiaa <= 28
tier3 = rsiiaa > 28 and rsiiaa <= 42
tier4 = rsiiaa > 42 and rsiiaa <= 56
tier5 = rsiiaa > 56 and rsiiaa <= 70
tier6 = rsiiaa > 70 and rsiiaa <= 84
tier7 = rsiiaa > 84 and rsiiaa <= 100

//Assign color based on range
barcolor(tier1 ? #FFFFFF : na)
barcolor(tier2 ? #e0fbff : na)
barcolor(tier3 ? #e0fbff : na)
barcolor(tier4 ? #80eeff : na)
barcolor(tier5 ? #61eaff : na)
barcolor(tier6 ? #61eaff : na)
barcolor(tier7 ? #00dbff : na)