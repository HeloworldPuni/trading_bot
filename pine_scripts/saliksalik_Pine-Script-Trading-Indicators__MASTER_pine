// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)
// MASTER - Trend Signals with TP & SL Boxes + Range Filter

//@version=5
indicator("MASTER - Trend Signals with Boxes [Enhanced]", shorttitle = "MASTER", overlay = true, max_boxes_count = 500, max_labels_count = 500)

//═══════════════════════════════════════════════════════════════════════════════
// SETTINGS
//═══════════════════════════════════════════════════════════════════════════════

// Trend Signal Settings
grpTrend = "══════ TREND SIGNALS ══════"
src = input(hl2, title="Source", group = grpTrend)
Multiplier = input.float(2, title="Sensitivity (0.5 - 5)", step=0.1, minval=0.5, maxval=5, group = grpTrend)
atrPeriods = input.int(14, title="ATR Length", group = grpTrend)
atrCalcMethod = input.string("Method 1", title = "ATR Calculation Methods", options = ["Method 1","Method 2"], group = grpTrend)
cloud_val = input.int(10, title = "Cloud Moving Average Length", minval = 5, maxval = 500, group = grpTrend)

// Trade Zone Settings
grpTrade = "══════ TRADE ZONES ══════"
boxDuration = input.int(10, minval = 1, maxval = 100, title = "Box Duration (Bars)", group = grpTrade, tooltip = "How many bars the TP/SL boxes extend to the right.")
targetColor = input.color(color.green, title = "Target Profit Color", group = grpTrade, tooltip = "Color for all TP boxes (both long and short)")
stopColor = input.color(color.red, title = "Stop Loss Color", group = grpTrade, tooltip = "Color for all SL boxes (both long and short)")
tpOpacity = input.int(90, minval = 0, maxval = 100, title = "Target Profit Opacity", group = grpTrade, tooltip = "Transparency of TP boxes (0=opaque, 100=transparent)")
slOpacity = input.int(90, minval = 0, maxval = 100, title = "Stop Loss Opacity", group = grpTrade, tooltip = "Transparency of SL boxes (0=opaque, 100=transparent)")

// Signal Colors (for labels and shapes)
grpSignalColors = "══════ SIGNAL COLORS ══════"
bullColor = input.color(color.teal, title = "Bullish Signal Color", group = grpSignalColors)
bearColor = input.color(color.red, title = "Bearish Signal Color", group = grpSignalColors)

// Gold Trade Parameters (Fixed for 40 pips SL, 80 pips TP at 2RR)
grpGold = "══════ GOLD TRADE PARAMS ══════"
slPips = input.float(40.0, minval = 1, title = "Stop Loss (Pips)", group = grpGold, tooltip = "Stop loss distance in pips. 1 pip = 0.1 price move.")
tpPips1R = input.float(40.0, minval = 1, title = "TP 1R (Pips)", group = grpGold, tooltip = "First take profit at 1:1")
tpPips2R = input.float(80.0, minval = 1, title = "TP 2R (Pips)", group = grpGold, tooltip = "Second take profit at 2:1 - FIXED 80 PIPS")
tpPips3R = input.float(120.0, minval = 1, title = "TP 3R (Pips)", group = grpGold, tooltip = "Third take profit at 3:1")
pipValue = input.float(0.1, minval = 0.01, step = 0.01, title = "Pip Value", group = grpGold, tooltip = "Price movement per pip. For Gold: 1 pip = 0.1")

// Range Filter Settings
grpRange = "══════ RANGE FILTER ══════"
enableRangeFilter = input.bool(true, title = "Enable Range Filter", group = grpRange, tooltip = "Suppress signals when price is ranging")
showRangeBoxes = input.bool(true, title = "Show Range Boxes", group = grpRange, tooltip = "Display range boxes and lines on chart (logic still works in background)")
rangeLength = input.int(20, 'Minimum Range Length', minval = 2, group = grpRange)
rangeMult = input.float(1., 'Range Width', minval = 0, step = 0.1, group = grpRange)
rangeAtrLen = input.int(500, 'Range ATR Length', minval = 1, group = grpRange)

// Signal Display
grpSignal = "══════ SIGNAL DISPLAY ══════"
showBuySellSignals = input.bool(true, title="Show Buy/Sell Signals", group = grpSignal)
showMovingAverageCloud = input.bool(true, title="Show Cloud MA", group = grpSignal)
labelSize = input.string("Normal", title = "Label Size", options = ["Tiny", "Small", "Normal", "Large"], group = grpSignal)

//═══════════════════════════════════════════════════════════════════════════════
// INTERNAL VARIABLES
//═══════════════════════════════════════════════════════════════════════════════

// Calculate pip distances
var float slDistance = slPips * pipValue
var float tpDistance1R = tpPips1R * pipValue
var float tpDistance2R = tpPips2R * pipValue
var float tpDistance3R = tpPips3R * pipValue

// Label size conversion
var lblSize = switch labelSize
    "Tiny" => size.tiny
    "Small" => size.small
    "Normal" => size.normal
    "Large" => size.large
    => size.normal

// Arrays to store trade zone boxes and labels
var tpBoxes1R = array.new<box>()
var tpBoxes2R = array.new<box>()
var tpBoxes3R = array.new<box>()
var slBoxes = array.new<box>()
var signalLabels = array.new<label>()

//═══════════════════════════════════════════════════════════════════════════════
// RANGE FILTER DETECTION (LuxAlgo Range Detector)
//═══════════════════════════════════════════════════════════════════════════════

// Range drawings
var box rangeBx = na
var line rangeLvl = na

// Range extensions
var float rangeMax = na
var float rangeMin = na

var int rangeOs = 0
color rangeDetectCss = na

n = bar_index
rangeAtr = ta.atr(rangeAtrLen) * rangeMult
rangeMa = ta.sma(close, rangeLength)

// Count how many bars are within range
rangeCount = 0
for i = 0 to rangeLength-1
    rangeCount += math.abs(close[i] - rangeMa) > rangeAtr ? 1 : 0

// Detect and draw ranges
if rangeCount == 0 and rangeCount[1] != rangeCount
    // Test for overlap and change coordinates
    if n[rangeLength] <= rangeBx.get_right()
        rangeMax := math.max(rangeMa + rangeAtr, rangeBx.get_top())
        rangeMin := math.min(rangeMa - rangeAtr, rangeBx.get_bottom())
        
        if showRangeBoxes
            // Box new coordinates
            rangeBx.set_top(rangeMax)
            rangeBx.set_rightbottom(n, rangeMin)
            rangeBx.set_bgcolor(color.new(color.blue, 80))

            // Line new coordinates
            rangeAvg = math.avg(rangeMax, rangeMin)
            rangeLvl.set_y1(rangeAvg)
            rangeLvl.set_xy2(n, rangeAvg)
            rangeLvl.set_color(color.blue)

        rangeDetectCss := showRangeBoxes ? color.new(color.gray, 80) : na
        rangeOs := 0
    else
        rangeMax := rangeMa + rangeAtr
        rangeMin := rangeMa - rangeAtr

        if showRangeBoxes
            // Set new box and level
            rangeBx := box.new(n[rangeLength], rangeMa + rangeAtr, n, rangeMa - rangeAtr, na
              , bgcolor = color.new(color.blue, 80))
            
            rangeLvl := line.new(n[rangeLength], rangeMa, n, rangeMa
              , color = color.blue
              , style = line.style_dotted)

        rangeDetectCss := showRangeBoxes ? color.new(color.gray, 80) : na
        rangeOs := 0

else if rangeCount == 0
    if showRangeBoxes
        rangeBx.set_right(n)
        rangeLvl.set_x2(n)

// Set color based on breakout (only if box exists)
if not na(rangeMax) and not na(rangeMin)
    if close > rangeMax
        if showRangeBoxes and not na(rangeBx)
            rangeBx.set_bgcolor(color.new(color.green, 80))
            rangeLvl.set_color(color.green)
        rangeOs := 1
    else if close < rangeMin
        if showRangeBoxes and not na(rangeBx)
            rangeBx.set_bgcolor(color.new(color.red, 80))
            rangeLvl.set_color(color.red)
        rangeOs := -1
    else
        // Price is inside the range
        if rangeCount == 0
            rangeOs := 0

// Check if currently in range for signal filtering
bool isInRangeNow = enableRangeFilter and rangeOs == 0 and not na(rangeMax) and not na(rangeMin) and close <= rangeMax and close >= rangeMin

//═══════════════════════════════════════════════════════════════════════════════
// TREND SIGNAL LOGIC (Original UAlgo)
//═══════════════════════════════════════════════════════════════════════════════

percent(nom, div) =>
    100 * nom / div

src1 = ta.hma(open, 5)[1] 
src2 = ta.hma(close, 12)
momm1 = ta.change(src1)
momm2 = ta.change(src2)
f1(m, n) => m >= n ? m : 0.0
f2(m, n) => m >= n ? 0.0 : -m
m1 = f1(momm1, momm2)
m2 = f2(momm1, momm2)
sm1 = math.sum(m1, 1)
sm2 = math.sum(m2, 1)

cmoCalc = percent(sm1-sm2, sm1+sm2)
 
hh = ta.highest(2)
h1 = ta.dev(hh, 2) > 0 ? na : hh
hpivot = fixnan(h1)
ll = ta.lowest(2)
l1 = ta.dev(ll, 2) > 0 ? na : ll
lpivot = fixnan(l1)
 
rsiCalc = ta.rsi(close, 9)
lowPivot = lpivot  
highPivot = hpivot
 
sup = rsiCalc < 25 and cmoCalc > 50 and lowPivot
res = rsiCalc > 75 and cmoCalc < -50 and highPivot

atr2 = ta.sma(ta.tr, atrPeriods)
atr = atrCalcMethod == "Method 1" ? ta.atr(atrPeriods) : atr2
up = src - (Multiplier * atr)
up1 = nz(up[1], up)
up := close[1] > up1 ? math.max(up, up1) : up
dn = src + (Multiplier * atr)
dn1 = nz(dn[1], dn)
dn := close[1] < dn1 ? math.min(dn, dn1) : dn
 
trend = 1
trend := nz(trend[1], trend)
trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend
buySignal = trend == 1 and trend[1] == -1
sellSignal = trend == -1 and trend[1] == 1
 
pos = 0.0
pos := buySignal ? 1 : sellSignal ? -1 : pos[1]

// Apply range filter to signals
var bool longCond = false
var bool shortCond = false

if barstate.isconfirmed
    longCond := buySignal and pos[1] != 1 and not isInRangeNow
    shortCond := sellSignal and pos[1] != -1 and not isInRangeNow
else
    longCond := false
    shortCond := false

//═══════════════════════════════════════════════════════════════════════════════
// DRAW TRADE ZONES (FIOME Style Boxes)
//═══════════════════════════════════════════════════════════════════════════════

drawTradeZone(bool isBull, float entryPrice) =>
    // Calculate TP and SL prices
    float slPrice = isBull ? entryPrice - slDistance : entryPrice + slDistance
    float tpPrice1R = isBull ? entryPrice + tpDistance1R : entryPrice - tpDistance1R
    float tpPrice2R = isBull ? entryPrice + tpDistance2R : entryPrice - tpDistance2R
    float tpPrice3R = isBull ? entryPrice + tpDistance3R : entryPrice - tpDistance3R
    
    // Box coordinates
    int leftBar = bar_index
    int rightBar = bar_index + boxDuration
    
    // Colors with user-defined transparency - unified for all trades
    color tpColor = color.new(targetColor, tpOpacity)
    color slColor = color.new(stopColor, slOpacity)
    color borderTpColor = color.new(targetColor, math.max(tpOpacity - 40, 0))
    color borderSlColor = color.new(stopColor, math.max(slOpacity - 40, 0))
    
    // Draw TP Zones (Entry to each TP level)
    box tpBox1R = box.new(leftBar, entryPrice, rightBar, tpPrice1R, 
         border_color = borderTpColor, 
         border_width = 1, 
         bgcolor = tpColor,
         text = "TP1 (1R): " + str.tostring(tpPrice1R, format.mintick),
         text_color = targetColor,
         text_size = size.tiny,
         text_halign = text.align_right,
         text_valign = isBull ? text.align_top : text.align_bottom)
    
    box tpBox2R = box.new(leftBar, tpPrice1R, rightBar, tpPrice2R, 
         border_color = borderTpColor, 
         border_width = 1, 
         bgcolor = color.new(targetColor, math.min(tpOpacity + 10, 100)),
         text = "TP2 (2R): " + str.tostring(tpPrice2R, format.mintick) + " [80 pips]",
         text_color = targetColor,
         text_size = size.tiny,
         text_halign = text.align_right,
         text_valign = isBull ? text.align_top : text.align_bottom)
    
    box tpBox3R = box.new(leftBar, tpPrice2R, rightBar, tpPrice3R, 
         border_color = borderTpColor, 
         border_width = 1, 
         bgcolor = color.new(targetColor, math.min(tpOpacity + 20, 100)),
         text = "TP3 (3R): " + str.tostring(tpPrice3R, format.mintick),
         text_color = targetColor,
         text_size = size.tiny,
         text_halign = text.align_right,
         text_valign = isBull ? text.align_top : text.align_bottom)
    
    // Draw SL Zone (Entry to SL)
    box slBox = box.new(leftBar, entryPrice, rightBar, slPrice, 
         border_color = borderSlColor, 
         border_width = 2, 
         bgcolor = slColor,
         text = "SL: " + str.tostring(slPrice, format.mintick),
         text_color = stopColor,
         text_size = size.tiny,
         text_halign = text.align_right,
         text_valign = isBull ? text.align_bottom : text.align_top)
    
    // Store boxes
    array.push(tpBoxes1R, tpBox1R)
    array.push(tpBoxes2R, tpBox2R)
    array.push(tpBoxes3R, tpBox3R)
    array.push(slBoxes, slBox)
    
    // Draw BUY/SELL Label
    if showBuySellSignals
        string labelText = isBull ? "BUY" : "SELL"
        color labelColor = isBull ? bullColor : bearColor
        labelYloc = isBull ? yloc.belowbar : yloc.abovebar
        labelStyle = isBull ? label.style_label_up : label.style_label_down
        signalLabel = label.new(bar_index, isBull ? low : high, labelText, xloc.bar_index, labelYloc, labelColor, labelStyle, color.white, lblSize)
        array.push(signalLabels, signalLabel)

// Draw trade zones for signals
if longCond
    drawTradeZone(true, close)

if shortCond
    drawTradeZone(false, close)

//═══════════════════════════════════════════════════════════════════════════════
// BOX MANAGEMENT (Similar to FIOME)
//═══════════════════════════════════════════════════════════════════════════════

var int maxBoxCapacity = 165  // 165 trades = 495 boxes (4 boxes per trade: 3 TP + 1 SL)

if array.size(tpBoxes1R) > maxBoxCapacity
    box.delete(array.shift(tpBoxes1R))
    box.delete(array.shift(tpBoxes2R))
    box.delete(array.shift(tpBoxes3R))
    box.delete(array.shift(slBoxes))

if array.size(signalLabels) > maxBoxCapacity
    label.delete(array.shift(signalLabels))

//═══════════════════════════════════════════════════════════════════════════════
// CLOUD AND VISUAL INDICATORS
//═══════════════════════════════════════════════════════════════════════════════

changeCond = trend != trend[1]
smaSrcHigh = ta.ema(high, cloud_val)
smaSrcLow = ta.ema(low, cloud_val)
[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)
plot_high = plot(showMovingAverageCloud ? smaSrcHigh : na, color = na, editable = false)
plot_low = plot(showMovingAverageCloud ? smaSrcLow : na, color = na, editable = false)

plotshape(longCond ? up : na, title="UpTrend Begins", location=location.belowbar, style=shape.circle, size=size.tiny, color=color.new(color.teal, 50))
plotshape(shortCond ? dn : na, title="DownTrend Begins", location=location.abovebar, style=shape.circle, size=size.tiny, color=color.new(color.red, 50))

fill(plot_high, plot_low, color = ((macdLine > 0) and (macdLine[0] > macdLine[1])) ? color.new(color.aqua, 85) : na, title = "Positive Cloud Uptrend")
fill(plot_high, plot_low, color = (macdLine > 0 and macdLine[0] < macdLine[1]) ? color.new(color.aqua, 85) : na, title = "Positive Cloud Downtrend")
fill(plot_high, plot_low, color = (macdLine < 0 and macdLine[0] < macdLine[1]) ? color.new(color.red, 85) : na, title = "Negative Cloud Uptrend")
fill(plot_high, plot_low, color = (macdLine < 0 and macdLine[0] > macdLine[1]) ? color.new(color.red, 85) : na, title = "Negative Cloud Downtrend")

// Range detection background
bgcolor(rangeDetectCss, title = "Range Detection")

//═══════════════════════════════════════════════════════════════════════════════
// INFO TABLE
//═══════════════════════════════════════════════════════════════════════════════

var table infoTable = table.new(position.top_right, 2, 8, bgcolor = color.new(color.black, 80), border_width = 1)

if barstate.islast
    table.cell(infoTable, 0, 0, "MASTER", text_color = color.white, text_size = size.small)
    table.cell(infoTable, 1, 0, "Settings", text_color = color.gray, text_size = size.tiny)
    
    table.cell(infoTable, 0, 1, "SL Pips:", text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 1, str.tostring(slPips), text_color = color.white, text_size = size.tiny)
    
    table.cell(infoTable, 0, 2, "TP1 Pips:", text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 2, str.tostring(tpPips1R), text_color = color.white, text_size = size.tiny)
    
    table.cell(infoTable, 0, 3, "TP2 Pips:", text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 3, str.tostring(tpPips2R), text_color = color.white, text_size = size.tiny)
    
    table.cell(infoTable, 0, 4, "TP3 Pips:", text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 4, str.tostring(tpPips3R), text_color = color.white, text_size = size.tiny)
    
    table.cell(infoTable, 0, 5, "Pip Value:", text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 5, str.tostring(pipValue), text_color = color.white, text_size = size.tiny)
    
    table.cell(infoTable, 0, 6, "Box Bars:", text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 6, str.tostring(boxDuration), text_color = color.white, text_size = size.tiny)
    
    table.cell(infoTable, 0, 7, "Range Filter:", text_color = color.gray, text_size = size.tiny)
    table.cell(infoTable, 1, 7, enableRangeFilter ? (isInRangeNow ? "RANGING" : "TRENDING") : "OFF", 
         text_color = isInRangeNow ? color.orange : color.green, text_size = size.tiny)

//═══════════════════════════════════════════════════════════════════════════════
// ALERTS
//═══════════════════════════════════════════════════════════════════════════════

alertcondition(changeCond, title="Trend Direction Change", message="Trend direction has changed!")

entryOfLongPosition = ta.valuewhen(longCond, close, 0)
entryOfShortPosition = ta.valuewhen(shortCond, close, 0)

takeProfitForLong1R = entryOfLongPosition + tpDistance1R
takeProfitForLong2R = entryOfLongPosition + tpDistance2R
takeProfitForLong3R = entryOfLongPosition + tpDistance3R
stopLossForLong = entryOfLongPosition - slDistance

takeProfitForShort1R = entryOfShortPosition - tpDistance1R
takeProfitForShort2R = entryOfShortPosition - tpDistance2R
takeProfitForShort3R = entryOfShortPosition - tpDistance3R
stopLossForShort = entryOfShortPosition + slDistance

alertLongText = str.tostring(syminfo.ticker) + " BUY ALERT! " +
                  "Entry Price: " + str.tostring(entryOfLongPosition) +
                  ", Take Profit 1: " + str.tostring(takeProfitForLong1R) + 
                  ", Take Profit 2: " + str.tostring(takeProfitForLong2R) + " (80 pips)" +
                  ", Take Profit 3: " + str.tostring(takeProfitForLong3R) + 
                  ", Stop Loss Price: " + str.tostring(stopLossForLong)

alertShortText = str.tostring(syminfo.ticker) + " SELL ALERT!" +
                  ", Entry Price: " + str.tostring(entryOfShortPosition) +
                  ", Take Profit 1: " + str.tostring(takeProfitForShort1R) + 
                  ", Take Profit 2: " + str.tostring(takeProfitForShort2R) + " (80 pips)" +
                  ", Take Profit 3: " + str.tostring(takeProfitForShort3R) +
                  ", Stop Loss Price: " + str.tostring(stopLossForShort)

longJson = '{"content": "' + alertLongText + '"}'
shortJson = '{"content": "' + alertShortText + '"}'

if longCond
    alert(longJson, alert.freq_once_per_bar_close)

if shortCond
    alert(shortJson, alert.freq_once_per_bar_close)

alertcondition(longCond, "MASTER BUY Signal", "MASTER: BUY Signal on {{ticker}} at {{close}}")
alertcondition(shortCond, "MASTER SELL Signal", "MASTER: SELL Signal on {{ticker}} at {{close}}")
alertcondition(longCond or shortCond, "MASTER Any Signal", "MASTER: {{ticker}} Signal at {{close}}")
