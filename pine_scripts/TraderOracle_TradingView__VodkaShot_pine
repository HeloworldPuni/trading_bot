//@version=5

indicator(title="Vodka Shot", overlay=true)

// Inspired by this video: https://www.youtube.com/watch?v=G4knq5vdy5g

var isLong = false
var isShort = false

// ===================================  NEGLECTED VOL by DGT  ======================================--

nzVolume = nz(volume)
source   = barstate.isconfirmed ? close : close[1]
vsource  = nzVolume ? barstate.isconfirmed ? ta.obv : ta.obv[1] : na
corr     = ta.correlation(source, vsource, 14)
volAvgS  = ta.sma(nzVolume, 14)
volAvgL  = ta.sma(nzVolume, 14 * 5)
volDev   = (volAvgL + 1.618034 * ta.stdev(volAvgL, 14 * 5)) / volAvgL * 11 / 100
volRel   = nzVolume / volAvgL
momentum = ta.change(vsource, 14) / 14
momOsc   = ta.linreg(momentum / volAvgS * 1.618034, 5, 0)

vbcbColor = if close < open
    if nzVolume > volAvgS * 1.618034
        #910000
    else if nzVolume >= volAvgS * .618034 and nzVolume <= volAvgS * 1.618034
        color.red
    else
        color.orange
else
    if nzVolume > volAvgS * 1.618034
        #006400
    else if nzVolume >= volAvgS * .618034 and nzVolume <= volAvgS * 1.618034
        color.green
    else
        #7FFFD4

bColor = color.new(color.black, 25)
gColor = color.new(color.gray, 50)

// ===================================  RedK Dual VADER with Energy Bars [VADER-DEB]  ======================================--

f_derma(_data, _len, MAOption) =>
    value = 
      MAOption == 'SMA' ? ta.sma(_data, _len) :
      MAOption == 'EMA' ? ta.ema(_data, _len) :
      ta.wma(_data, _len)

rlength  = input.int(12, minval=1)
DER_avg = input.int(5, 'Average', minval=1, inline='DER', group='Directional Energy Ratio')
MA_Type = input.string('WMA', 'DER MA type', options=['WMA', 'EMA', 'SMA'], inline='DER', group='Directional Energy Ratio') 
rsmooth  = input.int(3, 'Smooth', minval=1,  inline='DER_1', group='Directional Energy Ratio')

show_senti = input.bool(true, 'Sentiment',  inline='DER_s', group='Directional Energy Ratio')
senti   = input.int(20, 'Length', minval=1, inline='DER_s', group='Directional Energy Ratio')

v_calc  = input.string('Relative', 'Calculation', options=['Relative', 'Full', 'None'], group='Volume Parameters')
vlookbk = input.int(20, 'Lookback (for Relative)', minval=1,                            group='Volume Parameters')

v = volume

vola    = 
  v_calc == 'None' or na(volume) ? 1 : 
  v_calc == 'Relative' ?   ta.stoch(v, v, v, vlookbk) / 100 : 
  v

R       = (ta.highest(2) - ta.lowest(2)) / 2                    // R is the 2-bar average bar range - this method accomodates bar gaps
sr      = ta.change(close) / R                                  // calc ratio of change to R
rsr     = math.max(math.min(sr, 1), -1)                         // ensure ratio is restricted to +1/-1 in case of big moves
c       = fixnan(rsr * vola)                                    

c_plus  = math.max(c, 0)                                        // calc directional vol-accel energy
c_minus = -math.min(c, 0)

avg_vola    = f_derma(vola, rlength, MA_Type)
dem         = f_derma(c_plus, rlength, MA_Type)  / avg_vola          // directional energy ratio
sup         = f_derma(c_minus, rlength, MA_Type) / avg_vola

adp         = 100 * ta.wma(nz(dem), DER_avg)                        // average DER
asp         = 100 * ta.wma(nz(sup), DER_avg)
anp         = adp - asp                                             // net DER..
anp_s       = ta.wma(anp, rsmooth)

s_adp       = 100 * ta.wma(nz(dem), senti)                            // average DER for sentiment length
s_asp       = 100 * ta.wma(nz(sup), senti)
V_senti     = ta.wma(s_adp - s_asp, rsmooth)

c_adp   = color.new(#11ff20, 30)
c_asp   = color.new(#ff1111, 30)
c_fd    = color.new(color.green, 80)
c_fs    = color.new(color.red, 80)
c_zero  = color.new(#ffee00, 70)

c_up    = color.new(#11ff20, 0)
c_dn    = color.new(#ff1111, 0)

up      = anp_s >= 0
s_up    = V_senti >= 0 

c_grow_above = #1b5e2080 
c_grow_below = #dc4c4a80
c_fall_above = #66bb6a80  
c_fall_below = #ef8e9880     

sflag_up = math.abs(V_senti) >= math.abs(V_senti[1])

bo = fixnan(asp)
bc = fixnan(adp)
bh = math.max(bo, bc)
bl = math.min(bo, bc)

rising      = ta.change(bc) > 0

c_barup     = #11ff2088
c_bardn     = #ff111188
c_bardj     = #ffffff88

barcolor    = bc > bo and rising ? c_barup : bc < bo and not rising ? c_bardn : c_bardj

// ===================================  RedK Slow_Smooth WMA, RSS_WMA v3 ======================================--

f_LazyLine(_data, _length) =>
    w1 = 0, w2 = 0, w3 = 0
    L1 = 0.0, L2 = 0.0, L3 = 0.0
    w = _length / 3
    
    if _length > 2 
        w2 := math.round(w)
        w1 := math.round((_length-w2)/2)
        w3 :=   int((_length-w2)/2)
        
        L1 := ta.wma(_data, w1)
        L2 := ta.wma(L1, w2)
        L3 := ta.wma(L2, w3)
    else
        L3 := _data
    L3

LL = f_LazyLine(close, 21)

lc_up        = color.new(#33ff00, 0)
lc_dn        = color.new(#ff1111, 0)
luptrend     = LL > LL[1]
SigMulti    = 1.0

SignalOn    = barstate.isconfirmed 
SwingDn     = luptrend[1] and not(luptrend) and barstate.isconfirmed 
SwingUp     = luptrend and not(luptrend[1]) and barstate.isconfirmed 

dl = SigMulti / 100 * LL  

upwards = LL > LL[1] and (barcolor == c_barup) and up and (open < close and volRel * .145898 > volDev) and not isLong
downwards = LL < LL[1]  and (barcolor == c_bardn) and (open > close and volRel * .145898 > volDev) and not isShort

showUp = upwards and not upwards[1] and not upwards[2] and not upwards[3] and not upwards[4] 
showDown = downwards and not downwards[1] and not upwards[2] and not upwards[3] and not upwards[4] 

plotshape(showUp ? 1 : na, title="V", text="V", location=location.belowbar, style=shape.labelup, size=size.tiny, color=color.green, textcolor=color.white)
plotshape(showDown ? 1 : na, title="V", text="V", location=location.abovebar, style=shape.labeldown, size=size.tiny, color=color.red, textcolor=color.white)

alertcondition(showUp, title='Vodka BUY', message='Vodka BUY')
alertcondition(showDown, title='Vodka SELL', message='Vodka SELL')

if showUp
    isLong := true
    isShort := false

if showDown
    isLong := false
    isShort := true
