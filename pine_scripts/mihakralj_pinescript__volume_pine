// The MIT License (MIT)
// Â© mihakralj
//@version=6

//@library Volume
//@description Library of 26 volume-based technical indicators for analyzing trading volume patterns and money flow
library("volume")

//@function Calculates the Accumulation/Distribution Line (ADL), a volume-based indicator that measures money flow
//@param src_high The high price
//@param src_low The low price
//@param src_close The close price
//@param src_vol The volume
//@returns The cumulative ADL value
export adl(series float src_high = high, series float src_low = low, series float src_close = close, series float src_vol = volume) =>
    float mfm = 0.0
    if not na(src_high) and not na(src_low) and not na(src_close)
        mfm := (src_close - src_low) - (src_high - src_close)
        mfm := src_high != src_low ? mfm / (src_high - src_low) : 0.0
    float mfv = na(src_vol) ? 0.0 : src_vol * mfm
    var float cumulativeSum = 0.0
    cumulativeSum := na(mfv) ? cumulativeSum : cumulativeSum + mfv
    cumulativeSum

//@function Calculates the Chaikin Accumulation/Distribution Oscillator (ADOSC)
//@param shortPeriod Length of the short-term EMA applied to the ADL
//@param longPeriod Length of the long-term EMA applied to the ADL
//@returns The ADOSC value
export adosc(simple int shortPeriod, simple int longPeriod) =>
    float EPSILON = 1e-10
    if shortPeriod <= 0 or longPeriod <= 0
        runtime.error("Periods must be greater than 0")
    short_alpha = 2.0 / (shortPeriod + 1)
    long_alpha = 2.0 / (longPeriod + 1)
    one_minus_long_alpha = 1.0 - long_alpha
    float rng = high - low
    float mf = rng != 0.0 ? ((2 * close - high - low) / rng) * volume : 0.0
    var float cum = 0.0
    var float e = 1.0
    cum := bar_index == 0 ? mf : cum + mf
    var float short_raw_ema = 0.0
    short_raw_ema := short_alpha * (cum - short_raw_ema) + short_raw_ema
    float short_ema = e > EPSILON ? short_raw_ema / (1.0 - e) : short_raw_ema
    var float long_raw_ema = 0.0
    long_raw_ema := long_alpha * (cum - long_raw_ema) + long_raw_ema
    float long_ema = e > EPSILON ? long_raw_ema / (1.0 - e) : long_raw_ema
    e := one_minus_long_alpha * e
    short_ema - long_ema

//@function Computes Archer On-Balance Volume (AOBV) Fast and Slow
//@param src Price source
//@param vol Volume data
//@returns [AOBV Fast, AOBV Slow]
//@optimized Beta precomputation for EMA warmup compensation
export aobv(series float src, series float vol) =>
    var float prev_src = na
    safe_src = not na(src) ? src : (not na(prev_src) ? prev_src : 0)
    safe_vol = not na(vol) ? vol : 0
    safe_prev = not na(prev_src) ? prev_src : safe_src
    var float obv_val = 0.0
    obv_val := bar_index == 0 ? (safe_src > safe_prev ? safe_vol : safe_src < safe_prev ? -safe_vol : 0) : obv_val + (safe_src > safe_prev ? safe_vol : safe_src < safe_prev ? -safe_vol : 0)
    if not na(src)
        prev_src := src
    periods = array.from(4, 14)
    var emaArr = array.new_float(2, na)
    var eArr = array.new_float(2, 1.0)
    var warmupArr = array.new_bool(2, true)
    var betaArr = array.new_float(2, 0.0)
    resArr = array.new_float(2, na)
    for i = 0 to array.size(periods) - 1
        period = array.get(periods, i)
        alpha = 2.0 / math.max(period, 1)
        beta = array.get(betaArr, i)
        if beta == 0.0
            beta := 1.0 - alpha
            array.set(betaArr, i, beta)
        ema_val = array.get(emaArr, i)
        if na(ema_val)
            ema_val := 0.0
            array.set(emaArr, i, ema_val)
            array.set(resArr, i, obv_val)
        else
            ema_val := alpha * (obv_val - ema_val) + ema_val
            array.set(emaArr, i, ema_val)
            if array.get(warmupArr, i)
                new_e = array.get(eArr, i) * beta
                array.set(eArr, i, new_e)
                c = 1.0 / (1.0 - new_e)
                array.set(resArr, i, c * ema_val)
                if new_e <= 1e-10
                    array.set(warmupArr, i, false)
            else
                array.set(resArr, i, ema_val)
    [array.get(resArr, 0), array.get(resArr, 1)]

//@function Calculates the Chaikin Money Flow (CMF)
//@param len Lookback period length
//@param src_high The high price
//@param src_low The low price
//@param src_close The close price
//@param src_vol The volume
//@returns CMF value between -1 and 1
export cmf(simple int len = 20, series float src_high = high, series float src_low = low, series float src_close = close, series float src_vol = volume) =>
    if len < 1
        runtime.error("Length must be >= 1")
    float mfm = 0.0
    if not na(src_high) and not na(src_low) and not na(src_close)
        mfm := (src_close - src_low) - (src_high - src_close)
        mfm := src_high != src_low ? mfm / (src_high - src_low) : 0.0
    float mfv = na(src_vol) ? 0.0 : mfm * src_vol
    var float sum_mfv = 0.0
    var float sum_vol = 0.0
    sum_mfv := sum_mfv + mfv - (bar_index >= len ? mfv[len] : 0)
    sum_vol := sum_vol + src_vol - (bar_index >= len ? src_vol[len] : 0)
    float cmf_value = sum_vol != 0 ? sum_mfv / sum_vol : 0.0
    cmf_value

//@function Calculates Elder's Force Index (EFI)
//@param len Lookback period for EMA smoothing
//@param src Source price
//@param src_vol Volume
//@returns The smoothed Force Index value
//@optimized Beta precomputation for EMA warmup compensation
export efi(simple int len = 13, series float src = close, series float src_vol = volume) =>
    if len < 1
        runtime.error("Length must be >= 1")
    var float prev_src = src
    float raw_force = (nz(src) - nz(prev_src)) * nz(src_vol)
    prev_src := src
    float a = 2.0 / (len + 1.0)
    float beta = 1.0 - a
    var float ema = na
    var float result = na
    var float e = 1.0
    var bool warmup = true
    if na(ema)
        ema := 0
        result := raw_force
    else
        ema := a * (raw_force - ema) + ema
        if warmup
            e *= beta
            float c = 1.0 / (1.0 - e)
            result := c * ema
            if e <= 1e-10
                warmup := false
        else
            result := ema
    result

//@function Calculate Ease of Movement Volume
//@param i_smoothing Smoothing length for EOM
//@param i_vol_scale Volume scale factor
//@param i_high High price
//@param i_low Low price
//@param i_volume Volume
//@returns Ease of Movement value
export eom(simple int i_smoothing, simple int i_vol_scale, series float i_high=high, series float i_low=low, series float i_volume=volume) =>
    if i_smoothing < 1 or i_vol_scale <= 0
        runtime.error("Smoothing or Volume scale out or range")
    var float oldMidPoint = na
    midPoint = (i_high + i_low) * 0.5
    midPointChange = midPoint - nz(oldMidPoint, midPoint)
    oldMidPoint := midPoint
    priceRange = i_high - i_low
    boxRatio = priceRange > 0 and i_volume > 0 ? (i_volume / i_vol_scale) / priceRange : na
    rawEom = not na(boxRatio) and boxRatio != 0 ? midPointChange / boxRatio : 0.0
    var array<float> buffer = array.new_float(i_smoothing, 0.0)
    var int head = 0
    var float sum = 0.0
    float oldest = array.get(buffer, head)
    if bar_index >= i_smoothing
        sum -= oldest
    currentValue = nz(rawEom)
    sum += currentValue
    array.set(buffer, head, currentValue)
    head := (head + 1) % i_smoothing
    average = bar_index < i_smoothing ? sum / (bar_index + 1) : sum / i_smoothing
    average

//@function Calculates Intraday Intensity Index
//@param period Smoothing period
//@param cumulative Whether to accumulate
//@param h High price
//@param l Low price
//@param c Close price
//@param vol Volume
//@returns Smoothed or raw intensity value
export iii(simple int period, simple bool cumulative=false, series float h=high, series float l=low, series float c=close, series float vol=volume) =>
    high_val = nz(h, close)
    low_val = nz(l, close)
    close_val = nz(c, close)
    volume_val = math.max(nz(vol, 0.0), 1.0)
    range_val = high_val - low_val
    position_multiplier = range_val > 0 ? (2 * close_val - high_val - low_val) / range_val : 0.0
    raw_iii = position_multiplier * volume_val
    var buffer = array.new_float(period, na)
    var head = 0, var sum = 0.0, var valid_count = 0, var cumulative_value = 0.0
    oldest = array.get(buffer, head)
    sum := not na(oldest) ? sum - oldest : sum
    valid_count := not na(oldest) ? valid_count - 1 : valid_count
    sum := not na(raw_iii) ? sum + raw_iii : sum
    valid_count := not na(raw_iii) ? valid_count + 1 : valid_count
    array.set(buffer, head, raw_iii)
    head := (head + 1) % period
    smoothed_iii = sum / period
    cumulative_value := cumulative_value + raw_iii
    cumulative ? cumulative_value : smoothed_iii

//@function Calculates Klinger Volume Oscillator
//@param fast_len Fast EMA period
//@param slow_len Slow EMA period
//@param signal_len Signal line period
//@param src_open Open price
//@param src_high High price
//@param src_low Low price
//@param src_close Close price
//@param src_vol Volume
//@returns [KVO line, Signal line]
export kvo(simple int fast_len = 34, simple int slow_len = 55, simple int signal_len = 13, series float src_open = open, series float src_high = high, series float src_low = low, series float src_close = close, series float src_vol = volume) =>
    float hlc3 = (src_high + src_low + src_close) / 3.0
    float hlc3_prev = nz(hlc3[1], hlc3)
    var float trend = 1.0
    trend := hlc3 > hlc3_prev ? 1.0 : hlc3 < hlc3_prev ? -1.0 : trend
    float high_low_range = src_high - src_low
    float cm = high_low_range > 0 ? math.abs(2 * ((high_low_range - (src_close - src_low)) / high_low_range) - 1) : 0.0
    float dm = trend * nz(src_vol, 0.0) * cm
    float alpha_f = 2.0 / (fast_len + 1), float alpha_s = 2.0 / (slow_len + 1), float alpha_sig = 2.0 / (signal_len + 1)
    var bool warmup = true, var float e_f = 1.0, var float e_s = 1.0, var float e_sig = 1.0
    var float ema_val_f = 0.0, var float ema_val_s = 0.0, var float ema_val_sig = 0.0
    var float fast_ema = dm, var float slow_ema = dm
    ema_val_f := alpha_f * (dm - ema_val_f) + ema_val_f
    ema_val_s := alpha_s * (dm - ema_val_s) + ema_val_s
    if warmup
        e_f *= (1.0 - alpha_f), e_s *= (1.0 - alpha_s)
        float c_f = 1.0 / (1.0 - e_f), float c_s = 1.0 / (1.0 - e_s)
        fast_ema := c_f * ema_val_f, slow_ema := c_s * ema_val_s
        warmup := e_sig > 1e-10
    else
        fast_ema := ema_val_f, slow_ema := ema_val_s
    float kvo_line = fast_ema - slow_ema
    var float signal_line = kvo_line
    ema_val_sig := alpha_sig * (kvo_line - ema_val_sig) + ema_val_sig
    if warmup
        e_sig *= (1.0 - alpha_sig)
        float c_sig = 1.0 / (1.0 - e_sig)
        signal_line := c_sig * ema_val_sig
    else
        signal_line := ema_val_sig
    [kvo_line, signal_line]

//@function Calculates Money Flow Index
//@param len Period for MFI calculation
//@param src_high High price
//@param src_low Low price
//@param src_close Close price
//@param src_vol Volume
//@returns The MFI value (0-100)
export mfi(simple int len, series float src_high=high, series float src_low=low, series float src_close=close, series float src_vol=volume) =>
    if len < 1
        runtime.error("Invalid parameter: len must be >= 1")
    float typical_price = (src_high + src_low + src_close) / 3.0
    float raw_money_flow = typical_price * nz(src_vol, 0.0)
    float prev_typical_price = nz(typical_price[1], typical_price)
    bool is_positive = typical_price > prev_typical_price
    bool is_negative = typical_price < prev_typical_price
    float positive_money_flow = is_positive ? raw_money_flow : 0.0
    float negative_money_flow = is_negative ? raw_money_flow : 0.0
    var array<float> pos_buffer = array.new_float(len, na)
    var array<float> neg_buffer = array.new_float(len, na)
    var int head = 0
    var float sum_positive_mf = 0.0
    var float sum_negative_mf = 0.0
    var int count = 0
    float pos_oldest = array.get(pos_buffer, head)
    float neg_oldest = array.get(neg_buffer, head)
    if not na(pos_oldest)
        sum_positive_mf -= pos_oldest
        sum_negative_mf -= neg_oldest
    else
        count += 1
    sum_positive_mf += positive_money_flow
    sum_negative_mf += negative_money_flow
    array.set(pos_buffer, head, positive_money_flow)
    array.set(neg_buffer, head, negative_money_flow)
    head := (head + 1) % len
    float money_flow_ratio = sum_negative_mf != 0 ? sum_positive_mf / sum_negative_mf : 0.0
    float mfi_value = 100.0 - (100.0 / (1.0 + money_flow_ratio))
    mfi_value

//@function Calculates Negative Volume Index
//@param src Price series
//@param vol Volume series
//@param start_value Starting value for NVI
//@returns The NVI value
export nvi(series float src, series float vol = volume, simple float start_value = 100.0) =>
    var float nvi_value = start_value
    if not (na(src) or na(vol) or na(src[1]) or na(vol[1]) or src[1] == 0.0 or vol[1] <= 0.0) and vol < vol[1]
        nvi_value := nvi_value * src / src[1]
    nvi_value

//@function Calculates On Balance Volume
//@param c Close price
//@param vol Volume
//@returns Cumulative OBV value
export obv(series float c = close, series float vol = volume) =>
    float close_price = nz(c, close)
    float volume_val = nz(vol, 0.0)
    float prev_close = nz(close_price[1], close_price)
    var float obv_cumulative = 0.0
    obv_cumulative += close_price > prev_close ? volume_val : close_price < prev_close ? -volume_val : 0.0
    obv_cumulative

//@function Calculates Price Volume Divergence
//@param price_period Lookback for price momentum
//@param volume_period Lookback for volume momentum
//@param smoothing_period Smoothing period
//@param c Close price
//@param vol Volume
//@returns Smoothed divergence value
export pvd(simple int price_period, simple int volume_period, simple int smoothing_period, series float c=close, series float vol=volume ) =>
    if smoothing_period <= 0
        runtime.error("Smoothing period must be greater than 0")
    float close_price = nz(c, close)
    float volume_val = math.max(nz(vol, 0.0), 1.0)
    float prev_close = bar_index < price_period ? close_price[math.max(bar_index, 1)] : close_price[price_period]
    float prev_volume = bar_index < volume_period ? volume_val[math.max(bar_index, 1)] : volume_val[volume_period]
    float price_roc = prev_close > 0 ? (close_price - prev_close) / prev_close * 100 : 0.0
    float volume_roc = prev_volume > 0 ? (volume_val - prev_volume) / prev_volume * 100 : 0.0
    int price_momentum = price_roc > 0 ? 1 : price_roc < 0 ? -1 : 0
    int volume_momentum = volume_roc > 0 ? 1 : volume_roc < 0 ? -1 : 0
    float magnitude = math.abs(price_roc) + math.abs(volume_roc)
    float divergence_raw = price_momentum * -volume_momentum * magnitude
    var int p = smoothing_period
    var array<float> buffer = array.new_float(p, na)
    var int head = 0, var float sum = 0.0, var int valid_count = 0
    float oldest = array.get(buffer, head)
    sum := not na(oldest) ? sum - oldest : sum
    valid_count := not na(oldest) ? valid_count - 1 : valid_count
    sum := not na(divergence_raw) ? sum + divergence_raw : sum
    valid_count := not na(divergence_raw) ? valid_count + 1 : valid_count
    array.set(buffer, head, divergence_raw)
    head := (head + 1) % p
    valid_count > 0 ? sum / valid_count : 0.0

//@function Calculates Positive Volume Index
//@param src Price series
//@param vol Volume series
//@param start_value Starting value for PVI
//@returns The PVI value
export pvi(series float src, series float vol = volume, simple float start_value = 100.0) =>
    var float pvi_value = start_value
    if not (na(src) or na(vol) or na(src[1]) or na(vol[1]) or src[1] == 0.0 or vol[1] <= 0.0) and vol > vol[1]
        pvi_value := pvi_value * src / src[1]
    pvi_value

//@function Calculates Percentage Volume Oscillator (PVO)
//@param fast_len Fast EMA period
//@param slow_len Slow EMA period
//@param signal_len Signal line period
//@param vol Volume series
//@returns [PVO line, Signal line]
//@optimized Beta precomputation for EMA warmup compensation
export pvo(simple int fast_len = 12, simple int slow_len = 26, simple int signal_len = 9, series float vol = volume) =>
    if fast_len <= 0 or slow_len <= 0 or signal_len <= 0
        runtime.error("All periods must be positive")
    float volume_val = nz(vol, 0.0)
    float fast_alpha = 2.0 / (fast_len + 1)
    float slow_alpha = 2.0 / (slow_len + 1)
    float signal_alpha = 2.0 / (signal_len + 1)
    float fast_beta = 1.0 - fast_alpha
    float slow_beta = 1.0 - slow_alpha
    float signal_beta = 1.0 - signal_alpha
    var float fast_ema = 0.0
    var float slow_ema = 0.0
    var float signal_ema = 0.0
    var float e_fast = 1.0
    var float e_slow = 1.0
    var float e_signal = 1.0
    var bool warmup = true
    fast_ema := fast_alpha * (volume_val - fast_ema) + fast_ema
    slow_ema := slow_alpha * (volume_val - slow_ema) + slow_ema
    float fast_result = fast_ema
    float slow_result = slow_ema
    if warmup
        e_fast *= fast_beta
        e_slow *= slow_beta
        float c_fast = 1.0 / (1.0 - e_fast)
        float c_slow = 1.0 / (1.0 - e_slow)
        fast_result := c_fast * fast_ema
        slow_result := c_slow * slow_ema
    float pvo_line = slow_result != 0 ? ((fast_result - slow_result) / slow_result) * 100 : 0
    signal_ema := signal_alpha * (pvo_line - signal_ema) + signal_ema
    float signal_result = signal_ema
    if warmup
        e_signal *= signal_beta
        float c_signal = 1.0 / (1.0 - e_signal)
        signal_result := c_signal * signal_ema
        warmup := e_signal > 1e-10
    [pvo_line, signal_result]

//@function Calculates Price Volume Rank
//@param price Price series
//@param vol Volume series
//@returns Price Volume Rank (0-4)
export pvr(series float price, series float vol=volume) =>
    float p = nz(price, close), float v = nz(vol, 0.0)
    float pp = nz(p[1], p), float pv = nz(v[1], v)
    p > pp ? (v > pv ? 1 : 2) : p < pp ? (v < pv ? 3 : 4) : 0

//@function Calculates Price Volume Trend
//@param src Source price
//@param src_vol Volume data
//@returns The cumulative PVT value
export pvt(series float src, series float src_vol) =>
    float price_change = src - nz(src[1], src)
    float price_prev = nz(src[1], src)
    float price_change_ratio = price_prev != 0 ? price_change / price_prev : 0.0
    float volume_adjustment = nz(src_vol, 0.0) * price_change_ratio
    var float cumulative_pvt = 0.0
    cumulative_pvt += volume_adjustment
    cumulative_pvt

//@function Calculates Trade Volume Index
//@param price Price series
//@param min_tick Minimum price movement
//@param vol Volume series
//@returns Trade Volume Index value
export tvi(series float price, simple float min_tick, series float vol=volume) =>
    float p = nz(price, close), float v = nz(vol, 0.0)
    float pp = nz(p[1], p)
    float price_change = p - pp
    var int direction = 1
    var float tvi_sum = 0.0
    direction := price_change > min_tick ? 1 : price_change < -min_tick ? 0 : direction
    tvi_sum += direction == 1 ? v : -v
    tvi_sum

//@function Calculates session-based TWAP (Time Weighted Average Price)
//@param src Source price series
//@param reset_condition Condition to reset TWAP
//@returns TWAP value
export twap(series float src, series bool reset_condition) =>
    var float sum_prices = 0.0
    var int count = 0
    float current_price = nz(src)
    if reset_condition
        sum_prices := 0.0
        count := 0
    sum_prices += current_price
    count += 1
    count > 0 ? sum_prices / count : src

//@function Calculates Volume Accumulation
//@param h High price
//@param l Low price
//@param c Close price
//@param vol Volume
//@returns Cumulative Volume Accumulation value
export va(series float h=high, series float l=low, series float c=close, series float vol=volume) =>
    float high_price = nz(h, close), float low_price = nz(l, close)
    float close_price = nz(c, close), float volume_val = nz(vol, 0.0)
    float midpoint = (high_price + low_price) / 2.0
    float va_period = volume_val * (close_price - midpoint)
    var float va_cumulative = 0.0
    va_cumulative += va_period
    va_cumulative

//@function Calculates Volume Force
//@param len Smoothing period
//@param src Source price
//@param src_vol Volume data
//@returns The Volume Force value
export vf(simple int len, series float src = close, series float src_vol = volume) =>
    float price_change = src - nz(src[1], src)
    float raw_vf = price_change * nz(src_vol, 0.0)
    float alpha = 2.0 / (len + 1)
    var bool warmup = true
    var float e = 1.0
    var float ema_val = 0.0
    var float vf_result = raw_vf
    ema_val := alpha * (raw_vf - ema_val) + ema_val
    if warmup
        e *= (1.0 - alpha)
        float compensator = 1.0 / (1.0 - e)
        vf_result := compensator * ema_val
        warmup := e > 1e-10
    else
        vf_result := ema_val
    vf_result

//@function Calculates Volume Oscillator
//@param short_period Short-term volume MA period
//@param long_period Long-term volume MA period
//@param signal_period Signal line MA period
//@param vol Volume series
//@returns Volume Oscillator value
export vo(simple int short_period, simple int long_period, simple int signal_period, series float vol=volume) =>
    if short_period >= long_period
        runtime.error("Short period must be less than long period")
    volume_val = math.max(nz(vol, 0.0), 1.0)
    var p_short = short_period
    var buffer_short = array.new_float(p_short, na)
    var head_short = 0, var sum_short = 0.0, var valid_count_short = 0
    oldest_short = array.get(buffer_short, head_short)
    sum_short := not na(oldest_short) ? sum_short - oldest_short : sum_short
    valid_count_short := not na(oldest_short) ? valid_count_short - 1 : valid_count_short
    sum_short := not na(volume_val) ? sum_short + volume_val : sum_short
    valid_count_short := not na(volume_val) ? valid_count_short + 1 : valid_count_short
    array.set(buffer_short, head_short, volume_val)
    head_short := (head_short + 1) % p_short
    short_ma = valid_count_short > 0 ? sum_short / valid_count_short : volume_val
    var p_long = long_period
    var buffer_long = array.new_float(p_long, na)
    var head_long = 0, var sum_long = 0.0, var valid_count_long = 0
    oldest_long = array.get(buffer_long, head_long)
    sum_long := not na(oldest_long) ? sum_long - oldest_long : sum_long
    valid_count_long := not na(oldest_long) ? valid_count_long - 1 : valid_count_long
    sum_long := not na(volume_val) ? sum_long + volume_val : sum_long
    valid_count_long := not na(volume_val) ? valid_count_long + 1 : valid_count_long
    array.set(buffer_long, head_long, volume_val)
    head_long := (head_long + 1) % p_long
    long_ma = valid_count_long > 0 ? sum_long / valid_count_long : volume_val
    vo_raw = long_ma != 0 ? ((short_ma - long_ma) / long_ma) * 100 : 0.0
    var p_signal = signal_period
    var buffer_signal = array.new_float(p_signal, na)
    var head_signal = 0, var sum_signal = 0.0, var valid_count_signal = 0
    oldest_signal = array.get(buffer_signal, head_signal)
    sum_signal := not na(oldest_signal) ? sum_signal - oldest_signal : sum_signal
    valid_count_signal := not na(oldest_signal) ? valid_count_signal - 1 : valid_count_signal
    sum_signal := not na(vo_raw) ? sum_signal + vo_raw : sum_signal
    valid_count_signal := not na(vo_raw) ? valid_count_signal + 1 : valid_count_signal
    array.set(buffer_signal, head_signal, vo_raw)
    head_signal := (head_signal + 1) % p_signal
    valid_count_signal > 0 ? sum_signal / valid_count_signal : vo_raw

//@function Calculates Volume Rate of Change
//@param period Number of periods for comparison
//@param calc_type true for percentage, false for point change
//@param vol Volume series
//@returns Volume Rate of Change value
export vroc(simple int period, simple bool calc_type, series float vol = volume) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    float current_volume = vol
    float historical_volume = vol[period]
    if na(current_volume) or na(historical_volume)
        na
    else if calc_type
        historical_volume != 0.0 ? ((current_volume - historical_volume) / historical_volume) * 100.0 : na
    else
        current_volume - historical_volume

//@function Calculates VWAD using volume weighting
//@param period Lookback period for volume weighting
//@param src_high High price
//@param src_low Low price
//@param src_close Close price
//@param src_vol Volume
//@returns VWAD value
export vwad(simple int period, series float src_high = high, series float src_low = low, series float src_close = close, series float src_vol = volume) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    var int p = math.max(1, period), var int head = 0
    var array<float> vol_buffer = array.new_float(p, na)
    var float sum_vol = 0.0
    float old_vol = array.get(vol_buffer, head)
    if not na(old_vol)
        sum_vol -= old_vol
    float current_vol = nz(src_vol, 0.0)
    sum_vol += current_vol
    array.set(vol_buffer, head, current_vol)
    head := (head + 1) % p
    float mfm = 0.0
    if not na(src_high) and not na(src_low) and not na(src_close)
        mfm := (src_close - src_low) - (src_high - src_close)
        mfm := src_high != src_low ? mfm / (src_high - src_low) : 0.0
    float weight = sum_vol > 0.0 ? current_vol / sum_vol : 0.0
    float vwad_value = mfm * weight
    vwad_value

//@function Calculates session-based VWAP (Volume Weighted Average Price)
//@param src Source price series
//@param vol Volume series
//@param reset_condition Condition to reset VWAP
//@returns VWAP value
export vwap(series float src, series float vol, series bool reset_condition) =>
    var float sum_pv = 0.0, var float sum_vol = 0.0
    float current_price = nz(src), float current_vol = nz(vol, 0.0)
    if reset_condition
        sum_pv := current_vol > 0.0 ? current_price * current_vol : 0.0
        sum_vol := current_vol > 0.0 ? current_vol : 0.0
    else
        if current_vol > 0.0
            sum_pv += current_price * current_vol
            sum_vol += current_vol
    sum_vol > 0.0 ? sum_pv / sum_vol : src

//@function Calculates VWMA using circular buffer
//@param src Source price series
//@param vol Volume series
//@param period Lookback period
//@returns VWMA value
export vwma(series float src, series float vol, simple int period) =>
    if period <= 0
        runtime.error("Period must be greater than 0")
    var int p = math.max(1, period), var int head = 0, var int count = 0
    var array<float> price_buffer = array.new_float(p, na)
    var array<float> vol_buffer = array.new_float(p, na)
    var float sum_pv = 0.0, var float sum_vol = 0.0
    float old_price = array.get(price_buffer, head), float old_vol = array.get(vol_buffer, head)
    if not na(old_price) and not na(old_vol)
        sum_pv -= old_price * old_vol
        sum_vol -= old_vol
        count -= 1
    float current_price = nz(src), float current_vol = nz(vol, 0.0)
    if current_vol > 0.0
        sum_pv += current_price * current_vol
        sum_vol += current_vol
        count += 1
    array.set(price_buffer, head, current_price)
    array.set(vol_buffer, head, current_vol)
    head := (head + 1) % p
    sum_vol > 0.0 ? sum_pv / sum_vol : src

//@function Calculates Williams A/D using price relationships and volume
//@param src_open Open price
//@param src_high High price
//@param src_low Low price
//@param src_close Close price
//@param src_vol Volume
//@returns WAD value
export wad(series float src_open=open, series float src_high=high, series float src_low=low, series float src_close=close, series float src_vol=volume) =>
    float close_prev = nz(src_close[1], src_close)
    float true_range_high = math.max(src_high, close_prev)
    float true_range_low = math.min(src_low, close_prev)
    float pm = 0.0
    if not na(src_close) and not na(close_prev)
        if src_close > close_prev
            pm := src_close - true_range_low
        else if src_close < close_prev
            pm := src_close - true_range_high
        else
            pm := 0.0
    float ad_value = pm * nz(src_vol, 0.0)
    var float cumulative_wad = 0.0
    cumulative_wad += ad_value
    cumulative_wad
