//@version=5
// =====================================================================================================================
//
// WTT_HiFreqScalp Â© William Skrzypczak Waverider Trading Technologies
// Revision: v6.8 Beta (Keltner channel color optimization and performance enhancements)
// Performance Optimizations: Reduced table updates, optimized array sizes, conditional calculations, performance mode
// Color Updates: Changed Keltner channel lines to magenta/fuchsia for better visibility
// Next Version: v6.9 Beta
//
// =====================================================================================================================
//
// Version History:
//   v1.0-v1.14 - Initial development: Core signal detection, table display, SMP branding, pattern analysis, and alert tracking
//   v2.0-v2.9 - Performance & filtering: Optimized success tracking (40-60% improvement), added market structure detection, 
//               signal spam filters, volume/candle pattern filters, and visual enhancements
//   v3.0-v3.9 - Projection system: Added comprehensive price projection with target/stop loss lines, real-time success tracking,
//               and major performance optimizations (60-80% improvement)
//   v4.0-v4.2 - Code simplification: Removed projection visuals, enhanced bounce detection with EMA invalidation logic,
//               streamlined codebase for cleaner performance
//   v4.3-v4.4Beta - UI improvements and Keltner Channel integration with dynamic volatility adjustment and breakout detection
//   v5.0-v5.9 Beta - Enhanced signal tracking, performance tables, ranking systems, and visual enhancements with comprehensive optimization
//   v6.0-v6.6.3 Beta - Production-ready features: Three Bar Stop Strategy table,Keltner Breakout integration, optimized ranking system,
//                      and final UI refinements for professional trading use

//
// =====================================================================================================================
//
// This Pine Script code implements a high-frequency scalp trading indicator for TradingView called "WTT_HiFreqScalp." -
// It calculates multiple Exponential Moving Averages (EMAs) with configurable lengths to identify trend direction and -
// potential trade signals. The script generates long and short signals based on crossovers between a "Super Fast" EMA -
// and a "Middle" EMA (the average of fast and slow EMAs), and visually marks these signals on the chart with shapes ---
// and colored lines. It also computes the Relative Strength Index (RSI) and Average Directional Index (ADX) to assess -
// overbought/oversold conditions and trend strength, displaying their values and interpretations in a customizable ----
// on-chart table. The indicator dynamically colors the price line according to EMA relationships (bullish, bearish, or 
// neutral), and provides alert conditions for trade signals, overbought/oversold events, and color transitions, -------
// enabling automated alerting for traders. User options allow toggling the display of individual EMAs and the RSI/ADX -
// monitor table for a tailored charting experience. -------------------------------------------------------------------

indicator("WTT_HiFreqScalp_Rev6.0_Production", overlay=true)

// ======================================== INPUT GROUPS ===============================================================
// Organizing inputs into logical groups for better UI experience ------------------------------------------------------
var GROUP_TRADING_STYLE = "Trading Style Presets"
var GROUP_DISPLAY = "Display Preferences"
var GROUP_RSI_ADX = "5 x 5 Strategy Performance Table Settings"
var GROUP_ALERT_TIME = "Alert Setting"
var GROUP_MARKET_STRUCTURE = "Market Structure Detection"
var GROUP_KELTNER = "Keltner Channel Settings"
var GROUP_PIP_CAPTURE = "Three Bar Strategy Performance Table Settings"

// ==================================== TRADING STYLE PRESETS ==========================================================
// Trading style selection with optimized parameters -------------------------------------------------------------------
trading_style = input.string("Scalping", title="Trading Style", options=["Scalping", "Day Trading", "Swing Trading"], group=GROUP_TRADING_STYLE)

// ======================================== EMA SETTINGS ===============================================================
// EMA parameters for trend identification - dynamically set based on trading style ------------------------------------
ema1_length = trading_style == "Scalping" ? 21 : trading_style == "Day Trading" ? 21 : 50
ema2_length = trading_style == "Scalping" ? 50 : trading_style == "Day Trading" ? 50 : 200
ema3_length = trading_style == "Scalping" ? 8 : trading_style == "Day Trading" ? 9 : 20

// =================================== VOLUME FILTER SETTINGS ==========================================================
// Volume parameters for signal filtering - dynamically set based on trading style -------------------------------------
volume_ma_length = trading_style == "Scalping" ? 20 : trading_style == "Day Trading" ? 20 : 30

// ====================================== DISPLAY OPTIONS ==============================================================
// Display preferences for chart visualization -------------------------------------------------------------------------

// ================================== THREE BAR STRATEGY PERFORMANCE TABLE SETTINGS ====================================
// Settings for the three bar strategy performance table that shows 3-bar pip movement ---------------------------------
show_pip_capture_table = input.bool(true, title="Show Three Bar Strategy Performance Table", group=GROUP_PIP_CAPTURE, tooltip="Display table showing pip capture for trades held for 3 bars")
pip_table_position = input.string("bottom_right", title="Pip Table Position", options=["top_right", "top_left", "bottom_left", "bottom_right"], group=GROUP_PIP_CAPTURE)
pip_capture_lookback = input.int(15, title="Pip Capture Lookback", minval=10, maxval=100, group=GROUP_PIP_CAPTURE, tooltip="Number of recent signals to track for pip capture analysis (reduced for performance)")
show_pip_performance_data = input.bool(false, title="Show Performance Data", group=GROUP_PIP_CAPTURE, tooltip="Display average pips, total trades, and win percentage columns in the table")


// ================================= 5 x 5 STRATEGY PERFORMANCE TABLE SETTINGS =========================================
// Parameters for RSI and ADX calculations and display - dynamically set based on trading style ------------------------
rsi_length = trading_style == "Scalping" ? 14 : trading_style == "Day Trading" ? 14 : 21
adx_length = trading_style == "Scalping" ? 14 : trading_style == "Day Trading" ? 14 : 21
rsi_overbought = trading_style == "Scalping" ? 75 : trading_style == "Day Trading" ? 70 : 65
rsi_oversold = trading_style == "Scalping" ? 25 : trading_style == "Day Trading" ? 30 : 35
adx_threshold = trading_style == "Scalping" ? 25 : trading_style == "Day Trading" ? 30 : 25
show_table = input.bool(true, title="Show 5 x 5 Strategy Performance Table", group=GROUP_RSI_ADX)
table_position = input.string("bottom_left", title="Table Position", options=["top_right", "top_left", "bottom_left", "bottom_right"], group=GROUP_RSI_ADX)
show_performance_data = input.bool(false, title="Show Performance Data", group=GROUP_RSI_ADX, tooltip="Display success rates and signal counts for SMP, Pivot, and Bounce signals")

// Reversal threshold multiplier for potential signal detection
reversal_threshold = 0.85

// ==================================== ALERT SETTINGS ================================================================
// Alert enablement settings -------------------------------------------------------------------------------------------
enable_alerts = input.bool(true, title="Enable Alerts", group=GROUP_ALERT_TIME, tooltip="Toggle all alerts on or off")

// Individual alert type toggles
enable_smp_alerts = input.bool(true, title="Enable SMP Alerts", group=GROUP_ALERT_TIME, tooltip="Enable Syzygy Momentum Peak alerts")
enable_bounce_alerts = input.bool(true, title="Enable Bounce Alerts", group=GROUP_ALERT_TIME, tooltip="Enable Bounce projection alerts")

// Alert enablement variable
alerts_enabled = enable_alerts

// ==================================== SIGNAL FILTER SETTINGS =========================================================
// Signal spam prevention settings -------------------------------------------------------------------------------------
minBarsBetweenSignals = 2

// Success tracking parameters
success_lookback_bars = 15

// Volume confirmation filter settings
enable_volume_filter = input.bool(true, title="Enable Volume Filter", group=GROUP_ALERT_TIME, tooltip="Require above-average volume for pivot signals to ensure market participation")
volume_threshold_multiplier = 1.5

// ==================================== PULLBACK DETECTION SETTINGS ====================================================
// Pullback detection parameters for pivot signals
enable_pullback_detection = input.bool(true, title="Enable Pullback Detection", group=GROUP_ALERT_TIME, tooltip="Detect pullbacks after pivot signals for potential re-entry opportunities")
pullback_percentage = input.float(0.15, title="Pullback Percentage", minval=0.01, maxval=10.0, step=0.05, group=GROUP_ALERT_TIME, tooltip="Percentage pullback required to trigger detection (0.01-10.0%)")
pullback_lookback_bars = input.int(50, title="Pullback Lookback Bars", minval=5, maxval=100, group=GROUP_ALERT_TIME, tooltip="Maximum bars to look back for pullback detection after pivot signal")

// ================================== TREND VS RANGE DETECTION =========================================================
// Market structure detection parameters -------------------------------------------------------------------------------
trend_range_lookback = 15
trend_threshold = 0.45
range_threshold = 0.35

// ================================== KELTNER CHANNEL SETTINGS ==========================================================
// Keltner Channel parameters for ranging/mixed market conditions ------------------------------------------------------
enable_keltner_channels = input.bool(true, title="Enable Keltner Channels", group=GROUP_KELTNER, tooltip="Automatically show Keltner Channels during ranging/mixed markets")
keltner_length = input.int(20, title="Keltner Length", minval=5, maxval=50, group=GROUP_KELTNER, tooltip="Period for Keltner Channel calculation")
keltner_multiplier = input.float(1.2, title="Keltner Multiplier", minval=0.5, maxval=5.0, step=0.1, group=GROUP_KELTNER, tooltip="Base multiplier for channel width")
enable_volatility_adjustment = input.bool(true, title="Auto-Adjust for Volatility", group=GROUP_KELTNER, tooltip="Automatically adjust multiplier based on current price volatility")
volatility_lookback = input.int(15, title="Volatility Lookback", minval=10, maxval=50, group=GROUP_KELTNER, tooltip="Period to analyze for volatility adjustment")
volatility_min_multiplier = input.float(0.8, title="Min Volatility Multiplier", minval=0.5, maxval=1.5, step=0.1, group=GROUP_KELTNER, tooltip="Minimum multiplier during low volatility")
volatility_max_multiplier = input.float(2.5, title="Max Volatility Multiplier", minval=1.5, maxval=5.0, step=0.1, group=GROUP_KELTNER, tooltip="Maximum multiplier during high volatility")
keltner_source = input.source(close, title="Keltner Source", group=GROUP_KELTNER, tooltip="Price source for Keltner Channel calculation")


// ================================== GLOBAL VARIABLES =================================================================
// Initialize success tracking variables globally ----------------------------------------------------------------------

// Performance optimization settings
enable_performance_mode = input.bool(true, title="Enable Performance Mode", group=GROUP_DISPLAY, tooltip="Disable heavy calculations for better performance")

// Hardcoded display settings (removed from input controls)
show_pullback_indicators = true
show_market_structure = true

var float overall_success_ratio = 0.0
var int total_signals = 0

// Pivot success tracking variables
var float pivot_success_ratio = 0.0
var int pivot_total_signals = 0

// Signal bar tracking variables
var int lastLongSignalBar = 0
var int lastShortSignalBar = 0

// Performance optimization constants
var int MAX_SIGNALS = 5

// Market structure tracking variables
var string last_market_structure = "UNKNOWN"
var int structure_change_bar = 0

// === Trend/Counter-Trend Success Tracking Variables ===
var int trend_success_count = 0
var int countertrend_success_count = 0
var int trend_total_count = 0
var int countertrend_total_count = 0

// === Stop Loss Tracking Variables ===
var int trend_stop_loss_count = 0
var int countertrend_stop_loss_count = 0

// === Market Structure at Signal Time Tracking ===
var array<string> longMomentumPeakMarketStructure = array.new<string>()
var array<string> shortMomentumPeakMarketStructure = array.new<string>()
var array<float> longMomentumPeakPriceChange = array.new<float>()
var array<float> shortMomentumPeakPriceChange = array.new<float>()

// === Pivot Performance Tracking Variables ===
var int pivot_trend_success_count = 0
var int pivot_countertrend_success_count = 0
var int pivot_trend_total_count = 0
var int pivot_countertrend_total_count = 0
var int pivot_trend_stop_loss_count = 0
var int pivot_countertrend_stop_loss_count = 0

// === Bounce Performance Tracking Variables ===
var int bounce_trend_success_count = 0
var int bounce_countertrend_success_count = 0
var int bounce_trend_total_count = 0
var int bounce_countertrend_total_count = 0
var int bounce_trend_stop_loss_count = 0
var int bounce_countertrend_stop_loss_count = 0
var int bounce_total_signals = 0
var float bounce_success_ratio = 0.0

// === Keltner Breakout Performance Tracking Variables ===
var int keltner_trend_success_count = 0
var int keltner_countertrend_success_count = 0
var int keltner_trend_total_count = 0
var int keltner_countertrend_total_count = 0
var int keltner_trend_stop_loss_count = 0
var int keltner_countertrend_stop_loss_count = 0
var int keltner_total_signals = 0
var float keltner_success_ratio = 0.0

// === Signal Bar Tracking Variables ===
var int last_smp_signal_bar = 0
var int last_pivot_signal_bar = 0
var int last_bounce_signal_bar = 0
var int last_keltner_signal_bar = 0

// === Signal Highlight Flags (synchronized with alert conditions) ===
var int smp_highlight_bars = na
var int pivot_highlight_bars = na
var int bounce_highlight_bars = na
var int keltner_highlight_bars = na

// ================================== PULLBACK DETECTION VARIABLES =====================================================
// Variables to track pullback detection for pivot signals -------------------------------------------------------------
var float long_pivot_peak_price = 0.0
var float short_pivot_trough_price = 0.0
var int long_pivot_peak_bar = 0
var int short_pivot_trough_bar = 0
var bool long_pullback_detected = false
var bool short_pullback_detected = false
var float long_pullback_low = 0.0
var float short_pullback_high = 0.0
var bool long_bounce_detected = false
var bool short_bounce_detected = false

// Bounce display tracking variables
var bool long_bounce_displayed = false
var bool short_bounce_displayed = false
var int last_long_bounce_bar = 0
var int last_short_bounce_bar = 0

// Bounce alert tracking variables
var bool long_bounce_alerted = false
var bool short_bounce_alerted = false

// Synchronized bounce alert flag - matches alert conditions exactly
var bool long_bounce_alert_ready = false
var bool short_bounce_alert_ready = false

// ================================== EMA CROSSOVER TRACKING VARIABLES =================================================
// Variables to track if EMA has crossed in opposite direction since pivot signal --------------------------------------
var bool long_pivot_invalidated = false
var bool short_pivot_invalidated = false

// ================================== PULLBACK SUCCESS TRACKING VARIABLES ==============================================
// Variables to track success rate of pullback-based trades ------------------------------------------------------------
// NOTE: Pullback success tracking removed - not displayed in table

// === Bounce Performance Tracking Arrays ===
var array<int> longBounceBars = array.new<int>()
var array<int> shortBounceBars = array.new<int>()
var array<bool> longBounceResults = array.new<bool>()
var array<bool> shortBounceResults = array.new<bool>()

// === Keltner Breakout Performance Tracking Arrays ===
var array<int> longKeltnerBars = array.new<int>()
var array<int> shortKeltnerBars = array.new<int>()
var array<bool> longKeltnerResults = array.new<bool>()
var array<bool> shortKeltnerResults = array.new<bool>()

// === Pip Capture Tracking Variables ===
// Arrays to track signal bars and their pip capture after 3 bars
var array<int> smp_long_signal_bars = array.new<int>()
var array<int> smp_short_signal_bars = array.new<int>()
var array<float> smp_long_pip_capture = array.new<float>()
var array<float> smp_short_pip_capture = array.new<float>()

var array<int> pivot_long_signal_bars = array.new<int>()
var array<int> pivot_short_signal_bars = array.new<int>()
var array<float> pivot_long_pip_capture = array.new<float>()
var array<float> pivot_short_pip_capture = array.new<float>()

var array<int> bounce_long_signal_bars = array.new<int>()
var array<int> bounce_short_signal_bars = array.new<int>()
var array<float> bounce_long_pip_capture = array.new<float>()
var array<float> bounce_short_pip_capture = array.new<float>()

var array<int> keltner_long_signal_bars = array.new<int>()
var array<int> keltner_short_signal_bars = array.new<int>()
var array<float> keltner_long_pip_capture = array.new<float>()
var array<float> keltner_short_pip_capture = array.new<float>()

// Pip capture statistics - make these persistent
var float smp_avg_pip_capture = 0.0
var float pivot_avg_pip_capture = 0.0
var float bounce_avg_pip_capture = 0.0
var float keltner_avg_pip_capture = 0.0
var int smp_total_captures = 0
var int pivot_total_captures = 0
var int bounce_total_captures = 0
var int keltner_total_captures = 0

// Accumulated pip values for persistent storage
var float smp_accumulated_pips = 0.0
var float pivot_accumulated_pips = 0.0
var float bounce_accumulated_pips = 0.0
var float keltner_accumulated_pips = 0.0

// Win percentage variables for persistent storage
var float smp_win_percentage = 0.0
var float pivot_win_percentage = 0.0
var float bounce_win_percentage = 0.0
var float keltner_win_percentage = 0.0

// === Pip Rank Variables (for table display) ===
var string smp_pip_rank = "-"
var string pivot_pip_rank = "-"
var string bounce_pip_rank = "-"
var string keltner_pip_rank = "-"
var color smp_pip_rank_color = color.lime
var color pivot_pip_rank_color = color.lime
var color bounce_pip_rank_color = color.lime
var color keltner_pip_rank_color = color.lime





// ===================================== MAIN CALCULATIONS =============================================================
// Calculate primary indicators ----------------------------------------------------------------------------------------
ema3 = ta.ema(close, ema3_length)           // SuperFast EMA -----------------------------------------------------------
ema1 = ta.ema(close, ema1_length)           // Fast EMA ----------------------------------------------------------------
ema2 = ta.ema(close, ema2_length)           // Slow EMA ----------------------------------------------------------------
middleEMA = (ema1 + ema2) / 2               // Middle EMA (average of fast and slow) -----------------------------------

// Calculate volume moving average for the volume filter ---------------------------------------------------------------
volume_ma = ta.sma(volume, volume_ma_length)

// Calculate RSI for overbought/oversold detection ---------------------------------------------------------------------
rsi_value = ta.rsi(close, rsi_length)

// Calculate ADX components for trend strength assessment --------------------------------------------------------------
[plus_di, minus_di, adx_value] = ta.dmi(adx_length, adx_length)

// ========================================== FUNCTIONS ================================================================

// Determines price line color based on EMA relationships --------------------------------------------------------------
// Changes color to reflect bullish, bearish, or neutral conditions ----------------------------------------------------
determine_price_line_color(price, fast_ema, slow_ema, middle_ema) =>
    var color defaultPriceColor = color.white
    
    if price > fast_ema and price > slow_ema
        #26ba9f         // Bullish - price above both EMAs -----------------------------------------------------------
    else if price < fast_ema and price < slow_ema
        #6626ba         // Bearish - price below both EMAs -----------------------------------------------------------
    else if ta.crossover(fast_ema, slow_ema)
        #26ba9f         // Bullish crossover signal ------------------------------------------------------------------
    else if ta.crossunder(fast_ema, slow_ema)
        #6626ba         // Bearish crossunder signal -----------------------------------------------------------------
    else if ta.cross(price, middle_ema)
        color.white     // Price crossing the middle EMA - potential reversal ----------------------------------------
    else
        defaultPriceColor  // Default color when no specific condition is met ------------------------------------------

// Function to calculate color brightness (0-255) ----------------------------------------------------------------------
get_color_brightness(r, g, b) =>
    // Using perceived brightness formula: (0.299*R + 0.587*G + 0.114*B)
    math.round(0.299 * r + 0.587 * g + 0.114 * b)

// Function to get RSI-based gradient color: green (low), yellow (middle), red (high) ----------------------------------
get_rsi_gradient_color(rsi, rsi_min, rsi_max) =>
    normalized = math.max(0, math.min(1, (rsi - rsi_min) / (rsi_max - rsi_min)))
    r = 0
    g = 0
    b = 0
    if normalized < 0.5
        // Green to Yellow
        t = normalized * 2
        r := math.round(0 + (255 - 0) * t)      // 0 to 255
        g := math.round(128 + (255 - 128) * t)  // 128 to 255
        b := 0                                  // stays 0
    else
        // Yellow to Red
        t = (normalized - 0.5) * 2
        r := 255                                // stays 255
        g := math.round(255 - (255 * t))        // 255 to 0
        b := 0                                  // stays 0
    color.rgb(r, g, b)

// Function to determine optimal setup conditions ----------------------------------------------------------------------
get_optimal_setup() =>
    // Initialize setup message and color
    var string setup_message = "SMP Neutral ðŸ‡¨ðŸ‡­"
    var color setup_color = color.gray
    
    // Create a flashing effect using seconds - cached calculation
    flash = math.floor(time / 1000) % 2 == 0
    
    // Check for optimal long setup
    if rsi_value <= rsi_oversold and adx_value >= adx_threshold and volume > (volume_ma * volume_threshold_multiplier)
        setup_message := "SMP ðŸš€"
        setup_color := flash ? color.red : color.new(color.red, 90)
    // Check for optimal short setup
    else if rsi_value >= rsi_overbought and adx_value >= adx_threshold and volume > (volume_ma * volume_threshold_multiplier)
        setup_message := "SMP ðŸ“‰"
        setup_color := flash ? color.green : color.new(color.green, 90)
    // Check for potential long setup
    else if rsi_value <= (rsi_oversold * reversal_threshold) and adx_value >= (adx_threshold * 0.8) and volume > (volume_ma * volume_threshold_multiplier * 0.8)
        setup_message := "SMP âš¡"
        setup_color := flash ? color.maroon : color.new(color.maroon, 90)
    // Check for potential short setup
    else if rsi_value >= (rsi_overbought * reversal_threshold) and adx_value >= (adx_threshold * 0.8) and volume > (volume_ma * volume_threshold_multiplier * 0.8)
        setup_message := "SMP âš¡"
        setup_color := flash ? color.lime : color.new(color.lime, 90)
    else
        setup_message := "SMP ðŸ‡¨ðŸ‡­"
        setup_color := color.gray
    
    // Add success rate to setup message if we have data - optimized string concatenation
    if setup_message == "SMP ðŸ‡¨ðŸ‡­"
        setup_message := setup_message + " (neutral)"
    else if total_signals > 0
        success_interpretation = overall_success_ratio >= 60 ? " (High)" : overall_success_ratio >= 40 ? " (Med)" : " (Low)"
        setup_message := setup_message + success_interpretation
    else
        setup_message := setup_message + " (neutral)"
    
    [setup_message, setup_color]

// ================================== MARKET STRUCTURE DETECTION (OPTIMIZED) ===========================================
// Simplified market structure detection for better performance ------------------------------------------------------
// Cache market structure calculations to improve performance
var string cached_market_structure = "UNKNOWN"
var int last_structure_calc = 0
var float cached_price_change = 0.0

// Calculate price_change every bar (needed for other parts of the code)
price_change = (close - close[trend_range_lookback]) / close[trend_range_lookback] * 100

// Only recalculate market structure every 5 bars for performance (or every 10 bars in performance mode)
if bar_index - last_structure_calc >= (enable_performance_mode ? 10 : 5)
    normalized_slope = math.abs(price_change)

    up_moves = 0
    down_moves = 0
    for i = 1 to math.min(trend_range_lookback, 10)  // Limit to 10 bars for performance
        if close[i] > close[i-1]
            up_moves := up_moves + 1
        else if close[i] < close[i-1]
            down_moves := down_moves + 1

    total_moves = up_moves + down_moves
    directional_ratio = total_moves > 0 ? math.max(up_moves, down_moves) / total_moves : 0.5

    trend_score = 0.0
    if normalized_slope > 0.06
        trend_score := trend_score + 0.3
    else if normalized_slope > 0.03
        trend_score := trend_score + 0.2

    if directional_ratio > 0.6
        trend_score := trend_score + 0.3
    else if directional_ratio > 0.5
        trend_score := trend_score + 0.2

    if adx_value > 20
        trend_score := trend_score + 0.2
    else if adx_value > 16
        trend_score := trend_score + 0.15

    cached_market_structure := trend_score >= trend_threshold ? "TRENDING" : trend_score <= range_threshold ? "RANGING" : "MIXED"
    last_structure_calc := bar_index

// Use cached market structure
market_structure = cached_market_structure
structure_color = market_structure == "TRENDING" ? (price_change > 0 ? color.green : color.red) : market_structure == "RANGING" ? color.orange : color.yellow
// Detect structure changes
if market_structure != last_market_structure
    structure_change_bar := bar_index
    last_market_structure := market_structure

// ================================== KELTNER CHANNEL CALCULATIONS =====================================================
// Calculate Keltner Channels for ranging/mixed market conditions ------------------------------------------------------
keltner_middle = ta.ema(keltner_source, keltner_length)
keltner_atr = ta.atr(keltner_length)

// Calculate dynamic multiplier based on volatility
dynamic_multiplier = keltner_multiplier
if enable_volatility_adjustment and not enable_performance_mode
    // Calculate current volatility measures
    current_atr = ta.atr(volatility_lookback)
    historical_atr = ta.sma(ta.atr(volatility_lookback), volatility_lookback)
    
    // Calculate price range volatility
    current_range = ta.highest(high, volatility_lookback) - ta.lowest(low, volatility_lookback)
    historical_range = ta.sma(ta.highest(high, volatility_lookback) - ta.lowest(low, volatility_lookback), volatility_lookback)
    
    // Calculate volatility ratios
    atr_ratio = current_atr / historical_atr
    range_ratio = current_range / historical_range
    
    // Combine volatility measures (weighted average)
    volatility_factor = (atr_ratio * 0.6) + (range_ratio * 0.4)
    
    // Adjust multiplier based on volatility
    // Higher volatility = wider channels, lower volatility = tighter channels
    adjustment_factor = math.min(2.0, math.max(0.5, volatility_factor))
    dynamic_multiplier := math.min(volatility_max_multiplier, math.max(volatility_min_multiplier, keltner_multiplier * adjustment_factor))

// Calculate Keltner Channels with dynamic multiplier
keltner_upper = keltner_middle + (keltner_atr * dynamic_multiplier)
keltner_lower = keltner_middle - (keltner_atr * dynamic_multiplier)

// Calculate Keltner Channel crossover signals (only when price crosses during the bar, not when it opens already outside)
keltner_upper_cross_up = ta.crossover(close, keltner_upper) and open <= keltner_upper
keltner_lower_cross_down = ta.crossunder(close, keltner_lower) and open >= keltner_lower

// Determine when to show Keltner Channels based on market structure
// Show channels when market is ranging or mixed (not trending)
show_keltner = enable_keltner_channels and (market_structure == "RANGING" or market_structure == "MIXED")

// ===================================== SIGNAL GENERATION =============================================================
// Primary trading signals ---------------------------------------------------------------------------------------------
longSignal = ta.crossover(ema3, middleEMA)                               // Fast EMA crosses above slow EMA ------------
shortSignal = ta.crossunder(ema3, middleEMA)                             // Fast EMA crosses below slow EMA ------------

// Volume confirmation filter function
check_volume_confirmation() =>
    not enable_volume_filter or volume > (volume_ma * volume_threshold_multiplier)

// Enhanced pivot signals with cooldown, volume filters, and trend direction alignment
longSignalActive = longSignal and (bar_index - lastLongSignalBar >= minBarsBetweenSignals) and check_volume_confirmation() and market_structure == "TRENDING" and price_change > 0
shortSignalActive = shortSignal and (bar_index - lastShortSignalBar >= minBarsBetweenSignals) and check_volume_confirmation() and market_structure == "TRENDING" and price_change < 0

// Update signal bar tracking
if longSignalActive
    lastLongSignalBar := bar_index
if shortSignalActive
    lastShortSignalBar := bar_index

// ================================== PULLBACK DETECTION LOGIC =========================================================
// Track peak/trough prices after pivot signals and detect pullbacks ---------------------------------------------------

// Reset pullback detection when new pivot signals occur
if longSignalActive
    long_pivot_peak_price := close
    long_pivot_peak_bar := bar_index
    long_pullback_detected := false
    long_pivot_invalidated := false

if shortSignalActive
    short_pivot_trough_price := close
    short_pivot_trough_bar := bar_index
    short_pullback_detected := false
    short_pivot_invalidated := false

// ================================== EMA CROSSOVER INVALIDATION LOGIC =================================================
// Track if EMA crosses in opposite direction and invalidate pivot for bounce detection --------------------------------
if long_pivot_peak_price > 0 and not long_pivot_invalidated and ta.crossunder(ema3, middleEMA)
    long_pivot_invalidated := true

if short_pivot_trough_price > 0 and not short_pivot_invalidated and ta.crossover(ema3, middleEMA)
    short_pivot_invalidated := true

// Update peak/trough prices after pivot signals
if long_pivot_peak_price > 0 and bar_index > long_pivot_peak_bar and bar_index <= long_pivot_peak_bar + pullback_lookback_bars
    if close > long_pivot_peak_price
        long_pivot_peak_price := close
        long_pivot_peak_bar := bar_index

if short_pivot_trough_price > 0 and bar_index > short_pivot_trough_bar and bar_index <= short_pivot_trough_bar + pullback_lookback_bars
    if close < short_pivot_trough_price
        short_pivot_trough_price := close
        short_pivot_trough_bar := bar_index

// Detect pullbacks and bounces for long pivot signals
if enable_pullback_detection and long_pivot_peak_price > 0 and not long_pullback_detected and bar_index > long_pivot_peak_bar and bar_index <= long_pivot_peak_bar + pullback_lookback_bars
    pullback_distance = ((long_pivot_peak_price - close) / long_pivot_peak_price) * 100
    if pullback_distance >= pullback_percentage
        long_pullback_detected := true
        long_pullback_low := close

// Detect pullbacks and bounces for short pivot signals
if enable_pullback_detection and short_pivot_trough_price > 0 and not short_pullback_detected and bar_index > short_pivot_trough_bar and bar_index <= short_pivot_trough_bar + pullback_lookback_bars
    pullback_distance = ((close - short_pivot_trough_price) / short_pivot_trough_price) * 100
    if pullback_distance >= pullback_percentage
        short_pullback_detected := true
        short_pullback_high := close

// Detect bounces after pullbacks (only first time)
if enable_pullback_detection and long_pullback_detected and long_pullback_low > 0 and not long_pivot_invalidated and close > long_pullback_low and not long_bounce_detected
    long_bounce_detected := true
    long_bounce_displayed := true
    last_long_bounce_bar := bar_index

if enable_pullback_detection and short_pullback_detected and short_pullback_high > 0 and not short_pivot_invalidated and close < short_pullback_high and not short_bounce_detected
    short_bounce_detected := true
    short_bounce_displayed := true
    last_short_bounce_bar := bar_index

// Synchronized bounce alert flags - match chart indicators exactly
long_bounce_alert_ready := long_bounce_detected and not long_bounce_detected[1] and alerts_enabled and enable_bounce_alerts
short_bounce_alert_ready := short_bounce_detected and not short_bounce_detected[1] and alerts_enabled and enable_bounce_alerts

// Track bounce signals for performance evaluation
if long_bounce_alert_ready and not long_bounce_alerted
    array.unshift(longBounceBars, bar_index)
    last_bounce_signal_bar := bar_index
    if array.size(longBounceBars) > MAX_SIGNALS
        array.pop(longBounceBars)
    if array.size(longBounceResults) > 0
        array.pop(longBounceResults)

if short_bounce_alert_ready and not short_bounce_alerted
    array.unshift(shortBounceBars, bar_index)
    last_bounce_signal_bar := bar_index
    if array.size(shortBounceBars) > MAX_SIGNALS
        array.pop(shortBounceBars)
    if array.size(shortBounceResults) > 0
        array.pop(shortBounceResults)



// Reset pullback detection after lookback period expires
if long_pivot_peak_price > 0 and bar_index > long_pivot_peak_bar + pullback_lookback_bars
    long_pivot_peak_price := 0.0
    long_pullback_detected := false
    long_bounce_detected := false
    long_pullback_low := 0.0
    long_pivot_invalidated := false
    long_bounce_displayed := false

if short_pivot_trough_price > 0 and bar_index > short_pivot_trough_bar + pullback_lookback_bars
    short_pivot_trough_price := 0.0
    short_pullback_detected := false
    short_bounce_detected := false
    short_pullback_high := 0.0
    short_pivot_invalidated := false
    short_bounce_displayed := false

// TEMPORARILY DISABLED - Bounce indicators will stay visible permanently
// Clear previous bounce display after 5 bars have passed (show for 5 bars instead of 1)
// if long_bounce_displayed and bar_index > last_long_bounce_bar + 5
//     long_bounce_displayed := false

// if short_bounce_displayed and bar_index > last_short_bounce_bar + 5
//     short_bounce_displayed := false

// ================================== PULLBACK SUCCESS TRACKING LOGIC (OPTIMIZED) ======================================
// Track pullback signals and evaluate their success -------------------------------------------------------------------
// NOTE: Pullback success tracking logic removed - not displayed in table

// ================================== SMP CONDITIONS AND PROJECTIONS ===================================================
// Overbought/Oversold conditions --------------------------------------------------------------------------------------
isOverbought = rsi_value > rsi_overbought
isOversold = rsi_value < rsi_oversold

// RSI overbought/oversold visual indicators (for chart display only)
rsiOverboughtAlert = isOverbought[1] and ta.crossunder(rsi_value, rsi_overbought)
rsiOversoldAlert = isOversold[1] and ta.crossover(rsi_value, rsi_oversold)

// === Syzygy Momentum Peak Conditions ===
strict_momentum_peak_long = rsi_value <= rsi_oversold and adx_value >= adx_threshold and volume > (volume_ma * volume_threshold_multiplier)
strict_momentum_peak_short = rsi_value >= rsi_overbought and adx_value >= adx_threshold and volume > (volume_ma * volume_threshold_multiplier)
potential_momentum_peak_long = rsi_value <= (rsi_oversold * reversal_threshold) and adx_value >= (adx_threshold * 0.8) and volume > (volume_ma * volume_threshold_multiplier * 0.8)
potential_momentum_peak_short = rsi_value >= (rsi_overbought * reversal_threshold) and adx_value >= (adx_threshold * 0.8) and volume > (volume_ma * volume_threshold_multiplier * 0.8)

syzygy_momentum_peak_signal = strict_momentum_peak_long or strict_momentum_peak_short or potential_momentum_peak_long or potential_momentum_peak_short

// ================================== SIGNAL HIGHLIGHT FLAGS (SYNCHRONIZED WITH ALERT CONDITIONS) ======================
// Update highlight flags based on alert conditions - ensures table highlighting matches alert logic ----------------

// SMP highlight: synchronize with SMP alert condition
if syzygy_momentum_peak_signal and alerts_enabled and enable_smp_alerts
    smp_highlight_bars := 0
else if not na(smp_highlight_bars)
    smp_highlight_bars := smp_highlight_bars + 1
    if smp_highlight_bars > 3
        smp_highlight_bars := na

// Pivot highlight: synchronize with Pivot alert condition
if (longSignalActive and alerts_enabled and market_structure == "TRENDING" and price_change > 0) or (shortSignalActive and alerts_enabled and market_structure == "TRENDING" and price_change < 0)
    pivot_highlight_bars := 0
else if not na(pivot_highlight_bars)
    pivot_highlight_bars := pivot_highlight_bars + 1
    if pivot_highlight_bars > 3
        pivot_highlight_bars := na

// Bounce highlight: synchronize with Bounce alert conditions
if long_bounce_alert_ready or short_bounce_alert_ready
    bounce_highlight_bars := 0
else if not na(bounce_highlight_bars)
    bounce_highlight_bars := bounce_highlight_bars + 1
    if bounce_highlight_bars > 3
        bounce_highlight_bars := na

// Keltner highlight: synchronize with Keltner Breakout conditions
if (keltner_upper_cross_up and alerts_enabled) or (keltner_lower_cross_down and alerts_enabled)
    keltner_highlight_bars := 0
else if not na(keltner_highlight_bars)
    keltner_highlight_bars := keltner_highlight_bars + 1
    if keltner_highlight_bars > 3
        keltner_highlight_bars := na

// ================================== SUCCESS TRACKING (OPTIMIZED) =====================================================
// Track success rate of Syzygy Momentum Peak signals ------------------------------------------------------------------
var array<int> longMomentumPeakBars = array.new<int>()
var array<int> shortMomentumPeakBars = array.new<int>()
var array<bool> longMomentumPeakResults = array.new<bool>()
var array<bool> shortMomentumPeakResults = array.new<bool>()

// Track new momentum peak signals with optimized array management
if strict_momentum_peak_long or potential_momentum_peak_long
    array.unshift(longMomentumPeakBars, bar_index)
    array.unshift(longMomentumPeakMarketStructure, market_structure)
    array.unshift(longMomentumPeakPriceChange, price_change)
    last_smp_signal_bar := bar_index
    if array.size(longMomentumPeakBars) > MAX_SIGNALS
        array.pop(longMomentumPeakBars)
        array.pop(longMomentumPeakMarketStructure)
        array.pop(longMomentumPeakPriceChange)
    if array.size(longMomentumPeakResults) > 0
        array.pop(longMomentumPeakResults)
    
    // Track SMP long signal for pip capture
    array.unshift(smp_long_signal_bars, bar_index)
    if array.size(smp_long_signal_bars) > pip_capture_lookback
        array.pop(smp_long_signal_bars)

if strict_momentum_peak_short or potential_momentum_peak_short
    array.unshift(shortMomentumPeakBars, bar_index)
    array.unshift(shortMomentumPeakMarketStructure, market_structure)
    array.unshift(shortMomentumPeakPriceChange, price_change)
    last_smp_signal_bar := bar_index
    if array.size(shortMomentumPeakBars) > MAX_SIGNALS
        array.pop(shortMomentumPeakBars)
        array.pop(shortMomentumPeakMarketStructure)
        array.pop(shortMomentumPeakPriceChange)
    if array.size(shortMomentumPeakResults) > 0
        array.pop(shortMomentumPeakResults)
    
    // Track SMP short signal for pip capture
    array.unshift(smp_short_signal_bars, bar_index)
    if array.size(smp_short_signal_bars) > pip_capture_lookback
        array.pop(smp_short_signal_bars)

// Track success rate of Syzygy Pivot signals --------------------------------------------------------------------------
var array<int> longPivotBars = array.new<int>()
var array<int> shortPivotBars = array.new<int>()
var array<bool> longPivotResults = array.new<bool>()
var array<bool> shortPivotResults = array.new<bool>()

// Track new pivot signals with optimized array management
if longSignalActive
    array.unshift(longPivotBars, bar_index)
    last_pivot_signal_bar := bar_index
    if array.size(longPivotBars) > MAX_SIGNALS
        array.pop(longPivotBars)
    if array.size(longPivotResults) > 0
        array.pop(longPivotResults)
    
    // Track pivot long signal for pip capture
    array.unshift(pivot_long_signal_bars, bar_index)
    if array.size(pivot_long_signal_bars) > pip_capture_lookback
        array.pop(pivot_long_signal_bars)

if shortSignalActive
    array.unshift(shortPivotBars, bar_index)
    last_pivot_signal_bar := bar_index
    if array.size(shortPivotBars) > MAX_SIGNALS
        array.pop(shortPivotBars)
    if array.size(shortPivotResults) > 0
        array.pop(shortPivotResults)
    
    // Track pivot short signal for pip capture
    array.unshift(pivot_short_signal_bars, bar_index)
    if array.size(pivot_short_signal_bars) > pip_capture_lookback
        array.pop(pivot_short_signal_bars)

// Track bounce signals for pip capture
if long_bounce_detected and not long_bounce_displayed
    array.unshift(bounce_long_signal_bars, bar_index)
    if array.size(bounce_long_signal_bars) > pip_capture_lookback
        array.pop(bounce_long_signal_bars)

if short_bounce_detected and not short_bounce_displayed
    array.unshift(bounce_short_signal_bars, bar_index)
    array.unshift(bounce_short_pip_capture, close)  // Store the signal price
    if array.size(bounce_short_signal_bars) > pip_capture_lookback
        array.pop(bounce_short_signal_bars)
        array.pop(bounce_short_pip_capture)

// Track Keltner breakout signals for pip capture
if keltner_upper_cross_up
    last_keltner_signal_bar := bar_index
    array.unshift(keltner_long_signal_bars, bar_index)
    array.unshift(keltner_long_pip_capture, close)  // Store the signal price
    if array.size(keltner_long_signal_bars) > pip_capture_lookback
        array.pop(keltner_long_signal_bars)
        array.pop(keltner_long_pip_capture)

if keltner_lower_cross_down
    last_keltner_signal_bar := bar_index
    array.unshift(keltner_short_signal_bars, bar_index)
    array.unshift(keltner_short_pip_capture, close)  // Store the signal price
    if array.size(keltner_short_signal_bars) > pip_capture_lookback
        array.pop(keltner_short_signal_bars)
        array.pop(keltner_short_pip_capture)

// Only evaluate results every 20 bars for performance (optimized)
if bar_index % 20 == 0 and bar_index >= success_lookback_bars
    // Evaluate momentum peak results
    if array.size(longMomentumPeakBars) > 0 and array.size(longMomentumPeakBars) > array.size(longMomentumPeakResults)
        if (bar_index - array.get(longMomentumPeakBars, array.size(longMomentumPeakResults))) >= success_lookback_bars
            price_change_pct = ((close - close[success_lookback_bars]) / close[success_lookback_bars]) * 100
            pip_value = close * 0.0001
            profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
            stop_loss_pct = (5.0 * pip_value / close) * 100      // 5 pips
            result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
            
            // Get market structure at signal time
            signal_market_structure = array.get(longMomentumPeakMarketStructure, array.size(longMomentumPeakResults))
            signal_price_change = array.get(longMomentumPeakPriceChange, array.size(longMomentumPeakResults))
            
            // Improved trend/counter-trend logic for long signals
            // A long signal is counter-trend if it goes against the prevailing trend at signal time
            is_countertrend = signal_market_structure == "TRENDING" and signal_price_change < 0
            is_trend = signal_market_structure == "TRENDING" and signal_price_change > 0
            
            if is_trend
                trend_total_count := trend_total_count + 1
                if result == true
                    trend_success_count := trend_success_count + 1
                else if result == false
                    trend_stop_loss_count := trend_stop_loss_count + 1
            else if is_countertrend
                countertrend_total_count := countertrend_total_count + 1
                if result == true
                    countertrend_success_count := countertrend_success_count + 1
                else if result == false
                    countertrend_stop_loss_count := countertrend_stop_loss_count + 1
            // For RANGING/MIXED market structure, classify based on signal strength
            else if signal_market_structure == "RANGING" or signal_market_structure == "MIXED"
                // In ranging markets, strong signals (RSI extremes) are more likely to be counter-trend
                if rsi_value <= rsi_oversold or rsi_value >= rsi_overbought
                    countertrend_total_count := countertrend_total_count + 1
                    if result == true
                        countertrend_success_count := countertrend_success_count + 1
                    else if result == false
                        countertrend_stop_loss_count := countertrend_stop_loss_count + 1
                else
                    trend_total_count := trend_total_count + 1
                    if result == true
                        trend_success_count := trend_success_count + 1
                    else if result == false
                        trend_stop_loss_count := trend_stop_loss_count + 1
            if not na(result)
                array.push(longMomentumPeakResults, result)

    if array.size(shortMomentumPeakBars) > 0 and array.size(shortMomentumPeakBars) > array.size(shortMomentumPeakResults)
        if (bar_index - array.get(shortMomentumPeakBars, array.size(shortMomentumPeakResults))) >= success_lookback_bars
            price_change_pct = ((close[success_lookback_bars] - close) / close[success_lookback_bars]) * 100
            pip_value = close * 0.0001
            profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
            stop_loss_pct = (5.0 * pip_value / close) * 100      // 5 pips
            result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
            
            // Get market structure at signal time
            signal_market_structure = array.get(shortMomentumPeakMarketStructure, array.size(shortMomentumPeakResults))
            signal_price_change = array.get(shortMomentumPeakPriceChange, array.size(shortMomentumPeakResults))
            
            // Improved trend/counter-trend logic for short signals
            // A short signal is counter-trend if it goes against the prevailing trend at signal time
            is_countertrend = signal_market_structure == "TRENDING" and signal_price_change > 0
            is_trend = signal_market_structure == "TRENDING" and signal_price_change < 0
            
            if is_trend
                trend_total_count := trend_total_count + 1
                if result == true
                    trend_success_count := trend_success_count + 1
                else if result == false
                    trend_stop_loss_count := trend_stop_loss_count + 1
            else if is_countertrend
                countertrend_total_count := countertrend_total_count + 1
                if result == true
                    countertrend_success_count := countertrend_success_count + 1
                else if result == false
                    countertrend_stop_loss_count := countertrend_stop_loss_count + 1
            // For RANGING/MIXED market structure, classify based on signal strength
            else if signal_market_structure == "RANGING" or signal_market_structure == "MIXED"
                // In ranging markets, strong signals (RSI extremes) are more likely to be counter-trend
                if rsi_value <= rsi_oversold or rsi_value >= rsi_overbought
                    countertrend_total_count := countertrend_total_count + 1
                    if result == true
                        countertrend_success_count := countertrend_success_count + 1
                    else if result == false
                        countertrend_stop_loss_count := countertrend_stop_loss_count + 1
                else
                    trend_total_count := trend_total_count + 1
                    if result == true
                        trend_success_count := trend_success_count + 1
                    else if result == false
                        trend_stop_loss_count := trend_stop_loss_count + 1
            if not na(result)
                array.push(shortMomentumPeakResults, result)

    // Evaluate pivot results
    if array.size(longPivotBars) > 0 and array.size(longPivotBars) > array.size(longPivotResults)
        if (bar_index - array.get(longPivotBars, array.size(longPivotResults))) >= success_lookback_bars
            price_change_pct = ((close - close[success_lookback_bars]) / close[success_lookback_bars]) * 100
            pip_value = close * 0.0001
            profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
            stop_loss_pct = (7.0 * pip_value / close) * 100      // 7 pips
            result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
            // Pivot trend/counter-trend logic for long
            is_trend = market_structure == "TRENDING" and price_change > 0
            is_countertrend = market_structure == "TRENDING" and price_change < 0
            if is_trend
                pivot_trend_total_count := pivot_trend_total_count + 1
                if result == true
                    pivot_trend_success_count := pivot_trend_success_count + 1
                else if result == false
                    pivot_trend_stop_loss_count := pivot_trend_stop_loss_count + 1
            else if is_countertrend
                pivot_countertrend_total_count := pivot_countertrend_total_count + 1
                if result == true
                    pivot_countertrend_success_count := pivot_countertrend_success_count + 1
                else if result == false
                    pivot_countertrend_stop_loss_count := pivot_countertrend_stop_loss_count + 1
            // For RANGING/MIXED market structure, classify based on price direction relative to signal
            else if market_structure == "RANGING" or market_structure == "MIXED"
                if price_change > 0
                    pivot_trend_total_count := pivot_trend_total_count + 1
                    if result == true
                        pivot_trend_success_count := pivot_trend_success_count + 1
                    else if result == false
                        pivot_trend_stop_loss_count := pivot_trend_stop_loss_count + 1
                else if price_change < 0
                    pivot_countertrend_total_count := pivot_countertrend_total_count + 1
                    if result == true
                        pivot_countertrend_success_count := pivot_countertrend_success_count + 1
                    else if result == false
                        pivot_countertrend_stop_loss_count := pivot_countertrend_stop_loss_count + 1
            if not na(result)
                array.push(longPivotResults, result)

    if array.size(shortPivotBars) > 0 and array.size(shortPivotBars) > array.size(shortPivotResults)
        if (bar_index - array.get(shortPivotBars, array.size(shortPivotResults))) >= success_lookback_bars
            price_change_pct = ((close[success_lookback_bars] - close) / close[success_lookback_bars]) * 100
            pip_value = close * 0.0001
            profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
            stop_loss_pct = (7.0 * pip_value / close) * 100      // 7 pips
            result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
            // Pivot trend/counter-trend logic for short
            is_trend = market_structure == "TRENDING" and price_change < 0
            is_countertrend = market_structure == "TRENDING" and price_change > 0
            if is_trend
                pivot_trend_total_count := pivot_trend_total_count + 1
                if result == true
                    pivot_trend_success_count := pivot_trend_success_count + 1
                else if result == false
                    pivot_trend_stop_loss_count := pivot_trend_stop_loss_count + 1
            else if is_countertrend
                pivot_countertrend_total_count := pivot_countertrend_total_count + 1
                if result == true
                    pivot_countertrend_success_count := pivot_countertrend_success_count + 1
                else if result == false
                    pivot_countertrend_stop_loss_count := pivot_countertrend_stop_loss_count + 1
            // For RANGING/MIXED market structure, classify based on price direction relative to signal
            else if market_structure == "RANGING" or market_structure == "MIXED"
                if price_change < 0
                    pivot_trend_total_count := pivot_trend_total_count + 1
                    if result == true
                        pivot_trend_success_count := pivot_trend_success_count + 1
                    else if result == false
                        pivot_trend_stop_loss_count := pivot_trend_stop_loss_count + 1
                else if price_change > 0
                    pivot_countertrend_total_count := pivot_countertrend_total_count + 1
                    if result == true
                        pivot_countertrend_success_count := pivot_countertrend_success_count + 1
                    else if result == false
                        pivot_countertrend_stop_loss_count := pivot_countertrend_stop_loss_count + 1
            if not na(result)
                array.push(shortPivotResults, result)

// Calculate success ratios - only when needed for display (optimized)
total_signals := array.size(longMomentumPeakResults) + array.size(shortMomentumPeakResults)
total_successes = 0
if array.size(longMomentumPeakResults) > 0
    for i = 0 to math.min(array.size(longMomentumPeakResults) - 1, 9)
        if array.get(longMomentumPeakResults, i)
            total_successes := total_successes + 1
if array.size(shortMomentumPeakResults) > 0
    for i = 0 to math.min(array.size(shortMomentumPeakResults) - 1, 9)
        if array.get(shortMomentumPeakResults, i)
            total_successes := total_successes + 1
overall_success_ratio := total_signals > 0 ? (total_successes / total_signals) * 100 : 0.0

// Pivot success ratio - optimized calculation
pivot_total_signals := array.size(longPivotResults) + array.size(shortPivotResults)
pivot_total_successes = 0
if array.size(longPivotResults) > 0
    for i = 0 to math.min(array.size(longPivotResults) - 1, 9)
        if array.get(longPivotResults, i)
            pivot_total_successes := pivot_total_successes + 1
if array.size(shortPivotResults) > 0
    for i = 0 to math.min(array.size(shortPivotResults) - 1, 9)
        if array.get(shortPivotResults, i)
            pivot_total_successes := pivot_total_successes + 1
pivot_success_ratio := pivot_total_signals > 0 ? (pivot_total_successes / pivot_total_signals) * 100 : 0.0

// Evaluate bounce results
if array.size(longBounceBars) > 0 and array.size(longBounceBars) > array.size(longBounceResults)
    if (bar_index - array.get(longBounceBars, array.size(longBounceResults))) >= success_lookback_bars
        price_change_pct = ((close - close[success_lookback_bars]) / close[success_lookback_bars]) * 100
        pip_value = close * 0.0001
        profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
        stop_loss_pct = (7.0 * pip_value / close) * 100      // 7 pips
        result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
        // Bounce trend/counter-trend logic for long
        is_trend = market_structure == "TRENDING" and price_change > 0
        is_countertrend = market_structure == "TRENDING" and price_change < 0
        if is_trend
            bounce_trend_total_count := bounce_trend_total_count + 1
            if result == true
                bounce_trend_success_count := bounce_trend_success_count + 1
            else if result == false
                bounce_trend_stop_loss_count := bounce_trend_stop_loss_count + 1
        else if is_countertrend
            bounce_countertrend_total_count := bounce_countertrend_total_count + 1
            if result == true
                bounce_countertrend_success_count := bounce_countertrend_success_count + 1
            else if result == false
                bounce_countertrend_stop_loss_count := bounce_countertrend_stop_loss_count + 1
        // For RANGING/MIXED market structure, classify based on price direction relative to signal
        else if market_structure == "RANGING" or market_structure == "MIXED"
            if price_change > 0
                bounce_trend_total_count := bounce_trend_total_count + 1
                if result == true
                    bounce_trend_success_count := bounce_trend_success_count + 1
                else if result == false
                    bounce_trend_stop_loss_count := bounce_trend_stop_loss_count + 1
            else if price_change < 0
                bounce_countertrend_total_count := bounce_countertrend_total_count + 1
                if result == true
                    bounce_countertrend_success_count := bounce_countertrend_success_count + 1
                else if result == false
                    bounce_countertrend_stop_loss_count := bounce_countertrend_stop_loss_count + 1
        if not na(result)
            array.push(longBounceResults, result)

if array.size(shortBounceBars) > 0 and array.size(shortBounceBars) > array.size(shortBounceResults)
    if (bar_index - array.get(shortBounceBars, array.size(shortBounceResults))) >= success_lookback_bars
        price_change_pct = ((close[success_lookback_bars] - close) / close[success_lookback_bars]) * 100
        pip_value = close * 0.0001
        profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
        stop_loss_pct = (7.0 * pip_value / close) * 100      // 7 pips
        result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
        // Bounce trend/counter-trend logic for short
        is_trend = market_structure == "TRENDING" and price_change < 0
        is_countertrend = market_structure == "TRENDING" and price_change > 0
        if is_trend
            bounce_trend_total_count := bounce_trend_total_count + 1
            if result == true
                bounce_trend_success_count := bounce_trend_success_count + 1
            else if result == false
                bounce_trend_stop_loss_count := bounce_trend_stop_loss_count + 1
        else if is_countertrend
            bounce_countertrend_total_count := bounce_countertrend_total_count + 1
            if result == true
                bounce_countertrend_success_count := bounce_countertrend_success_count + 1
            else if result == false
                bounce_countertrend_stop_loss_count := bounce_countertrend_stop_loss_count + 1
        // For RANGING/MIXED market structure, classify based on price direction relative to signal
        else if market_structure == "RANGING" or market_structure == "MIXED"
            if price_change < 0
                bounce_trend_total_count := bounce_trend_total_count + 1
                if result == true
                    bounce_trend_success_count := bounce_trend_success_count + 1
                else if result == false
                    bounce_trend_stop_loss_count := bounce_trend_stop_loss_count + 1
            else if price_change > 0
                bounce_countertrend_total_count := bounce_countertrend_total_count + 1
                if result == true
                    bounce_countertrend_success_count := bounce_countertrend_success_count + 1
                else if result == false
                    bounce_countertrend_stop_loss_count := bounce_countertrend_stop_loss_count + 1
        if not na(result)
            array.push(shortBounceResults, result)

// Calculate bounce success ratios - only when needed for display (optimized)
bounce_total_signals := array.size(longBounceResults) + array.size(shortBounceResults)
bounce_total_successes = 0
if array.size(longBounceResults) > 0
    for i = 0 to math.min(array.size(longBounceResults) - 1, 9)
        if array.get(longBounceResults, i)
            bounce_total_successes := bounce_total_successes + 1
if array.size(shortBounceResults) > 0
    for i = 0 to math.min(array.size(shortBounceResults) - 1, 9)
        if array.get(shortBounceResults, i)
            bounce_total_successes := bounce_total_successes + 1
bounce_success_ratio := bounce_total_signals > 0 ? (bounce_total_successes / bounce_total_signals) * 100 : 0.0

// Evaluate Keltner breakout results
if array.size(longKeltnerBars) > 0 and array.size(longKeltnerBars) > array.size(longKeltnerResults)
    if (bar_index - array.get(longKeltnerBars, array.size(longKeltnerResults))) >= success_lookback_bars
        price_change_pct = ((close - close[success_lookback_bars]) / close[success_lookback_bars]) * 100
        pip_value = close * 0.0001
        profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
        stop_loss_pct = (5.0 * pip_value / close) * 100      // 5 pips
        result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
        
        // Keltner trend/counter-trend logic for long breakouts
        is_trend = market_structure == "RANGING" and price_change > 0
        is_countertrend = market_structure == "TRENDING" and price_change > 0
        
        if is_trend
            keltner_trend_total_count := keltner_trend_total_count + 1
            if result == true
                keltner_trend_success_count := keltner_trend_success_count + 1
            else if result == false
                keltner_trend_stop_loss_count := keltner_trend_stop_loss_count + 1
        else if is_countertrend
            keltner_countertrend_total_count := keltner_countertrend_total_count + 1
            if result == true
                keltner_countertrend_success_count := keltner_countertrend_success_count + 1
            else if result == false
                keltner_countertrend_stop_loss_count := keltner_countertrend_stop_loss_count + 1
        // For MIXED market structure, classify based on signal strength
        else if market_structure == "MIXED"
            if price_change > 0
                keltner_trend_total_count := keltner_trend_total_count + 1
                if result == true
                    keltner_trend_success_count := keltner_trend_success_count + 1
                else if result == false
                    keltner_trend_stop_loss_count := keltner_trend_stop_loss_count + 1
            else
                keltner_countertrend_total_count := keltner_countertrend_total_count + 1
                if result == true
                    keltner_countertrend_success_count := keltner_countertrend_success_count + 1
                else if result == false
                    keltner_countertrend_stop_loss_count := keltner_countertrend_stop_loss_count + 1
        if not na(result)
            array.push(longKeltnerResults, result)

if array.size(shortKeltnerBars) > 0 and array.size(shortKeltnerBars) > array.size(shortKeltnerResults)
    if (bar_index - array.get(shortKeltnerBars, array.size(shortKeltnerResults))) >= success_lookback_bars
        price_change_pct = ((close[success_lookback_bars] - close) / close[success_lookback_bars]) * 100
        pip_value = close * 0.0001
        profit_target_pct = (5.0 * pip_value / close) * 100  // 5 pips
        stop_loss_pct = (5.0 * pip_value / close) * 100      // 5 pips
        result = price_change_pct >= profit_target_pct ? true : (price_change_pct <= -stop_loss_pct ? false : na)
        
        // Keltner trend/counter-trend logic for short breakouts
        is_trend = market_structure == "RANGING" and price_change < 0
        is_countertrend = market_structure == "TRENDING" and price_change < 0
        
        if is_trend
            keltner_trend_total_count := keltner_trend_total_count + 1
            if result == true
                keltner_trend_success_count := keltner_trend_success_count + 1
            else if result == false
                keltner_trend_stop_loss_count := keltner_trend_stop_loss_count + 1
        else if is_countertrend
            keltner_countertrend_total_count := keltner_countertrend_total_count + 1
            if result == true
                keltner_countertrend_success_count := keltner_countertrend_success_count + 1
            else if result == false
                keltner_countertrend_stop_loss_count := keltner_countertrend_stop_loss_count + 1
        // For MIXED market structure, classify based on signal strength
        else if market_structure == "MIXED"
            if price_change < 0
                keltner_trend_total_count := keltner_trend_total_count + 1
                if result == true
                    keltner_trend_success_count := keltner_trend_success_count + 1
                else if result == false
                    keltner_trend_stop_loss_count := keltner_trend_stop_loss_count + 1
            else
                keltner_countertrend_total_count := keltner_countertrend_total_count + 1
                if result == true
                    keltner_countertrend_success_count := keltner_countertrend_success_count + 1
                else if result == false
                    keltner_countertrend_stop_loss_count := keltner_countertrend_stop_loss_count + 1
        if not na(result)
            array.push(shortKeltnerResults, result)

// Calculate Keltner success ratios (optimized)
keltner_total_signals := array.size(longKeltnerResults) + array.size(shortKeltnerResults)
keltner_total_successes = 0
if array.size(longKeltnerResults) > 0
    for i = 0 to math.min(array.size(longKeltnerResults) - 1, 9)
        if array.get(longKeltnerResults, i)
            keltner_total_successes := keltner_total_successes + 1
if array.size(shortKeltnerResults) > 0
    for i = 0 to math.min(array.size(shortKeltnerResults) - 1, 9)
        if array.get(shortKeltnerResults, i)
            keltner_total_successes := keltner_total_successes + 1
keltner_success_ratio := keltner_total_signals > 0 ? (keltner_total_successes / keltner_total_signals) * 100 : 0.0

// ================================== ALERT STATUS TRACKING ============================================================
// Create persistent variables to track the last triggered alert and its bar index -------------------------------------
var string lastAlertType = "None"
var int lastAlertBarIndex = 0

// Update alert status based on conditions - track all signal types ---------------------------------------------------
if longSignalActive
    lastAlertType := "LONG"
    lastAlertBarIndex := bar_index
else if shortSignalActive
    lastAlertType := "SHORT"
    lastAlertBarIndex := bar_index

// ================================== ALERT ENABLEMENT ================================================================
// Simple alert enablement without time windows -----------------------------------------------------------------------
// alerts_enabled is now declared earlier in the code

// Calculate bars since last alert -------------------------------------------------------------------------------------
barsSinceLastAlert = bar_index == lastAlertBarIndex ? 1 : bar_index - lastAlertBarIndex

// ======================================= VISUALIZATION ===============================================================
// Determine price line color based on technical conditions ------------------------------------------------------------
priceLineColor = determine_price_line_color(close, ema1, ema2, middleEMA)

// Plot price and middle EMA with the dynamic color --------------------------------------------------------------------
pricePlot = plot(close, color=color.new(priceLineColor, 0), linewidth=2, title="Price Line", 
     style=plot.style_line, editable=true, show_last=5000)
middleEMAPlot = plot(middleEMA, color=color.new(priceLineColor, 0), linewidth=2, 
     title="Middle EMA Line", style=plot.style_line, editable=true, show_last=5000)

// Fill area between price and middle EMA for visual emphasis ----------------------------------------------------------
fill(pricePlot, middleEMAPlot, color.new(priceLineColor, 50))

// Plot EMAs (hidden by default for cleaner chart) -------------------------------------------------------------------
plot(ema3, color=color.new(color.rgb(0, 255, 255), 100), title="Super Fast EMA", linewidth=2)
plot(ema1, color=color.new(color.yellow, 100), title="Fast EMA", linewidth=2)
plot(middleEMA, color=color.new(color.silver, 100), title="Middle EMA", linewidth=2)
plot(ema2, color=color.new(color.purple, 100), title="Slow EMA", linewidth=4)

// Plot Keltner Channels (always plot, but change color based on market state) ----------------------------
// Use magenta/fuchsia color for excellent contrast and visibility
keltner_border_color = show_keltner ? color.new(color.fuchsia, 10) : color.new(color.black, 100)

// Create Keltner Channel boundaries
plot(keltner_upper, color=keltner_border_color, title="Keltner Upper", linewidth=2, style=plot.style_line)
plot(keltner_lower, color=keltner_border_color, title="Keltner Lower", linewidth=2, style=plot.style_line)

// Plot trading signals ------------------------------------------------------------------------------------------------
plotshape(series=longSignalActive, location=location.bottom, color=color.lime, 
     style=shape.triangleup, size=size.tiny, title="Syzygy Cross Long", text="B", textcolor=color.lime)
plotshape(series=shortSignalActive, location=location.top, color=color.white, 
     style=shape.triangledown, size=size.tiny, title="Syzygy Cross Short", text="S", textcolor=color.white)

// Plot overbought/oversold markers (removed for cleaner display) ------------------------------------------------------------------------------------

// Draw vertical line at signal points ---------------------------------------------------------------------------------
if longSignalActive
    line.new(bar_index, 0, bar_index, 0, extend=extend.both, 
         color=#43b593, width=1, style=line.style_dotted)

if shortSignalActive
    line.new(bar_index, 0, bar_index, 0, extend=extend.both, 
         color=color.gray, width=1, style=line.style_dotted)

// Plot SMP dots with text labels indicating strength (simplified for cleaner display)
plotshape(strict_momentum_peak_long, location=location.belowbar, color=#dec20b, style=shape.circle, size=size.small, title="Strong Long Momentum Peak")
plotshape(potential_momentum_peak_long, location=location.belowbar, color=#7371df, style=shape.circle, size=size.tiny, title="Weak Long Momentum Peak")
plotshape(strict_momentum_peak_short, location=location.abovebar, color=#dec20b, style=shape.circle, size=size.small, title="Strong Short Momentum Peak")
plotshape(potential_momentum_peak_short, location=location.abovebar, color=#7371df, style=shape.circle, size=size.tiny, title="Weak Short Momentum Peak")

// ================================== KELTNER CHANNEL CROSSOVER INDICATORS ==============================================
// Visual indicators when price crosses Keltner Channel lines -----------------------------------------------------

// Track Keltner Channel breakouts
if keltner_upper_cross_up
    last_keltner_signal_bar := bar_index
    array.unshift(longKeltnerBars, bar_index)
    if array.size(longKeltnerBars) > MAX_SIGNALS
        array.pop(longKeltnerBars)
    if array.size(longKeltnerResults) > 0
        array.pop(longKeltnerResults)

if keltner_lower_cross_down
    last_keltner_signal_bar := bar_index
    array.unshift(shortKeltnerBars, bar_index)
    if array.size(shortKeltnerBars) > MAX_SIGNALS
        array.pop(shortKeltnerBars)
    if array.size(shortKeltnerResults) > 0
        array.pop(shortKeltnerResults)

// Plot square indicators for Keltner Channel breakouts
plotshape(keltner_upper_cross_up, location=location.abovebar, color=color.green, style=shape.square, size=size.tiny, 
     title="Keltner Upper Breakout")
plotshape(keltner_lower_cross_down, location=location.belowbar, color=color.red, style=shape.square, size=size.tiny, 
     title="Keltner Lower Breakdown")




// ================================== PULLBACK DETECTION VISUALS =======================================================
// Visual indicators for pullback detection after pivot signals --------------------------------------------------------

// Set alert flags to prevent multiple plots
// NOTE: Removed redundant pullback alert flags - using bounce logic instead



// TEMPORARY DEBUG: Plot simple bounce detection to test if basic logic works
// Bounce detection indicators - only show on the bar when bounce is first detected
plotshape(long_bounce_detected and not long_bounce_detected[1], 
     location=location.belowbar, color=color.lime, style=shape.triangleup, size=size.normal, 
     title="Long Bounce Detected")

plotshape(short_bounce_detected and not short_bounce_detected[1], 
     location=location.abovebar, color=color.orange, style=shape.triangledown, size=size.normal, 
     title="Short Bounce Detected")

// TEMPORARY DEBUG: Force bounce detection flags when gray circles appear
if enable_pullback_detection and long_pullback_detected and long_pullback_low > 0 and not long_pivot_invalidated and close > long_pullback_low and not long_bounce_detected
    long_bounce_detected := true
    long_bounce_displayed := true

if enable_pullback_detection and short_pullback_detected and short_pullback_high > 0 and not short_pivot_invalidated and close < short_pullback_high and not short_bounce_detected
    short_bounce_detected := true
    short_bounce_displayed := true

// Bounce detection - only when price starts moving back in opposite direction
if enable_pullback_detection and long_pullback_detected and long_pullback_low > 0 and not long_pivot_invalidated and close > long_pullback_low and close[1] <= long_pullback_low and not long_bounce_detected
    long_bounce_detected := true
    long_bounce_displayed := true

if enable_pullback_detection and short_pullback_detected and short_pullback_high > 0 and not short_pivot_invalidated and close < short_pullback_high and close[1] >= short_pullback_high and not short_bounce_detected
    short_bounce_detected := true
    short_bounce_displayed := true








// ================================== 5 x 5 STRATEGY PERFORMANCE TABLE (OPTIMIZED) ======================================
// Only update table when signals change or every 10 bars for performance ----------------------------------------------
// Calculate market structure display for use in both tables
trend_direction = ""
if market_structure == "TRENDING"
    if price_change > 0
        trend_direction := "UP"
    else
        trend_direction := "DOWN"
else if market_structure == "RANGING"
    trend_direction := "SIDEWAYS"
else  // MIXED
    if math.abs(price_change) < 0.05
        trend_direction := "SIDEWAYS"
    else if price_change > 0
        trend_direction := "UP"
    else
        trend_direction := "DOWN"

market_structure_display = (market_structure == "TRENDING" ? "TREND" : market_structure == "RANGING" ? "RANGE" : "MIXED") + " " + trend_direction

// ================================== GLOBAL BARS DISPLAY VARIABLES ===========================================
// Calculate bars since signals for use across all table sections
bars_since_smp = last_smp_signal_bar > 0 ? bar_index - last_smp_signal_bar - 1 : 999
smp_bars_display = bars_since_smp <= 3 ? str.tostring(bars_since_smp) : ">3"
smp_bars_color = bars_since_smp <= 3 ? color.yellow : color.gray

bars_since_pivot = last_pivot_signal_bar > 0 ? bar_index - last_pivot_signal_bar - 1 : 999
pivot_bars_display = bars_since_pivot <= 3 ? str.tostring(bars_since_pivot) : ">3"
pivot_bars_color = bars_since_pivot <= 3 ? color.yellow : color.gray

bars_since_bounce = last_bounce_signal_bar > 0 ? bar_index - last_bounce_signal_bar - 1 : 999
bounce_bars_display = bars_since_bounce <= 3 ? str.tostring(bars_since_bounce) : ">3"
bounce_bars_color = bars_since_bounce <= 3 ? color.yellow : color.gray

bars_since_keltner = last_keltner_signal_bar > 0 ? bar_index - last_keltner_signal_bar - 1 : 999
keltner_bars_display = bars_since_keltner <= 3 ? str.tostring(bars_since_keltner) : ">3"
keltner_bars_color = bars_since_keltner <= 3 ? color.yellow : color.gray

var string lastTableUpdateKey = ""
// Optimized table update key - use integer instead of string concatenation
var int lastTableUpdateInt = 0
tableUpdateInt = (longSignalActive ? 1 : 0) + (shortSignalActive ? 2 : 0) + (strict_momentum_peak_long ? 4 : 0) + (strict_momentum_peak_short ? 8 : 0) + (bar_index % 50)
tableUpdateKey = str.tostring(tableUpdateInt)

if show_table and (tableUpdateKey != lastTableUpdateKey and (bar_index % 20 == 0 or longSignalActive or shortSignalActive or strict_momentum_peak_long or strict_momentum_peak_short))
    lastTableUpdateKey := tableUpdateKey
    
    // Create table with position based on user selection
    var table monitor_table = table.new(position = table_position == "top_right" ? 
     position.top_right : table_position == "top_left" ? position.top_left : table_position == "bottom_left" ? 
     position.bottom_left : position.bottom_right, columns = 5, rows = 9, bgcolor = color.rgb(0, 0, 0, 80), 
     border_width = 1)

    // ================================== GLOBAL VARIABLES FOR STRATEGY RANKING ===========================================
    // Calculate rankings based on win percentage (only rank signals with at least 2 trades for reliability)
    smp_pip_rank = smp_total_captures >= 2 ? "0" : "-"
    pivot_pip_rank = pivot_total_captures >= 2 ? "0" : "-"
    bounce_pip_rank = bounce_total_captures >= 2 ? "0" : "-"
    keltner_pip_rank = keltner_total_captures >= 2 ? "0" : "-"
    smp_pip_rank_color = smp_total_captures >= 2 ? color.white : color.lime
    pivot_pip_rank_color = pivot_total_captures >= 2 ? color.white : color.lime
    bounce_pip_rank_color = bounce_total_captures >= 2 ? color.white : color.lime
    keltner_pip_rank_color = keltner_total_captures >= 2 ? color.white : color.lime

    // Determine which signal has the highest win percentage rank (lowest number = highest rank) - Global scope
    string highest_win_rank_signal = ""
    float highest_win_rank_value = 999.0

    // Check each win percentage rank and find the lowest number (highest rank)
    if smp_pip_rank != "-" and smp_pip_rank != "" and str.tonumber(smp_pip_rank) < highest_win_rank_value
        highest_win_rank_value = str.tonumber(smp_pip_rank)
        highest_win_rank_signal = "SMP"
    if pivot_pip_rank != "-" and pivot_pip_rank != "" and str.tonumber(pivot_pip_rank) < highest_win_rank_value
        highest_win_rank_value = str.tonumber(pivot_pip_rank)
        highest_win_rank_signal = "PIVOT"
    if bounce_pip_rank != "-" and bounce_pip_rank != "" and str.tonumber(bounce_pip_rank) < highest_win_rank_value
        highest_win_rank_value = str.tonumber(bounce_pip_rank)
        highest_win_rank_signal = "BOUNCE"
    if keltner_pip_rank != "-" and keltner_pip_rank != "" and str.tonumber(keltner_pip_rank) < highest_win_rank_value
        highest_win_rank_value = str.tonumber(keltner_pip_rank)
        highest_win_rank_signal = "KELTNER"

    // Calculate signal rankings for the new column
    smp_success_rate = total_signals > 0 ? overall_success_ratio : 0
    pivot_success_rate = pivot_total_signals > 0 ? pivot_success_ratio : 0
    bounce_success_rate = bounce_total_signals > 0 ? bounce_success_ratio : 0
    keltner_success_rate = keltner_total_signals > 0 ? keltner_success_ratio : 0
    
    // Determine ranking for each signal type
    smp_rank = ""
    pivot_rank = ""
    bounce_rank = ""
    keltner_rank = ""
    smp_rank_color = color.white
    pivot_rank_color = color.white
    bounce_rank_color = color.white
    keltner_rank_color = color.white
    
    // Simple ranking system - rank signals 1-4 based on success rates
    // Rank signals that have at least 2 trades for reliability
    if total_signals >= 2 or pivot_total_signals >= 2 or bounce_total_signals >= 2 or keltner_total_signals >= 2
        // All four signals have data - simple ranking by success rate
        if smp_success_rate >= pivot_success_rate and smp_success_rate >= bounce_success_rate and smp_success_rate >= keltner_success_rate
            smp_rank := "1"
            smp_rank_color := color.yellow
            if pivot_success_rate >= bounce_success_rate and pivot_success_rate >= keltner_success_rate
                pivot_rank := "2"
                pivot_rank_color := color.gray
                if bounce_success_rate >= keltner_success_rate
                    bounce_rank := "3"
                    bounce_rank_color := color.orange
                    keltner_rank := "4"
                    keltner_rank_color := color.red
                else
                    keltner_rank := "3"
                    keltner_rank_color := color.orange
                    bounce_rank := "4"
                    bounce_rank_color := color.red
            else if bounce_success_rate >= pivot_success_rate and bounce_success_rate >= keltner_success_rate
                bounce_rank := "2"
                bounce_rank_color := color.gray
                if pivot_success_rate >= keltner_success_rate
                    pivot_rank := "3"
                    pivot_rank_color := color.orange
                    keltner_rank := "4"
                    keltner_rank_color := color.red
                else
                    keltner_rank := "3"
                    keltner_rank_color := color.orange
                    pivot_rank := "4"
                    pivot_rank_color := color.red
            else
                keltner_rank := "2"
                keltner_rank_color := color.gray
                if pivot_success_rate >= bounce_success_rate
                    pivot_rank := "3"
                    pivot_rank_color := color.orange
                    bounce_rank := "4"
                    bounce_rank_color := color.red
                else
                    bounce_rank := "3"
                    bounce_rank_color := color.orange
                    pivot_rank := "4"
                    pivot_rank_color := color.red
        else if pivot_success_rate >= smp_success_rate and pivot_success_rate >= bounce_success_rate and pivot_success_rate >= keltner_success_rate
            pivot_rank := "1"
            pivot_rank_color := color.yellow
            if smp_success_rate >= bounce_success_rate and smp_success_rate >= keltner_success_rate
                smp_rank := "2"
                smp_rank_color := color.gray
                if bounce_success_rate >= keltner_success_rate
                    bounce_rank := "3"
                    bounce_rank_color := color.orange
                    keltner_rank := "4"
                    keltner_rank_color := color.red
                else
                    keltner_rank := "3"
                    keltner_rank_color := color.orange
                    bounce_rank := "4"
                    bounce_rank_color := color.red
            else if bounce_success_rate >= smp_success_rate and bounce_success_rate >= keltner_success_rate
                bounce_rank := "2"
                bounce_rank_color := color.gray
                if smp_success_rate >= keltner_success_rate
                    smp_rank := "3"
                    smp_rank_color := color.orange
                    keltner_rank := "4"
                    keltner_rank_color := color.red
                else
                    keltner_rank := "3"
                    keltner_rank_color := color.orange
                    smp_rank := "4"
                    smp_rank_color := color.red
            else
                keltner_rank := "2"
                keltner_rank_color := color.gray
                if smp_success_rate >= bounce_success_rate
                    smp_rank := "3"
                    smp_rank_color := color.orange
                    bounce_rank := "4"
                    bounce_rank_color := color.red
                else
                    bounce_rank := "3"
                    bounce_rank_color := color.orange
                    smp_rank := "4"
                    smp_rank_color := color.red
        else if bounce_success_rate >= smp_success_rate and bounce_success_rate >= pivot_success_rate and bounce_success_rate >= keltner_success_rate
            bounce_rank := "1"
            bounce_rank_color := color.yellow
            if smp_success_rate >= pivot_success_rate and smp_success_rate >= keltner_success_rate
                smp_rank := "2"
                smp_rank_color := color.gray
                if pivot_success_rate >= keltner_success_rate
                    pivot_rank := "3"
                    pivot_rank_color := color.orange
                    keltner_rank := "4"
                    keltner_rank_color := color.red
                else
                    keltner_rank := "3"
                    keltner_rank_color := color.orange
                    pivot_rank := "4"
                    pivot_rank_color := color.red
            else if pivot_success_rate >= smp_success_rate and pivot_success_rate >= keltner_success_rate
                pivot_rank := "2"
                pivot_rank_color := color.gray
                if smp_success_rate >= keltner_success_rate
                    smp_rank := "3"
                    smp_rank_color := color.orange
                    keltner_rank := "4"
                    keltner_rank_color := color.red
                else
                    keltner_rank := "3"
                    keltner_rank_color := color.orange
                    smp_rank := "4"
                    smp_rank_color := color.red
            else
                keltner_rank := "2"
                keltner_rank_color := color.gray
                if smp_success_rate >= pivot_success_rate
                    smp_rank := "3"
                    smp_rank_color := color.orange
                    pivot_rank := "4"
                    pivot_rank_color := color.red
                else
                    pivot_rank := "3"
                    pivot_rank_color := color.orange
                    smp_rank := "4"
                    smp_rank_color := color.red
        else
            keltner_rank := "1"
            keltner_rank_color := color.yellow
            if smp_success_rate >= pivot_success_rate and smp_success_rate >= bounce_success_rate
                smp_rank := "2"
                smp_rank_color := color.gray
                if pivot_success_rate >= bounce_success_rate
                    pivot_rank := "3"
                    pivot_rank_color := color.orange
                    bounce_rank := "4"
                    bounce_rank_color := color.red
                else
                    bounce_rank := "3"
                    bounce_rank_color := color.orange
                    pivot_rank := "4"
                    pivot_rank_color := color.red
            else if pivot_success_rate >= smp_success_rate and pivot_success_rate >= bounce_success_rate
                pivot_rank := "2"
                pivot_rank_color := color.gray
                if smp_success_rate >= bounce_success_rate
                    smp_rank := "3"
                    smp_rank_color := color.orange
                    bounce_rank := "4"
                    bounce_rank_color := color.red
                else
                    bounce_rank := "3"
                    bounce_rank_color := color.orange
                    smp_rank := "4"
                    smp_rank_color := color.red
            else
                bounce_rank := "2"
                bounce_rank_color := color.gray
                if smp_success_rate >= pivot_success_rate
                    smp_rank := "3"
                    smp_rank_color := color.orange
                    pivot_rank := "4"
                    pivot_rank_color := color.red
                else
                    pivot_rank := "3"
                    pivot_rank_color := color.orange
                    smp_rank := "4"
                    smp_rank_color := color.red
    else
        // Not enough data for ranking
        smp_rank := "-"
        pivot_rank := "-"
        bounce_rank := "-"
        keltner_rank := "-"

    // Determine which signal has the highest rank (lowest number = highest rank)
    string highest_rank_signal = ""
    float highest_rank_value = 999.0
    
    // Simple approach: Any rank "1" gets highlighted with larger text and bright background

    // Syzygy Momentum Peak (SMP) Alerts row
    [setup_message, setup_color] = get_optimal_setup()

    // Calculate trend performance stats for table display
    trend_success_rate = trend_total_count > 0 ? math.round(trend_success_count / trend_total_count * 100) : na
    countertrend_success_rate = countertrend_total_count > 0 ? math.round(countertrend_success_count / countertrend_total_count * 100) : na
    trend_stop_loss_rate = trend_total_count > 0 ? math.round(trend_stop_loss_count / trend_total_count * 100) : na
    countertrend_stop_loss_rate = countertrend_total_count > 0 ? math.round(countertrend_stop_loss_count / countertrend_total_count * 100) : na

    // Determine trade direction suggestion based on performance
    trade_suggestion = ""
    if trend_total_count > 0 or countertrend_total_count > 0
        // Calculate relative performance even with limited data
        trend_performance = trend_success_rate ? trend_success_rate : 0
        countertrend_performance = countertrend_success_rate ? countertrend_success_rate : 0
        
        // Determine suggestion based on relative performance and minimum viable thresholds
        if trend_performance > countertrend_performance
            if trend_performance >= 40
                trade_suggestion := "â†’ WITH TREND (STRONG)"
            else if trend_performance >= 25
                trade_suggestion := "â†’ WITH TREND (MOD)"
            else
                trade_suggestion := "â†’ WITH TREND (WEAK)"
        else if countertrend_performance > trend_performance
            if countertrend_performance >= 40
                trade_suggestion := "â†’ AGAINST TREND (STRONG)"
            else if countertrend_performance >= 25
                trade_suggestion := "â†’ AGAINST TREND (MOD)"
            else
                trade_suggestion := "â†’ AGAINST TREND (WEAK)"
        else if trend_performance == countertrend_performance and trend_performance > 0
            if trend_performance >= 35
                trade_suggestion := "â†’ BOTH WORK (STRONG)"
            else
                trade_suggestion := "â†’ NO CLEAR DIRECTION"
        else
            // No clear winner, suggest based on which has more data
            if trend_total_count > countertrend_total_count
                trade_suggestion := "â†’ WITH TREND (WEAK)"
            else if countertrend_total_count > trend_total_count
                trade_suggestion := "â†’ AGAINST TREND (WEAK)"
            else
                trade_suggestion := "â†’ NO CLEAR DIRECTION"
    else
        trade_suggestion := "â†’ WAIT FOR MORE DATA"

    trend_stats = "Trend: " + (trend_success_rate ? str.tostring(trend_success_rate) + "%" : "N/A") + " SL:" + (trend_stop_loss_rate ? str.tostring(trend_stop_loss_rate) + "%" : "N/A")
    countertrend_stats = "CT: " + (countertrend_success_rate ? str.tostring(countertrend_success_rate) + "%" : "N/A") + " SL:" + (countertrend_stop_loss_rate ? str.tostring(countertrend_stop_loss_rate) + "%" : "N/A")

    // Calculate bars since SMP signal (start counting from bar AFTER signal)
    // Note: bars_display variables are now calculated in global scope
    
    // Highlight SMP indicator name when signal is active (synchronized with alert condition)
    smp_indicator_bgcolor = not na(smp_highlight_bars) ? color.new(color.blue, 30) : color.black
    table.cell(monitor_table, 0, 0, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    table.cell(monitor_table, 1, 0, "SMP", text_color=color.white, text_size=size.normal, bgcolor=smp_indicator_bgcolor)
    table.cell(monitor_table, 2, 0, setup_message + "\n" + trade_suggestion, text_color=setup_color == color.lime or setup_color == color.green ? color.black : color.white, bgcolor=setup_color, text_size=size.normal)
    table.cell(monitor_table, 3, 0, smp_rank, text_color=smp_rank_color, text_size=smp_rank == "1" ? size.large : size.normal, bgcolor=smp_rank == "1" ? color.orange : color.black)
    table.cell(monitor_table, 4, 0, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // SMP Performance row - only show if enabled
    if show_performance_data
        trend_performance_display = trend_stats + " | " + countertrend_stats
        table.cell(monitor_table, 0, 1, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 1, 1, "SMP Perf", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 2, 1, trend_performance_display, text_color=color.white, bgcolor=color.blue, text_size=size.normal)
        table.cell(monitor_table, 3, 1, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 4, 1, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Syzygy Pivot Alerts row
    // Calculate pivot trade direction suggestion
    pivot_trade_suggestion = ""
    if pivot_trend_total_count > 0 or pivot_countertrend_total_count > 0
        pivot_trend_success_rate = pivot_trend_total_count > 0 ? math.round(pivot_trend_success_count / pivot_trend_total_count * 100) : na
        pivot_countertrend_success_rate = pivot_countertrend_total_count > 0 ? math.round(pivot_countertrend_success_count / pivot_countertrend_total_count * 100) : na
        
        // Calculate relative performance even with limited data
        pivot_trend_performance = pivot_trend_success_rate ? pivot_trend_success_rate : 0
        pivot_countertrend_performance = pivot_countertrend_success_rate ? pivot_countertrend_success_rate : 0
        
        // Determine suggestion based on relative performance and minimum viable thresholds
        if pivot_trend_performance > pivot_countertrend_performance
            if pivot_trend_performance >= 40
                pivot_trade_suggestion := "â†’ FOLLOW (STRONG)"
            else if pivot_trend_performance >= 25
                pivot_trade_suggestion := "â†’ FOLLOW (MOD)"
            else
                pivot_trade_suggestion := "â†’ FOLLOW (WEAK)"
        else if pivot_countertrend_performance > pivot_trend_performance
            if pivot_countertrend_performance >= 40
                pivot_trade_suggestion := "â†’ AGAINST (STRONG)"
            else if pivot_countertrend_performance >= 25
                pivot_trade_suggestion := "â†’ AGAINST (MOD)"
            else
                pivot_trade_suggestion := "â†’ AGAINST (WEAK)"
        else if pivot_trend_performance == pivot_countertrend_performance and pivot_trend_performance > 0
            if pivot_trend_performance >= 35
                pivot_trade_suggestion := "â†’ BOTH WORK (STRONG)"
            else
                pivot_trade_suggestion := "â†’ NO CLEAR STRATEGY"
        else
            // No clear winner, suggest based on which has more data
            if pivot_trend_total_count > pivot_countertrend_total_count
                pivot_trade_suggestion := "â†’ FOLLOW (WEAK)"
            else if pivot_countertrend_total_count > pivot_trend_total_count
                pivot_trade_suggestion := "â†’ AGAINST (WEAK)"
            else
                pivot_trade_suggestion := "â†’ NO CLEAR STRATEGY"
    else
        pivot_trade_suggestion := "â†’ WAIT FOR MORE DATA"

    // Calculate bars since Pivot signal (start counting from bar AFTER signal)
    bars_since_pivot = last_pivot_signal_bar > 0 ? bar_index - last_pivot_signal_bar - 1 : 999
    pivot_bars_display = bars_since_pivot <= 3 ? str.tostring(bars_since_pivot) : ">3"
    pivot_bars_color = bars_since_pivot <= 3 ? color.yellow : color.gray
    
    combined_pivot_trends = (lastAlertType == "None" ? "None" : barsSinceLastAlert == 0 ? lastAlertType + "ðŸŸ¡" : lastAlertType) + "\n" + pivot_trade_suggestion
    // Highlight Pivot indicator name when signal is active (synchronized with alert condition)
    pivot_indicator_bgcolor = not na(pivot_highlight_bars) ? color.new(color.teal, 30) : color.black
    table.cell(monitor_table, 0, 2, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    table.cell(monitor_table, 1, 2, "Pivot", text_color=color.white, text_size=size.normal, bgcolor=pivot_indicator_bgcolor)
    table.cell(monitor_table, 2, 2, combined_pivot_trends, text_color=color.white, bgcolor=lastAlertType == "LONG" ? color.teal : lastAlertType == "SHORT" ? color.maroon : color.gray, text_size=size.normal)
    table.cell(monitor_table, 3, 2, pivot_rank, text_color=pivot_rank_color, text_size=pivot_rank == "1" ? size.large : size.normal, bgcolor=pivot_rank == "1" ? color.orange : color.black)
    table.cell(monitor_table, 4, 2, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Pivot Performance row - only show if enabled
    if show_performance_data
        // Calculate pivot performance stats
        pivot_trend_success_rate = pivot_trend_total_count > 0 ? math.round(pivot_trend_success_count / pivot_trend_total_count * 100) : na
        pivot_countertrend_success_rate = pivot_countertrend_total_count > 0 ? math.round(pivot_countertrend_success_count / pivot_countertrend_total_count * 100) : na
        pivot_trend_stop_loss_rate = pivot_trend_total_count > 0 ? math.round(pivot_trend_stop_loss_count / pivot_trend_total_count * 100) : na
        pivot_countertrend_stop_loss_rate = pivot_countertrend_total_count > 0 ? math.round(pivot_countertrend_stop_loss_count / pivot_countertrend_total_count * 100) : na
        
        // Determine pivot trade direction suggestion based on performance
        pivot_trade_suggestion = ""
        if pivot_trend_total_count > 0 or pivot_countertrend_total_count > 0
            // Calculate relative performance even with limited data
            pivot_trend_performance = pivot_trend_success_rate ? pivot_trend_success_rate : 0
            pivot_countertrend_performance = pivot_countertrend_success_rate ? pivot_countertrend_success_rate : 0
            
            // Determine suggestion based on relative performance and minimum viable thresholds
            if pivot_trend_performance > pivot_countertrend_performance
                if pivot_trend_performance >= 40
                    pivot_trade_suggestion := "â†’ TREND"
                else if pivot_trend_performance >= 25
                    pivot_trade_suggestion := "â†’ TREND*"
                else
                    pivot_trade_suggestion := "â†’ TREND?"
            else if pivot_countertrend_performance > pivot_trend_performance
                if pivot_countertrend_performance >= 40
                    pivot_trade_suggestion := "â†’ COUNTER"
                else if pivot_countertrend_performance >= 25
                    pivot_trade_suggestion := "â†’ COUNTER*"
                else
                    pivot_trade_suggestion := "â†’ COUNTER?"
            else if pivot_trend_performance == pivot_countertrend_performance and pivot_trend_performance > 0
                if pivot_trend_performance >= 35
                    pivot_trade_suggestion := "â†’ BOTH"
                else
                    pivot_trade_suggestion := "â†’ NEUTRAL"
            else
                // No clear winner, suggest based on which has more data
                if pivot_trend_total_count > pivot_countertrend_total_count
                    pivot_trade_suggestion := "â†’ TREND?"
                else if pivot_countertrend_total_count > pivot_trend_total_count
                    pivot_trade_suggestion := "â†’ COUNTER?"
                else
                    pivot_trade_suggestion := "â†’ NEUTRAL"
        else
            pivot_trade_suggestion := "â†’ WAIT"
        
        pivot_trend_stats = "Trend: " + (pivot_trend_success_rate ? str.tostring(pivot_trend_success_rate) + "%" : "N/A") + " SL:" + (pivot_trend_stop_loss_rate ? str.tostring(pivot_trend_stop_loss_rate) + "%" : "N/A")
        pivot_countertrend_stats = "CT: " + (pivot_countertrend_success_rate ? str.tostring(pivot_countertrend_success_rate) + "%" : "N/A") + " SL:" + (pivot_countertrend_stop_loss_rate ? str.tostring(pivot_countertrend_stop_loss_rate) + "%" : "N/A")
        pivot_performance_display = pivot_trend_stats + " | " + pivot_countertrend_stats + "\n" + pivot_trade_suggestion
        
        table.cell(monitor_table, 0, 3, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 1, 3, "Pivot Perf", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 2, 3, pivot_performance_display, text_color=color.white, bgcolor=color.teal, text_size=size.normal)
        table.cell(monitor_table, 3, 3, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 4, 3, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Pullback Detection row - only show if enabled
    if enable_pullback_detection
        // Calculate pullback display text
        pullback_display = ""
        if long_bounce_detected
            pullback_display := "LAST: BUY BOUNCE"
        else if short_bounce_detected
            pullback_display := "LAST: SELL BOUNCE"
        else if long_pullback_detected
            pullback_display := "LAST: BUY PULLBACK"
        else if short_pullback_detected
            pullback_display := "LAST: SELL PULLBACK"
        else
            pullback_display := "None"
        
        // Calculate bounce trade direction suggestion
        bounce_trade_suggestion = ""
        if bounce_trend_total_count > 0 or bounce_countertrend_total_count > 0
            bounce_trend_success_rate = bounce_trend_total_count > 0 ? math.round(bounce_trend_success_count / bounce_trend_total_count * 100) : na
            bounce_countertrend_success_rate = bounce_countertrend_total_count > 0 ? math.round(bounce_countertrend_success_count / bounce_countertrend_total_count * 100) : na
            
            // Calculate relative performance even with limited data
            bounce_trend_performance = bounce_trend_success_rate ? bounce_trend_success_rate : 0
            bounce_countertrend_performance = bounce_countertrend_success_rate ? bounce_countertrend_success_rate : 0
            
            // Determine suggestion based on relative performance and minimum viable thresholds
            if bounce_trend_performance > bounce_countertrend_performance
                if bounce_trend_performance >= 40
                    bounce_trade_suggestion := "â†’ FOLLOW (STRONG)"
                else if bounce_trend_performance >= 25
                    bounce_trade_suggestion := "â†’ FOLLOW (MOD)"
                else
                    bounce_trade_suggestion := "â†’ FOLLOW (WEAK)"
            else if bounce_countertrend_performance > bounce_trend_performance
                if bounce_countertrend_performance >= 40
                    bounce_trade_suggestion := "â†’ AGAINST (STRONG)"
                else if bounce_countertrend_performance >= 25
                    bounce_trade_suggestion := "â†’ AGAINST (MOD)"
                else
                    bounce_trade_suggestion := "â†’ AGAINST (WEAK)"
            else if bounce_trend_performance == bounce_countertrend_performance and bounce_trend_performance > 0
                if bounce_trend_performance >= 35
                    bounce_trade_suggestion := "â†’ BOTH WORK (STRONG)"
                else
                    bounce_trade_suggestion := "â†’ NO CLEAR STRATEGY"
            else
                // No clear winner, suggest based on which has more data
                if bounce_trend_total_count > bounce_countertrend_total_count
                    bounce_trade_suggestion := "â†’ FOLLOW (WEAK)"
                else if bounce_countertrend_total_count > bounce_trend_total_count
                    bounce_trade_suggestion := "â†’ AGAINST (WEAK)"
                else
                    bounce_trade_suggestion := "â†’ NO CLEAR STRATEGY"
        else
            bounce_trade_suggestion := "â†’ WAIT FOR MORE DATA"
        
        pullback_combined_info = pullback_display + "\n" + bounce_trade_suggestion
        
        // Set pullback color based on detection status
        pullback_color = long_bounce_detected ? color.aqua : short_bounce_detected ? color.fuchsia : long_pullback_detected ? color.new(color.aqua, 50) : short_pullback_detected ? color.new(color.fuchsia, 50) : color.gray
        
        // Calculate bars since Bounce signal (start counting from bar AFTER signal)
        bars_since_bounce = last_bounce_signal_bar > 0 ? bar_index - last_bounce_signal_bar - 1 : 999
        bounce_bars_display = bars_since_bounce <= 3 ? str.tostring(bars_since_bounce) : ">3"
        bounce_bars_color = bars_since_bounce <= 3 ? color.yellow : color.gray
        
        // Highlight Bounce indicator name when signal is active (synchronized with alert condition)
        bounce_indicator_bgcolor = not na(bounce_highlight_bars) ? color.new(color.fuchsia, 30) : color.black
        table.cell(monitor_table, 0, 4, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 1, 4, "Pivot Bounce", text_color=color.white, text_size=size.normal, bgcolor=bounce_indicator_bgcolor)
        table.cell(monitor_table, 2, 4, pullback_combined_info, text_color=color.white, bgcolor=pullback_color, text_size=size.normal)
        table.cell(monitor_table, 3, 4, bounce_rank, text_color=bounce_rank_color, text_size=bounce_rank == "1" ? size.large : size.normal, bgcolor=bounce_rank == "1" ? color.orange : color.black)
        table.cell(monitor_table, 4, 4, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Bounce Performance row - only show if enabled
    if show_performance_data and enable_pullback_detection
        // Calculate bounce performance stats
        bounce_trend_success_rate = bounce_trend_total_count > 0 ? math.round(bounce_trend_success_count / bounce_trend_total_count * 100) : na
        bounce_countertrend_success_rate = bounce_countertrend_total_count > 0 ? math.round(bounce_countertrend_success_count / bounce_countertrend_total_count * 100) : na
        bounce_trend_stop_loss_rate = bounce_trend_total_count > 0 ? math.round(bounce_trend_stop_loss_count / bounce_trend_total_count * 100) : na
        bounce_countertrend_stop_loss_rate = bounce_countertrend_total_count > 0 ? math.round(bounce_countertrend_stop_loss_count / bounce_countertrend_total_count * 100) : na
        
        // Determine bounce trade direction suggestion based on performance
        bounce_trade_suggestion = ""
        if bounce_trend_total_count > 0 or bounce_countertrend_total_count > 0
            // Calculate relative performance even with limited data
            bounce_trend_performance = bounce_trend_success_rate ? bounce_trend_success_rate : 0
            bounce_countertrend_performance = bounce_countertrend_success_rate ? bounce_countertrend_success_rate : 0
            
            // Determine suggestion based on relative performance and minimum viable thresholds
            if bounce_trend_performance > bounce_countertrend_performance
                if bounce_trend_performance >= 40
                    bounce_trade_suggestion := "â†’ FOLLOW (STRONG)"
                else if bounce_trend_performance >= 25
                    bounce_trade_suggestion := "â†’ FOLLOW (MOD)"
                else
                    bounce_trade_suggestion := "â†’ FOLLOW (WEAK)"
            else if bounce_countertrend_performance > bounce_trend_performance
                if bounce_countertrend_performance >= 40
                    bounce_trade_suggestion := "â†’ AGAINST (STRONG)"
                else if bounce_countertrend_performance >= 25
                    bounce_trade_suggestion := "â†’ AGAINST (MOD)"
                else
                    bounce_trade_suggestion := "â†’ AGAINST (WEAK)"
            else if bounce_trend_performance == bounce_countertrend_performance and bounce_trend_performance > 0
                if bounce_trend_performance >= 35
                    bounce_trade_suggestion := "â†’ BOTH WORK (STRONG)"
                else
                    bounce_trade_suggestion := "â†’ NO CLEAR STRATEGY"
            else
                // No clear winner, suggest based on which has more data
                if bounce_trend_total_count > bounce_countertrend_total_count
                    bounce_trade_suggestion := "â†’ FOLLOW (WEAK)"
                else if bounce_countertrend_total_count > bounce_trend_total_count
                    bounce_trade_suggestion := "â†’ AGAINST (WEAK)"
                else
                    bounce_trade_suggestion := "â†’ NO CLEAR STRATEGY"
        else
            bounce_trade_suggestion := "â†’ WAIT FOR MORE DATA"
        
        bounce_trend_stats = "Trend: " + (bounce_trend_success_rate ? str.tostring(bounce_trend_success_rate) + "%" : "N/A") + " SL:" + (bounce_trend_stop_loss_rate ? str.tostring(bounce_trend_stop_loss_rate) + "%" : "N/A")
        bounce_countertrend_stats = "CT: " + (bounce_countertrend_success_rate ? str.tostring(bounce_countertrend_success_rate) + "%" : "N/A") + " SL:" + (bounce_countertrend_stop_loss_rate ? str.tostring(bounce_countertrend_stop_loss_rate) + "%" : "N/A")
        bounce_performance_display = bounce_trend_stats + " | " + bounce_countertrend_stats + "\n" + bounce_trade_suggestion
        
        table.cell(monitor_table, 0, 5, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 1, 5, "Bounce Perf", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 2, 5, bounce_performance_display, text_color=color.white, bgcolor=color.fuchsia, text_size=size.normal)
        table.cell(monitor_table, 3, 5, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 4, 5, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Calculate bars since Keltner signal (for use in multiple rows) (start counting from bar AFTER signal)
    bars_since_keltner = last_keltner_signal_bar > 0 ? bar_index - last_keltner_signal_bar - 1 : 999
    keltner_bars_display = bars_since_keltner <= 3 ? str.tostring(bars_since_keltner) : ">3"
    keltner_bars_color = bars_since_keltner <= 3 ? color.yellow : color.gray

    // Keltner Breakout row - only show if performance data is enabled and Keltner channels are enabled
    if show_performance_data and enable_keltner_channels
        // Calculate Keltner performance stats
        keltner_trend_success_rate = keltner_trend_total_count > 0 ? math.round(keltner_trend_success_count / keltner_trend_total_count * 100) : na
        keltner_countertrend_success_rate = keltner_countertrend_total_count > 0 ? math.round(keltner_countertrend_success_count / keltner_countertrend_total_count * 100) : na
        keltner_trend_stop_loss_rate = keltner_trend_total_count > 0 ? math.round(keltner_trend_stop_loss_count / keltner_trend_total_count * 100) : na
        keltner_countertrend_stop_loss_rate = keltner_countertrend_total_count > 0 ? math.round(keltner_countertrend_stop_loss_count / keltner_countertrend_total_count * 100) : na
        
        // Determine Keltner trade direction suggestion based on performance
        keltner_trade_suggestion = ""
        if keltner_trend_total_count > 0 or keltner_countertrend_total_count > 0
            // Calculate relative performance even with limited data
            keltner_trend_performance = keltner_trend_success_rate ? keltner_trend_success_rate : 0
            keltner_countertrend_performance = keltner_countertrend_success_rate ? keltner_countertrend_success_rate : 0
            
            // Determine suggestion based on relative performance and minimum viable thresholds
            if keltner_trend_performance > keltner_countertrend_performance
                if keltner_trend_performance >= 40
                    keltner_trade_suggestion := "â†’ RANGE (STRONG)"
                else if keltner_trend_performance >= 25
                    keltner_trade_suggestion := "â†’ RANGE (MOD)"
                else
                    keltner_trade_suggestion := "â†’ RANGE (WEAK)"
            else if keltner_countertrend_performance > keltner_trend_performance
                if keltner_countertrend_performance >= 40
                    keltner_trade_suggestion := "â†’ TREND (STRONG)"
                else if keltner_countertrend_performance >= 25
                    keltner_trade_suggestion := "â†’ TREND (MOD)"
                else
                    keltner_trade_suggestion := "â†’ TREND (WEAK)"
            else if keltner_trend_performance == keltner_countertrend_performance and keltner_trend_performance > 0
                if keltner_trend_performance >= 35
                    keltner_trade_suggestion := "â†’ BOTH WORK (STRONG)"
                else
                    keltner_trade_suggestion := "â†’ NO CLEAR STRATEGY"
            else
                // No clear winner, suggest based on which has more data
                if keltner_trend_total_count > keltner_countertrend_total_count
                    keltner_trade_suggestion := "â†’ RANGE (WEAK)"
                else if keltner_countertrend_total_count > keltner_trend_total_count
                    keltner_trade_suggestion := "â†’ TREND (WEAK)"
                else
                    keltner_trade_suggestion := "â†’ NO CLEAR STRATEGY"
        else
            keltner_trade_suggestion := "â†’ WAIT FOR MORE DATA"
        
        keltner_trend_stats = "Range: " + (keltner_trend_success_rate ? str.tostring(keltner_trend_success_rate) + "%" : "N/A") + " SL:" + (keltner_trend_stop_loss_rate ? str.tostring(keltner_trend_stop_loss_rate) + "%" : "N/A")
        keltner_countertrend_stats = "Trend: " + (keltner_countertrend_success_rate ? str.tostring(keltner_countertrend_success_rate) + "%" : "N/A") + " SL:" + (keltner_countertrend_stop_loss_rate ? str.tostring(keltner_countertrend_stop_loss_rate) + "%" : "N/A")
        keltner_performance_display = keltner_trend_stats + " | " + keltner_countertrend_stats + "\n" + keltner_trade_suggestion
        
        // Calculate bars since Keltner signal (start counting from bar AFTER signal)
        bars_since_keltner = last_keltner_signal_bar > 0 ? bar_index - last_keltner_signal_bar - 1 : 999
        keltner_bars_display := bars_since_keltner <= 3 ? str.tostring(bars_since_keltner) : ">3"
        keltner_bars_color := bars_since_keltner <= 3 ? color.yellow : color.gray
        
        // Highlight Keltner indicator name when signal is active (within 3 bars)
        keltner_indicator_bgcolor = not na(keltner_highlight_bars) ? color.new(color.orange, 30) : color.black
        
        table.cell(monitor_table, 0, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 1, 6, "Keltner Breakout", text_color=color.white, text_size=size.normal, bgcolor=keltner_indicator_bgcolor)
        table.cell(monitor_table, 2, 6, keltner_performance_display, text_color=color.white, bgcolor=color.orange, text_size=size.normal)
        table.cell(monitor_table, 3, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 4, 6, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Signal Ranking row - shows which signal type is performing best
    // NOTE: Ranking now integrated into column 2 of each signal row

    // Keltner Breakout Alert row - only show if enabled
    if show_market_structure
        // Highlight Keltner Breakout Alert row when Keltner breakout signal is active (synchronized with alert condition)
        keltner_alert_bgcolor = not na(keltner_highlight_bars) ? color.new(color.orange, 30) : color.black
        keltner_alert_status = keltner_upper_cross_up ? "BULLISH" : keltner_lower_cross_down ? "BEARISH" : "INACTIVE"
        keltner_alert_color = keltner_upper_cross_up ? color.green : keltner_lower_cross_down ? color.red : color.gray
        
        // Keltner trading direction recommendation based on trend vs counter-trend performance
        keltner_trend_success_rate = keltner_trend_total_count > 0 ? math.round(keltner_trend_success_count / keltner_trend_total_count * 100) : na
        keltner_countertrend_success_rate = keltner_countertrend_total_count > 0 ? math.round(keltner_countertrend_success_count / keltner_countertrend_total_count * 100) : na
        
        // Determine trading direction recommendation
        strategy_recommendation = ""
        strategy_recommendation_color = color.gray
        
        if keltner_trend_total_count > 0 or keltner_countertrend_total_count > 0
            keltner_trend_performance = keltner_trend_success_rate ? keltner_trend_success_rate : 0
            keltner_countertrend_performance = keltner_countertrend_success_rate ? keltner_countertrend_success_rate : 0
            
            if keltner_trend_performance > keltner_countertrend_performance
                if keltner_trend_performance >= 40
                    strategy_recommendation := "â†’ TREND (STRONG)"
                    strategy_recommendation_color := color.green
                else if keltner_trend_performance >= 25
                    strategy_recommendation := "â†’ TREND (MOD)"
                    strategy_recommendation_color := color.lime
                else
                    strategy_recommendation := "â†’ TREND (WEAK)"
                    strategy_recommendation_color := color.yellow
            else if keltner_countertrend_performance > keltner_trend_performance
                if keltner_countertrend_performance >= 40
                    strategy_recommendation := "â†’ COUNTER (STRONG)"
                    strategy_recommendation_color := color.red
                else if keltner_countertrend_performance >= 25
                    strategy_recommendation := "â†’ COUNTER (MOD)"
                    strategy_recommendation_color := color.orange
                else
                    strategy_recommendation := "â†’ COUNTER (WEAK)"
                    strategy_recommendation_color := color.yellow
            else if keltner_trend_performance == keltner_countertrend_performance and keltner_trend_performance > 0
                if keltner_trend_performance >= 35
                    strategy_recommendation := "â†’ BOTH WORK"
                    strategy_recommendation_color := color.purple
                else
                    strategy_recommendation := "â†’ NO CLEAR"
                    strategy_recommendation_color := color.gray
            else
                // No clear winner, suggest based on which has more data
                if keltner_trend_total_count > keltner_countertrend_total_count
                    strategy_recommendation := "â†’ TREND (WEAK)"
                    strategy_recommendation_color := color.yellow
                else if keltner_countertrend_total_count > keltner_trend_total_count
                    strategy_recommendation := "â†’ COUNTER (WEAK)"
                    strategy_recommendation_color := color.yellow
                else
                    strategy_recommendation := "â†’ WAIT FOR DATA"
                    strategy_recommendation_color := color.gray
        else
            strategy_recommendation := "â†’ NO DATA"
            strategy_recommendation_color := color.gray
        
        table.cell(monitor_table, 0, 7, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(monitor_table, 1, 7, "Keltner Breakout", text_color=color.white, text_size=size.normal, bgcolor=keltner_alert_bgcolor)
        table.cell(monitor_table, 2, 7, strategy_recommendation, text_color=color.white, text_size=size.normal, bgcolor=strategy_recommendation_color)
        table.cell(monitor_table, 3, 7, keltner_rank, text_color=keltner_rank_color, text_size=keltner_rank == "1" ? size.large : size.normal, bgcolor=keltner_rank == "1" ? color.orange : color.black)
        table.cell(monitor_table, 4, 7, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)


    // Table name row at the bottom
    table.cell(monitor_table, 0, 8, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    table.cell(monitor_table, 1, 8, "5 x 5 Stop", text_color=color.white, text_size=size.large, bgcolor=color.black)
    table.cell(monitor_table, 2, 8, "Strategy Table", text_color=color.white, text_size=size.large, bgcolor=color.black)
    table.cell(monitor_table, 3, 8, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    table.cell(monitor_table, 4, 8, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)



// ================================== INDICATORS TABLE ================================================================
// Create a separate table for indicator information in the middle bottom of the chart --------------------------------
// Calculate indicator values for the new table
rsi_display = str.tostring(math.round(rsi_value, 1)) + (rsi_value <= rsi_oversold ? "ðŸŸ¢" : rsi_value >= rsi_overbought ? "ðŸ”´" : "ðŸ‡¨ðŸ‡­")
volume_ratio = volume / volume_ma
volume_status = volume_ratio <= 0.5 ? "LðŸ“‰" : volume_ratio <= 1.0 ? "NðŸ“Š" : volume_ratio <= volume_threshold_multiplier ? "AðŸ“ˆ" : "HðŸš€"

combined_indicators = (plus_di > minus_di ? "BullðŸŸ¢" : "BearðŸ”´") + " ADX:" + (adx_value >= adx_threshold ? "SðŸ’ª" : "WðŸ¥º") + " RSI:" + rsi_display + " Vol:" + volume_status
rsi_gradient_color = get_rsi_gradient_color(rsi_value, rsi_oversold, rsi_overbought)

// Create indicators table in middle bottom
var table indicators_table = table.new(position = position.bottom_center, columns = 1, rows = 4, bgcolor = color.rgb(0, 0, 0, 80), border_width = 1)

// Status row (moved from 5 x 5 table)
volume_filter_status = enable_volume_filter ? "âœ…" : "âŒ"
status_display = (enable_alerts ? "âœ…" : "âŒ") + " " + trading_style + " Vol:" + volume_filter_status
table.cell(indicators_table, 0, 0, status_display, bgcolor=color.rgb(108, 107, 111), text_color=get_color_brightness(color.r(color.rgb(108, 107, 111)), color.g(color.rgb(108, 107, 111)), color.b(color.rgb(108, 107, 111))) > 128 ? color.black : color.white, text_size=size.normal)

// Display combined indicators
table.cell(indicators_table, 0, 1, combined_indicators, bgcolor=rsi_gradient_color, text_color=get_color_brightness(color.r(rsi_gradient_color), color.g(rsi_gradient_color), color.b(rsi_gradient_color)) > 128 ? color.black : color.white, text_size=size.normal)

// Current Market row (copy from 5 x 5 table)
table.cell(indicators_table, 0, 2, "Current Market: " + market_structure_display, text_color=structure_color == color.yellow ? color.black : color.white, text_size=size.normal, bgcolor=structure_color)

// Table name row
table.cell(indicators_table, 0, 3, "Indicators Table", text_color=color.white, text_size=size.large, bgcolor=color.black)

// ================================== THREE BAR STRATEGY PERFORMANCE TABLE =============================================
// Display three bar strategy performance table showing 3-bar pip movement for each signal type -------------------------
if show_pip_capture_table
    // Calculate bars since signals for the Three Bar table
    bars_since_smp = last_smp_signal_bar > 0 ? bar_index - last_smp_signal_bar - 1 : 999
    smp_bars_display := bars_since_smp <= 3 ? str.tostring(bars_since_smp) : ">3"
    smp_bars_color := bars_since_smp <= 3 ? color.yellow : color.gray
    
    bars_since_pivot = last_pivot_signal_bar > 0 ? bar_index - last_pivot_signal_bar - 1 : 999
    pivot_bars_display := bars_since_pivot <= 3 ? str.tostring(bars_since_pivot) : ">3"
    pivot_bars_color := bars_since_pivot <= 3 ? color.yellow : color.gray
    
    bars_since_bounce = last_bounce_signal_bar > 0 ? bar_index - last_bounce_signal_bar - 1 : 999
    bounce_bars_display := bars_since_bounce <= 3 ? str.tostring(bars_since_bounce) : ">3"
    bounce_bars_color := bars_since_bounce <= 3 ? color.yellow : color.gray
    
    bars_since_keltner = last_keltner_signal_bar > 0 ? bar_index - last_keltner_signal_bar - 1 : 999
    keltner_bars_display := bars_since_keltner <= 3 ? str.tostring(bars_since_keltner) : ">3"
    keltner_bars_color := bars_since_keltner <= 3 ? color.yellow : color.gray

    // Win percentages are calculated in the pip capture section using persistent variables
    
    // Enhanced ranking system with tie handling - rank signals 1-4 based on win percentage (rank signals with at least 2 trades)
    if smp_total_captures >= 2 or pivot_total_captures >= 2 or bounce_total_captures >= 2 or keltner_total_captures >= 2
        // Get win percentages for ranking (use -999.0 for signals with insufficient data)
        smp_win_rank_value = smp_total_captures >= 2 ? smp_win_percentage : -999.0
        pivot_win_rank_value = pivot_total_captures >= 2 ? pivot_win_percentage : -999.0
        bounce_win_rank_value = bounce_total_captures >= 2 ? bounce_win_percentage : -999.0
        keltner_win_rank_value = keltner_total_captures >= 2 ? keltner_win_percentage : -999.0
        
        // Count how many signals have valid data
        valid_count = 0
        if smp_win_rank_value > -999.0
            valid_count := valid_count + 1
        if pivot_win_rank_value > -999.0
            valid_count := valid_count + 1
        if bounce_win_rank_value > -999.0
            valid_count := valid_count + 1
        if keltner_win_rank_value > -999.0
            valid_count := valid_count + 1
        
        // FIXED: Simplified ranking logic that assigns unique ranks based on actual win percentages
        if valid_count >= 1
            // Initialize all ranks to empty
            smp_pip_rank := ""
            pivot_pip_rank := ""
            bounce_pip_rank := ""
            keltner_pip_rank := ""
            
            // Simple ranking by comparing win percentages directly
            // Find the highest win percentage
            float highest_win = -999.0
            if smp_win_rank_value > highest_win
                highest_win := smp_win_rank_value
            if pivot_win_rank_value > highest_win
                highest_win := pivot_win_rank_value
            if bounce_win_rank_value > highest_win
                highest_win := bounce_win_rank_value
            if keltner_win_rank_value > highest_win
                highest_win := keltner_win_rank_value
            
            // Assign rank 1 to the highest
            if smp_win_rank_value == highest_win
                smp_pip_rank := "1"
                smp_pip_rank_color := color.yellow
            if pivot_win_rank_value == highest_win
                pivot_pip_rank := "1"
                pivot_pip_rank_color := color.yellow
            if bounce_win_rank_value == highest_win
                bounce_pip_rank := "1"
                bounce_pip_rank_color := color.yellow
            if keltner_win_rank_value == highest_win
                keltner_pip_rank := "1"
                keltner_pip_rank_color := color.yellow
            
            // Find second highest (among remaining signals)
            float second_highest = -999.0
            if smp_win_rank_value < highest_win and smp_win_rank_value > second_highest
                second_highest := smp_win_rank_value
            if pivot_win_rank_value < highest_win and pivot_win_rank_value > second_highest
                second_highest := pivot_win_rank_value
            if bounce_win_rank_value < highest_win and bounce_win_rank_value > second_highest
                second_highest := bounce_win_rank_value
            if keltner_win_rank_value < highest_win and keltner_win_rank_value > second_highest
                second_highest := keltner_win_rank_value
            
            // Assign rank 2
            if smp_win_rank_value == second_highest and smp_pip_rank != "1"
                smp_pip_rank := "2"
                smp_pip_rank_color := color.gray
            if pivot_win_rank_value == second_highest and pivot_pip_rank != "1"
                pivot_pip_rank := "2"
                pivot_pip_rank_color := color.gray
            if bounce_win_rank_value == second_highest and bounce_pip_rank != "1"
                bounce_pip_rank := "2"
                bounce_pip_rank_color := color.gray
            if keltner_win_rank_value == second_highest and keltner_pip_rank != "1"
                keltner_pip_rank := "2"
                keltner_pip_rank_color := color.gray
            
            // Find third highest (among remaining signals)
            float third_highest = -999.0
            if smp_win_rank_value < second_highest and smp_win_rank_value > third_highest
                third_highest := smp_win_rank_value
            if pivot_win_rank_value < second_highest and pivot_win_rank_value > third_highest
                third_highest := pivot_win_rank_value
            if bounce_win_rank_value < second_highest and bounce_win_rank_value > third_highest
                third_highest := bounce_win_rank_value
            if keltner_win_rank_value < second_highest and keltner_win_rank_value > third_highest
                third_highest := keltner_win_rank_value
            
            // Assign rank 3
            if smp_win_rank_value == third_highest and smp_pip_rank != "1" and smp_pip_rank != "2"
                smp_pip_rank := "3"
                smp_pip_rank_color := color.orange
            if pivot_win_rank_value == third_highest and pivot_pip_rank != "1" and pivot_pip_rank != "2"
                pivot_pip_rank := "3"
                pivot_pip_rank_color := color.orange
            if bounce_win_rank_value == third_highest and bounce_pip_rank != "1" and bounce_pip_rank != "2"
                bounce_pip_rank := "3"
                bounce_pip_rank_color := color.orange
            if keltner_win_rank_value == third_highest and keltner_pip_rank != "1" and keltner_pip_rank != "2"
                keltner_pip_rank := "3"
                keltner_pip_rank_color := color.orange
            
            // Assign rank 4 to remaining signals
            if smp_pip_rank == ""
                smp_pip_rank := "4"
                smp_pip_rank_color := color.red
            if pivot_pip_rank == ""
                pivot_pip_rank := "4"
                pivot_pip_rank_color := color.red
            if bounce_pip_rank == ""
                bounce_pip_rank := "4"
                bounce_pip_rank_color := color.red
            if keltner_pip_rank == ""
                keltner_pip_rank := "4"
                keltner_pip_rank_color := color.red

    else
        // Not enough data for ranking
        smp_pip_rank := "-"
        pivot_pip_rank := "-"
        bounce_pip_rank := "-"
        keltner_pip_rank := "-"
    // Create three bar strategy performance table with position based on user selection (create once)
    var table pip_capture_table = table.new(position = pip_table_position == "top_right" ? 
     position.top_right : pip_table_position == "top_left" ? position.top_left : pip_table_position == "bottom_left" ? 
     position.bottom_left : position.bottom_right, columns = show_pip_performance_data ? 7 : 5, rows = 7, bgcolor = color.rgb(0, 0, 0, 80), 
     border_width = 1)

    // Table header
    table.cell(pip_capture_table, 0, 0, "Signal Type", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    if show_pip_performance_data
        table.cell(pip_capture_table, 1, 0, "Avg Pips (3 bars)", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 2, 0, "Total Trades", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 3, 0, "Win %", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 4, 0, "Rank", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 5, 0, "Bars", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 6, 0, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    else
        table.cell(pip_capture_table, 1, 0, "Rank", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 2, 0, "Bars", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 3, 0, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // SMP row
    smp_pip_color = smp_avg_pip_capture > 0 ? color.green : smp_avg_pip_capture < 0 ? color.red : color.gray
    smp_win_color = smp_win_percentage >= 60 ? color.green : smp_win_percentage >= 40 ? color.yellow : color.red
    // Highlight SMP indicator name when signal is active (synchronized with alert condition)
    smp_indicator_bgcolor = not na(smp_highlight_bars) ? color.new(color.blue, 30) : color.black
    table.cell(pip_capture_table, 0, 1, "SMP", text_color=color.white, text_size=size.normal, bgcolor=smp_indicator_bgcolor)
    if show_pip_performance_data
        table.cell(pip_capture_table, 1, 1, str.tostring(math.round(smp_avg_pip_capture, 1)), text_color=color.white, text_size=size.normal, bgcolor=smp_pip_color)
        table.cell(pip_capture_table, 2, 1, str.tostring(smp_total_captures), text_color=color.white, text_size=size.normal, bgcolor=color.blue)
        table.cell(pip_capture_table, 3, 1, str.tostring(math.round(smp_win_percentage, 1)) + "%", text_color=smp_win_color == color.yellow ? color.black : color.white, text_size=size.normal, bgcolor=smp_win_color)
        table.cell(pip_capture_table, 4, 1, smp_pip_rank, text_color=smp_pip_rank_color, text_size=smp_pip_rank == "1" ? size.large : size.normal, bgcolor=smp_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        smp_bars_highlight = smp_bars_display == "3" ? color.new(color.lime, 30) : color.black
        smp_bars_text_size = smp_bars_display == "3" ? size.large : size.normal
        smp_bars_text_color = smp_bars_display == "3" ? color.black : smp_bars_color
        table.cell(pip_capture_table, 5, 1, smp_bars_display, text_color=smp_bars_text_color, text_size=smp_bars_text_size, bgcolor=smp_bars_highlight)
        table.cell(pip_capture_table, 6, 1, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    else
        table.cell(pip_capture_table, 1, 1, smp_pip_rank, text_color=smp_pip_rank_color, text_size=smp_pip_rank == "1" ? size.large : size.normal, bgcolor=smp_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        smp_bars_highlight = smp_bars_display == "3" ? color.new(color.lime, 30) : color.black
        smp_bars_text_size = smp_bars_display == "3" ? size.large : size.normal
        smp_bars_text_color = smp_bars_display == "3" ? color.black : smp_bars_color
        table.cell(pip_capture_table, 2, 1, smp_bars_display, text_color=smp_bars_text_color, text_size=smp_bars_text_size, bgcolor=smp_bars_highlight)
        table.cell(pip_capture_table, 3, 1, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Pivot row
    pivot_pip_color = pivot_avg_pip_capture > 0 ? color.green : pivot_avg_pip_capture < 0 ? color.red : color.gray
    pivot_win_color = pivot_win_percentage >= 60 ? color.green : pivot_win_percentage >= 40 ? color.yellow : color.red
    // Highlight Pivot indicator name when signal is active (synchronized with alert condition)
    pivot_indicator_bgcolor = not na(pivot_highlight_bars) ? color.new(color.teal, 30) : color.black
    table.cell(pip_capture_table, 0, 2, "Pivot", text_color=color.white, text_size=size.normal, bgcolor=pivot_indicator_bgcolor)
    if show_pip_performance_data
        table.cell(pip_capture_table, 1, 2, str.tostring(math.round(pivot_avg_pip_capture, 1)), text_color=color.white, text_size=size.normal, bgcolor=pivot_pip_color)
        table.cell(pip_capture_table, 2, 2, str.tostring(pivot_total_captures), text_color=color.white, text_size=size.normal, bgcolor=color.teal)
        table.cell(pip_capture_table, 3, 2, str.tostring(math.round(pivot_win_percentage, 1)) + "%", text_color=pivot_win_color == color.yellow ? color.black : color.white, text_size=size.normal, bgcolor=pivot_win_color)
        table.cell(pip_capture_table, 4, 2, pivot_pip_rank, text_color=pivot_pip_rank_color, text_size=pivot_pip_rank == "1" ? size.large : size.normal, bgcolor=pivot_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        pivot_bars_highlight = pivot_bars_display == "3" ? color.new(color.lime, 30) : color.black
        pivot_bars_text_size = pivot_bars_display == "3" ? size.large : size.normal
        pivot_bars_text_color = pivot_bars_display == "3" ? color.black : pivot_bars_color
        table.cell(pip_capture_table, 5, 2, pivot_bars_display, text_color=pivot_bars_text_color, text_size=pivot_bars_text_size, bgcolor=pivot_bars_highlight)
        table.cell(pip_capture_table, 6, 2, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    else
        table.cell(pip_capture_table, 1, 2, pivot_pip_rank, text_color=pivot_pip_rank_color, text_size=pivot_pip_rank == "1" ? size.large : size.normal, bgcolor=pivot_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        pivot_bars_highlight = pivot_bars_display == "3" ? color.new(color.lime, 30) : color.black
        pivot_bars_text_size = pivot_bars_display == "3" ? size.large : size.normal
        pivot_bars_text_color = pivot_bars_display == "3" ? color.black : pivot_bars_color
        table.cell(pip_capture_table, 2, 2, pivot_bars_display, text_color=pivot_bars_text_color, text_size=pivot_bars_text_size, bgcolor=pivot_bars_highlight)
        table.cell(pip_capture_table, 3, 2, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Bounce row
    bounce_pip_color = bounce_avg_pip_capture > 0 ? color.green : bounce_avg_pip_capture < 0 ? color.red : color.gray
    bounce_win_color = bounce_win_percentage >= 60 ? color.green : bounce_win_percentage >= 40 ? color.yellow : color.red
    // Highlight Bounce indicator name when signal is active (synchronized with alert condition)
    bounce_indicator_bgcolor = not na(bounce_highlight_bars) ? color.new(color.fuchsia, 30) : color.black
    table.cell(pip_capture_table, 0, 3, "Pivot Bounce", text_color=color.white, text_size=size.normal, bgcolor=bounce_indicator_bgcolor)
    if show_pip_performance_data
        table.cell(pip_capture_table, 1, 3, str.tostring(math.round(bounce_avg_pip_capture, 1)), text_color=color.white, text_size=size.normal, bgcolor=bounce_pip_color)
        table.cell(pip_capture_table, 2, 3, str.tostring(bounce_total_captures), text_color=color.white, text_size=size.normal, bgcolor=color.fuchsia)
        table.cell(pip_capture_table, 3, 3, str.tostring(math.round(bounce_win_percentage, 1)) + "%", text_color=bounce_win_color == color.yellow ? color.black : color.white, text_size=size.normal, bgcolor=bounce_win_color)
        table.cell(pip_capture_table, 4, 3, bounce_pip_rank, text_color=bounce_pip_rank_color, text_size=bounce_pip_rank == "1" ? size.large : size.normal, bgcolor=bounce_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        bounce_bars_highlight = bounce_bars_display == "3" ? color.new(color.lime, 30) : color.black
        bounce_bars_text_size = bounce_bars_display == "3" ? size.large : size.normal
        bounce_bars_text_color = bounce_bars_display == "3" ? color.black : bounce_bars_color
        table.cell(pip_capture_table, 5, 3, bounce_bars_display, text_color=bounce_bars_text_color, text_size=bounce_bars_text_size, bgcolor=bounce_bars_highlight)
        table.cell(pip_capture_table, 6, 3, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    else
        table.cell(pip_capture_table, 1, 3, bounce_pip_rank, text_color=bounce_pip_rank_color, text_size=bounce_pip_rank == "1" ? size.large : size.normal, bgcolor=bounce_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        bounce_bars_highlight = bounce_bars_display == "3" ? color.new(color.lime, 30) : color.black
        bounce_bars_text_size = bounce_bars_display == "3" ? size.large : size.normal
        bounce_bars_text_color = bounce_bars_display == "3" ? color.black : bounce_bars_color
        table.cell(pip_capture_table, 2, 3, bounce_bars_display, text_color=bounce_bars_text_color, text_size=bounce_bars_text_size, bgcolor=bounce_bars_highlight)
        table.cell(pip_capture_table, 3, 3, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Keltner row
    keltner_pip_color = keltner_avg_pip_capture > 0 ? color.green : keltner_avg_pip_capture < 0 ? color.red : color.gray
    keltner_win_color = keltner_win_percentage >= 60 ? color.green : keltner_win_percentage >= 40 ? color.yellow : color.red
    // Highlight Keltner indicator name when signal is active (synchronized with alert condition)
    keltner_indicator_bgcolor = not na(keltner_highlight_bars) ? color.new(color.orange, 30) : color.black
    table.cell(pip_capture_table, 0, 4, "Keltner Breakout", text_color=color.white, text_size=size.normal, bgcolor=keltner_indicator_bgcolor)
    if show_pip_performance_data
        table.cell(pip_capture_table, 1, 4, str.tostring(math.round(keltner_avg_pip_capture, 1)), text_color=color.white, text_size=size.normal, bgcolor=keltner_pip_color)
        table.cell(pip_capture_table, 2, 4, str.tostring(keltner_total_captures), text_color=color.white, text_size=size.normal, bgcolor=color.orange)
        table.cell(pip_capture_table, 3, 4, str.tostring(math.round(keltner_win_percentage, 1)) + "%", text_color=keltner_win_color == color.yellow ? color.black : color.white, text_size=size.normal, bgcolor=keltner_win_color)
        table.cell(pip_capture_table, 4, 4, keltner_pip_rank, text_color=keltner_pip_rank_color, text_size=keltner_pip_rank == "1" ? size.large : size.normal, bgcolor=keltner_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        keltner_bars_highlight = keltner_bars_display == "3" ? color.new(color.lime, 30) : color.black
        keltner_bars_text_size = keltner_bars_display == "3" ? size.large : size.normal
        keltner_bars_text_color = keltner_bars_display == "3" ? color.black : keltner_bars_color
        table.cell(pip_capture_table, 5, 4, keltner_bars_display, text_color=keltner_bars_text_color, text_size=keltner_bars_text_size, bgcolor=keltner_bars_highlight)
        table.cell(pip_capture_table, 6, 4, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    else
        table.cell(pip_capture_table, 1, 4, keltner_pip_rank, text_color=keltner_pip_rank_color, text_size=keltner_pip_rank == "1" ? size.large : size.normal, bgcolor=keltner_pip_rank == "1" ? color.orange : color.black)
        // Highlight bars column when count reaches 3
        keltner_bars_highlight = keltner_bars_display == "3" ? color.new(color.lime, 30) : color.black
        keltner_bars_text_size = keltner_bars_display == "3" ? size.large : size.normal
        keltner_bars_text_color = keltner_bars_display == "3" ? color.black : keltner_bars_color
        table.cell(pip_capture_table, 2, 4, keltner_bars_display, text_color=keltner_bars_text_color, text_size=keltner_bars_text_size, bgcolor=keltner_bars_highlight)
        table.cell(pip_capture_table, 3, 4, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Table name row at the bottom
    table.cell(pip_capture_table, 0, 5, "Three Bar", text_color=color.white, text_size=size.large, bgcolor=color.black)
    if show_pip_performance_data
        table.cell(pip_capture_table, 1, 5, "Stop Strategy", text_color=color.white, text_size=size.large, bgcolor=color.black)
        table.cell(pip_capture_table, 2, 5, "Table", text_color=color.white, text_size=size.large, bgcolor=color.black)
        table.cell(pip_capture_table, 3, 5, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 4, 5, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 5, 5, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 6, 5, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    else
        table.cell(pip_capture_table, 1, 5, "Stop Strategy", text_color=color.white, text_size=size.large, bgcolor=color.black)
        table.cell(pip_capture_table, 2, 5, "Table", text_color=color.white, text_size=size.large, bgcolor=color.black)
        table.cell(pip_capture_table, 3, 5, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

    // Empty row for spacing at the bottom
    if show_pip_performance_data
        table.cell(pip_capture_table, 0, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 1, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 2, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 3, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 4, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 5, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 6, 6, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)
    else
        table.cell(pip_capture_table, 0, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 1, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 2, 6, "", text_color=color.white, text_size=size.normal, bgcolor=color.black)
        table.cell(pip_capture_table, 3, 6, "          ", text_color=color.white, text_size=size.normal, bgcolor=color.black)

// ================================== PIP CAPTURE CALCULATION ==========================================================
// Calculate pip capture for trades held for exactly 3 bars ------------------------------------------------------------
// This runs every bar to ensure we capture the 3-bar pip movement accurately

// Simplified pip capture calculation - store signal prices and calculate after 3 bars
// Function to calculate pip value based on current price
get_pip_value(current_price) =>
    current_price * 0.0001

// Store signal prices when signals occur
if strict_momentum_peak_long or potential_momentum_peak_long
    array.unshift(smp_long_signal_bars, bar_index)
    array.unshift(smp_long_pip_capture, close)  // Store the signal price
    if array.size(smp_long_signal_bars) > pip_capture_lookback
        array.pop(smp_long_signal_bars)
        array.pop(smp_long_pip_capture)

if strict_momentum_peak_short or potential_momentum_peak_short
    array.unshift(smp_short_signal_bars, bar_index)
    array.unshift(smp_short_pip_capture, close)  // Store the signal price
    if array.size(smp_short_signal_bars) > pip_capture_lookback
        array.pop(smp_short_signal_bars)
        array.pop(smp_short_pip_capture)

if longSignalActive
    array.unshift(pivot_long_signal_bars, bar_index)
    array.unshift(pivot_long_pip_capture, close)  // Store the signal price
    if array.size(pivot_long_signal_bars) > pip_capture_lookback
        array.pop(pivot_long_signal_bars)
        array.pop(pivot_long_pip_capture)

if shortSignalActive
    array.unshift(pivot_short_signal_bars, bar_index)
    array.unshift(pivot_short_pip_capture, close)  // Store the signal price
    if array.size(pivot_short_signal_bars) > pip_capture_lookback
        array.pop(pivot_short_signal_bars)
        array.pop(pivot_short_pip_capture)

if long_bounce_detected and not long_bounce_displayed
    array.unshift(bounce_long_signal_bars, bar_index)
    array.unshift(bounce_long_pip_capture, close)  // Store the signal price
    if array.size(bounce_long_signal_bars) > pip_capture_lookback
        array.pop(bounce_long_signal_bars)
        array.pop(bounce_long_pip_capture)

if short_bounce_detected and not short_bounce_displayed
    array.unshift(bounce_short_signal_bars, bar_index)
    array.unshift(bounce_short_pip_capture, close)  // Store the signal price
    if array.size(bounce_short_signal_bars) > pip_capture_lookback
        array.pop(bounce_short_signal_bars)
        array.pop(bounce_short_pip_capture)

// Track Keltner breakout signals for pip capture
if keltner_upper_cross_up
    last_keltner_signal_bar := bar_index
    array.unshift(keltner_long_signal_bars, bar_index)
    array.unshift(keltner_long_pip_capture, close)  // Store the signal price
    if array.size(keltner_long_signal_bars) > pip_capture_lookback
        array.pop(keltner_long_signal_bars)
        array.pop(keltner_long_pip_capture)

if keltner_lower_cross_down
    last_keltner_signal_bar := bar_index
    array.unshift(keltner_short_signal_bars, bar_index)
    array.unshift(keltner_short_pip_capture, close)  // Store the signal price
    if array.size(keltner_short_signal_bars) > pip_capture_lookback
        array.pop(keltner_short_signal_bars)
        array.pop(keltner_short_pip_capture)

// ================================== FIXED PIP CAPTURE AND WIN PERCENTAGE CALCULATION =================================
// Calculate individual trade results for accurate win percentage calculation
// Track individual trade pip captures and classify each trade as win/loss

// Initialize variables for individual trade tracking
smp_long_pips = 0.0
smp_short_pips = 0.0
pivot_long_pips = 0.0
pivot_short_pips = 0.0
bounce_long_pips = 0.0
bounce_short_pips = 0.0
keltner_long_pips = 0.0
keltner_short_pips = 0.0

smp_long_count = 0
smp_short_count = 0
pivot_long_count = 0
pivot_short_count = 0
bounce_long_count = 0
bounce_short_count = 0
keltner_long_count = 0
keltner_short_count = 0

// Initialize win/loss counters for accurate win percentage calculation
smp_wins = 0
smp_losses = 0
pivot_wins = 0
pivot_losses = 0
bounce_wins = 0
bounce_losses = 0
keltner_wins = 0
keltner_losses = 0

// Win threshold for individual trades
win_threshold = 0.5  // Minimum pips to consider a trade a win

// Calculate SMP long pip captures (individual trade evaluation)
if array.size(smp_long_signal_bars) > 0 and array.size(smp_long_pip_capture) > 0
    for i = 0 to math.min(array.size(smp_long_signal_bars) - 1, array.size(smp_long_pip_capture) - 1)
        signal_bar = array.get(smp_long_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(smp_long_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (current_price - signal_price) / pip_value
            smp_long_pips := smp_long_pips + pip_capture
            smp_long_count := smp_long_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                smp_wins := smp_wins + 1
            else
                smp_losses := smp_losses + 1

// Calculate SMP short pip captures (individual trade evaluation)
if array.size(smp_short_signal_bars) > 0 and array.size(smp_short_pip_capture) > 0
    for i = 0 to math.min(array.size(smp_short_signal_bars) - 1, array.size(smp_short_pip_capture) - 1)
        signal_bar = array.get(smp_short_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(smp_short_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (signal_price - current_price) / pip_value
            smp_short_pips := smp_short_pips + pip_capture
            smp_short_count := smp_short_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                smp_wins := smp_wins + 1
            else
                smp_losses := smp_losses + 1

// Calculate Pivot long pip captures (individual trade evaluation)
if array.size(pivot_long_signal_bars) > 0 and array.size(pivot_long_pip_capture) > 0
    for i = 0 to math.min(array.size(pivot_long_signal_bars) - 1, array.size(pivot_long_pip_capture) - 1)
        signal_bar = array.get(pivot_long_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(pivot_long_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (current_price - signal_price) / pip_value
            pivot_long_pips := pivot_long_pips + pip_capture
            pivot_long_count := pivot_long_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                pivot_wins := pivot_wins + 1
            else
                pivot_losses := pivot_losses + 1

// Calculate Pivot short pip captures (individual trade evaluation)
if array.size(pivot_short_signal_bars) > 0 and array.size(pivot_short_pip_capture) > 0
    for i = 0 to math.min(array.size(pivot_short_signal_bars) - 1, array.size(pivot_short_pip_capture) - 1)
        signal_bar = array.get(pivot_short_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(pivot_short_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (signal_price - current_price) / pip_value
            pivot_short_pips := pivot_short_pips + pip_capture
            pivot_short_count := pivot_short_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                pivot_wins := pivot_wins + 1
            else
                pivot_losses := pivot_losses + 1

// Calculate Bounce long pip captures (individual trade evaluation)
if array.size(bounce_long_signal_bars) > 0 and array.size(bounce_long_pip_capture) > 0
    for i = 0 to math.min(array.size(bounce_long_signal_bars) - 1, array.size(bounce_long_pip_capture) - 1)
        signal_bar = array.get(bounce_long_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(bounce_long_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (current_price - signal_price) / pip_value
            bounce_long_pips := bounce_long_pips + pip_capture
            bounce_long_count := bounce_long_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                bounce_wins := bounce_wins + 1
            else
                bounce_losses := bounce_losses + 1

// Calculate Bounce short pip captures (individual trade evaluation)
if array.size(bounce_short_signal_bars) > 0 and array.size(bounce_short_pip_capture) > 0
    for i = 0 to math.min(array.size(bounce_short_signal_bars) - 1, array.size(bounce_short_pip_capture) - 1)
        signal_bar = array.get(bounce_short_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(bounce_short_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (signal_price - current_price) / pip_value
            bounce_short_pips := bounce_short_pips + pip_capture
            bounce_short_count := bounce_short_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                bounce_wins := bounce_wins + 1
            else
                bounce_losses := bounce_losses + 1

// Calculate Keltner long pip captures (individual trade evaluation)
if array.size(keltner_long_signal_bars) > 0 and array.size(keltner_long_pip_capture) > 0
    for i = 0 to math.min(array.size(keltner_long_signal_bars) - 1, array.size(keltner_long_pip_capture) - 1)
        signal_bar = array.get(keltner_long_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(keltner_long_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (current_price - signal_price) / pip_value
            keltner_long_pips := keltner_long_pips + pip_capture
            keltner_long_count := keltner_long_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                keltner_wins := keltner_wins + 1
            else
                keltner_losses := keltner_losses + 1

// Calculate Keltner short pip captures (individual trade evaluation)
if array.size(keltner_short_signal_bars) > 0 and array.size(keltner_short_pip_capture) > 0
    for i = 0 to math.min(array.size(keltner_short_signal_bars) - 1, array.size(keltner_short_pip_capture) - 1)
        signal_bar = array.get(keltner_short_signal_bars, i)
        if bar_index >= signal_bar + 3  // 3 or more bars after signal
            signal_price = array.get(keltner_short_pip_capture, i)
            current_price = close
            pip_value = get_pip_value(signal_price)
            pip_capture = (signal_price - current_price) / pip_value
            keltner_short_pips := keltner_short_pips + pip_capture
            keltner_short_count := keltner_short_count + 1
            // Classify individual trade as win or loss
            if pip_capture >= win_threshold
                keltner_wins := keltner_wins + 1
            else
                keltner_losses := keltner_losses + 1

// Update persistent pip capture statistics
smp_total_captures := smp_long_count + smp_short_count
smp_accumulated_pips := smp_long_pips + smp_short_pips
smp_avg_pip_capture := smp_total_captures > 0 ? smp_accumulated_pips / smp_total_captures : 0.0

pivot_total_captures := pivot_long_count + pivot_short_count
pivot_accumulated_pips := pivot_long_pips + pivot_short_pips
pivot_avg_pip_capture := pivot_total_captures > 0 ? pivot_accumulated_pips / pivot_total_captures : 0.0

bounce_total_captures := bounce_long_count + bounce_short_count
bounce_accumulated_pips := bounce_long_pips + bounce_short_pips
bounce_avg_pip_capture := bounce_total_captures > 0 ? bounce_accumulated_pips / bounce_total_captures : 0.0

keltner_total_captures := keltner_long_count + keltner_short_count
keltner_accumulated_pips := keltner_long_pips + keltner_short_pips
keltner_avg_pip_capture := keltner_total_captures > 0 ? keltner_accumulated_pips / keltner_total_captures : 0.0

// FIXED: Calculate accurate win percentages based on individual trade results
smp_win_percentage := (smp_wins + smp_losses) > 0 ? (smp_wins / (smp_wins + smp_losses)) * 100 : 0.0
pivot_win_percentage := (pivot_wins + pivot_losses) > 0 ? (pivot_wins / (pivot_wins + pivot_losses)) * 100 : 0.0
bounce_win_percentage := (bounce_wins + bounce_losses) > 0 ? (bounce_wins / (bounce_wins + bounce_losses)) * 100 : 0.0
keltner_win_percentage := (keltner_wins + keltner_losses) > 0 ? (keltner_wins / (keltner_wins + keltner_losses)) * 100 : 0.0

// ========================================== SYZYGY PIVOT ALERTS ======================================================

// Alert conditions for Syzygy Pivots (only when market is trending in the correct direction) ---------------------------
alertcondition(longSignalActive and alerts_enabled and market_structure == "TRENDING" and price_change > 0, title="Syzygy Pivot Long (Trending Up)", message="SYZ_PIVOT_LONG_TRENDING_UP Alert \nTicker: {{ticker}}\nPrice: {{close}}\nMarket: TRENDING UP\nChart: https://www.tradingview.com/chart/?symbol={{ticker}}")
alertcondition(shortSignalActive and alerts_enabled and market_structure == "TRENDING" and price_change < 0, title="Syzygy Pivot Short (Trending Down)", message="SYZ_PIVOT_SHORT_TRENDING_DOWN Alert \nTicker: {{ticker}}\nPrice: {{close}}\nMarket: TRENDING DOWN\nChart: https://www.tradingview.com/chart/?symbol={{ticker}}")

// ================================= SYZYGY MOMENTUM PEAK ALERTS =======================================================
// Alert condition for Syzygy Momentum Peak with enhanced descriptive message ------------------------------------------
alertcondition(syzygy_momentum_peak_signal and alerts_enabled and enable_smp_alerts, title="Syzygy Momentum Peak", message="SYZYGY_MOMENTUM_PEAK\nTicker: {{ticker}}\nPrice: {{close}}\nSignal: Momentum Peak (Long/Short, Strong/Weak)\nVolume: {{volume}}\nTime: {{time}}\nChart: https://www.tradingview.com/chart/?symbol={{ticker}}")

// ================================== BOUNCE DETECTION ALERTS ==========================================================
// Alert conditions for Long/Short Pivot Bounce Detection after pullback signals -------------------------------------
alertcondition(long_bounce_alert_ready, title="Long Pivot Bounce Detected", 
     message="LONG_PIVOT_BOUNCE\nTicker: {{ticker}}\nPrice: {{close}}\nChart: https://www.tradingview.com/chart/?symbol={{ticker}}")

alertcondition(short_bounce_alert_ready, title="Short Pivot Bounce Detected", 
     message="SHORT_PIVOT_BOUNCE\nTicker: {{ticker}}\nPrice: {{close}}\nChart: https://www.tradingview.com/chart/?symbol={{ticker}}")

// ================================== KELTNER CHANNEL BREAKOUT ALERTS ===================================================
// Alert conditions for Syzygy Range Breakout (Bullish/Bearish) --------------------------------------------------------
alertcondition(keltner_upper_cross_up and alerts_enabled, title="Syzygy Range Breakout Bullish", 
     message="SYZYGY_RANGE_BREAKOUT_BULLISH\nTicker: {{ticker}}\nPrice: {{close}}\nDirection: BULLISH\nChart: https://www.tradingview.com/chart/?symbol={{ticker}}")

alertcondition(keltner_lower_cross_down and alerts_enabled, title="Syzygy Range Breakout Bearish", 
     message="SYZYGY_RANGE_BREAKOUT_BEARISH\nTicker: {{ticker}}\nPrice: {{close}}\nDirection: BEARISH\nChart: https://www.tradingview.com/chart/?symbol={{ticker}}")

