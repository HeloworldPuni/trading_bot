// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © KINSKI
//参考 https://www.reddit.com/r/TradingView/comments/o8r8v4/could_anyone_recommend_some_profitable_strategies/
// I use the Kinski buy-sell indicator.
//@version=5
indicator('KINSKI Buy-Sell Signal', shorttitle='Buy-Sell Signal', format=format.price, precision=0, overlay=true, max_labels_count = 500)


//********** Functions
funcDonchian(_len) =>
    math.avg(ta.lowest(_len), ta.highest(_len))

funcEmaSma(_src, _period, _strategy) =>
    tresholdPositive = 88
    tresholdNegative = -88

    // EMA/SMA
    maLengthBuy_1_Default = 14
    maLengthBuy_2_Default = 3
    maLengthSell_1_Default = 8
    maLengthSell_2_Default = 1

    // setting 1
    maLengthBuy_1 = _period == '1' ? 6 : _period == '3' ? 5 : _period == '5' ? 5 : _period == '15' ? 42 : _period == '30' ? 42 : _period == '45' ? 16 : _period == '60' ? 20 : timeframe.isdaily ? 14 : timeframe.isweekly ? 14 : timeframe.ismonthly ? 5 : 14
    maLengthBuy_2 = _period == '1' ? 1 : _period == '3' ? 1 : _period == '5' ? 1 : _period == '15' ? 1 : _period == '30' ? 1 : _period == '45' ? 1 : _period == '60' ? 2 : timeframe.isdaily ? 5 : timeframe.isweekly ? 3 : timeframe.ismonthly ? 1 : 3
    maLengthSell_1 = _period == '1' ? 6 : _period == '3' ? 3 : _period == '5' ? 3 : _period == '15' ? 6 : _period == '30' ? 6 : _period == '45' ? 8 : _period == '60' ? 20 : timeframe.isdaily ? 12 : timeframe.isweekly ? 8 : timeframe.ismonthly ? 5 : 8
    maLengthSell_2 = _period == '1' ? 3 : _period == '3' ? 1 : _period == '5' ? 2 : _period == '15' ? 2 : _period == '30' ? 1 : _period == '45' ? 1 : _period == '60' ? 1 : timeframe.isdaily ? 1 : timeframe.isweekly ? 1 : timeframe.ismonthly ? 1 : 1

    // setting 2
    isTimeframeBased = _strategy == 'EMA/SMA TF based'
    maLengthBuyFinal_1 = isTimeframeBased ? maLengthBuy_1 : maLengthBuy_1_Default
    maLengthBuyFinal_2 = isTimeframeBased ? maLengthBuy_2 : maLengthBuy_2_Default
    maLengthSellFinal_1 = isTimeframeBased ? maLengthSell_1 : maLengthSell_1_Default
    maLengthSellFinal_2 = isTimeframeBased ? maLengthSell_2 : maLengthSell_2_Default

    // BUY
    esaBuy = ta.ema(_src, maLengthBuyFinal_1)
    sourceEmaBuy = ta.ema(math.abs(_src - esaBuy), maLengthBuyFinal_1)
    ciBuy = (_src - esaBuy) / (0.015 * sourceEmaBuy)
    trendEmaBuy = ta.ema(ciBuy, maLengthBuyFinal_2)
    trendSmaBuy = ta.sma(trendEmaBuy, 4)

    // SELL
    esaSell = ta.ema(_src, maLengthSellFinal_1)
    sourceEmaSell = ta.ema(math.abs(_src - esaSell), maLengthSellFinal_1)
    ciSell = (_src - esaSell) / (0.015 * sourceEmaSell)
    trendEmaSell = ta.ema(ciSell, maLengthSellFinal_2)
    trendSmaSell = ta.sma(trendEmaSell, 4)

    // prepare signals
    buyEmaSma = ta.crossover(trendEmaBuy, trendSmaBuy) and trendEmaBuy <= tresholdNegative
    sellEmaSma = ta.crossunder(trendEmaSell, trendSmaSell) and trendEmaSell >= tresholdPositive

    [buyEmaSma, sellEmaSma]

// Percentage Price Oscillator
funcPPO(_src) =>
    valPPOfast = 12
    valPPOslow = 26
    valPPOsmooth = 2
    valPPOfastMA = ta.ema(_src, valPPOfast)
    valPPOslowMA = ta.ema(_src, valPPOslow)
    valPPOmacd = valPPOfastMA - valPPOslowMA
    valPPOmacd2 = valPPOmacd / valPPOslowMA * 100
    valPPOresult = ta.sma(valPPOmacd2, valPPOsmooth)
    valPPOoscMin = valPPOresult > valPPOresult[1] and valPPOresult[1] < valPPOresult[2]
    valPPOoscMax = valPPOresult < valPPOresult[1] and valPPOresult[1] > valPPOresult[2]
    valPPOdivergenceBull = valPPOoscMin ? valPPOresult[1] : na
    valPPOdivergenceBear = valPPOoscMax ? valPPOresult[1] : na

    // prepare signals
    buyPPO = valPPOdivergenceBull != 0
    sellPPO = valPPOdivergenceBear != 0

    [buyPPO, sellPPO]

// Kaufman's Adaptive Moving Average (KAMA)
funcKAMA(_src) =>
    // settings
    valKamaFastLength = 12
    valKamaFastLengthKAMA = 2
    valKamaSlowLength = 26
    valKamaSlowLengthKAMA = 30
    valKamaSignalLength = 9

    // fast
    valKamaFastLag = (valKamaFastLength - 1) / 2
    valKamaFastData = _src + _src - _src[valKamaFastLag]
    valKamaFastZeroLagEMA = ta.ema(valKamaFastData, valKamaFastLength)
    valKamaFastEma = ta.ema(_src, valKamaFastLength)
    valKamaFastVolatility = math.sum(math.abs(_src - _src[1]), valKamaFastLength)
    valKamaFastEfficiencyRatio = valKamaFastVolatility != 0 ? math.abs(_src - _src[valKamaFastLength]) / valKamaFastVolatility : 0
    valKamaFast = 0.0
    valKamaFast := nz(valKamaFast[1]) + math.pow(valKamaFastEfficiencyRatio * (2 / (valKamaFastLengthKAMA + 1) - 2 / (valKamaSlowLengthKAMA + 1)) + 2 / (valKamaSlowLengthKAMA + 1), 2) * (_src - nz(valKamaFast[1]))

    // slow
    valKamaSlowLag = (valKamaSlowLength - 1) / 2
    valKamaSlowData = _src + _src - _src[valKamaSlowLag]
    valKamaSlowZeroLagEMA = ta.ema(valKamaSlowData, valKamaSlowLength)
    valKamaSlowEma = ta.ema(_src, valKamaSlowLength)
    valKamaSlowVolatility = math.sum(math.abs(_src - _src[1]), valKamaSlowLength)
    valKamaSlowEfficiencyRatio = valKamaSlowVolatility != 0 ? math.abs(_src - _src[valKamaSlowLength]) / valKamaSlowVolatility : 0
    valKamaSlow = 0.0
    valKamaSlow := nz(valKamaSlow[1]) + math.pow(valKamaSlowEfficiencyRatio * (2 / (valKamaFastLengthKAMA + 1) - 2 / (valKamaSlowLengthKAMA + 1)) + 2 / (valKamaSlowLengthKAMA + 1), 2) * (_src - nz(valKamaSlow[1]))

    // Moving Average Convergence Divergence (MACD)
    valKamaMacd1 = valKamaFastZeroLagEMA - valKamaSlowZeroLagEMA
    valKamaMacd2 = valKamaFastEma - valKamaSlowEma
    valKamaMacd3 = valKamaFast - valKamaSlow
    valKamaMacdAverage = (valKamaMacd1 + valKamaMacd2 + valKamaMacd3) / 3

    // prepare signals
    valKamaSignal = ta.ema(valKamaMacdAverage, valKamaSignalLength)
    //valKamaSignal = ema(valKamaMacdAverage + (valKamaMacdAverage - valKamaMacdAverage[(valKamaSignalLength - 1) / 2]), valKamaSignalLength)

    // prepare signals
    buyKama = ta.crossover(valKamaMacdAverage, valKamaSignal)
    sellKama = ta.crossunder(valKamaMacdAverage, valKamaSignal)

    [buyKama, sellKama]

funcIchimoku(_period, _src) =>
    conversionLinePeriod = _period == 'Ichimoku_9-26-52' ? 9 : _period == 'Ichimoku_10-30-60' ? 10 : _period == 'Ichimoku_20-60-120' ? 20 : 9
    baseLinePeriod = _period == 'Ichimoku_9-26-52' ? 26 : _period == 'Ichimoku_10-30-60' ? 30 : _period == 'Ichimoku_20-60-120' ? 60 : 26
    laggingSpanPeriod = _period == 'Ichimoku_9-26-52' ? 52 : _period == 'Ichimoku_10-30-60' ? 60 : _period == 'Ichimoku_20-60-120' ? 120 : 52

    // calc
    tenkanSenConversionLine = funcDonchian(conversionLinePeriod)
    kijunSenBaseLine = funcDonchian(baseLinePeriod)
    leadingSpanA = math.avg(tenkanSenConversionLine, kijunSenBaseLine)
    leadingSpanB = funcDonchian(laggingSpanPeriod)

    // RSI Settings
    ichiRsiLength = 14
    ichiRsiOverBought = 50
    ichiRsiOverSold = 100
    ichiRsiDefault = ta.rsi(_src, ichiRsiLength)

    // lines, span
    tenkanSenLine = tenkanSenConversionLine[baseLinePeriod]
    kijunSenLine = kijunSenBaseLine[baseLinePeriod]
    senkouSpanA = leadingSpanA[baseLinePeriod * 2]
    senkouSpanB = leadingSpanB[baseLinePeriod * 2]
    chikuSpan = _src[0]

    // smallest/greatest of multiple given values
    ichiMin = math.min(senkouSpanA, senkouSpanB)
    ichiMax = math.max(senkouSpanA, senkouSpanB)

    // up/down
    upTrend = chikuSpan > ichiMax
    downTrend = chikuSpan < ichiMin

    // bull/bear
    bull = ta.crossover(tenkanSenLine, kijunSenLine)
    bear = ta.crossunder(tenkanSenLine, kijunSenLine)

    // prepare signals
    longIchi = bull and upTrend and ichiRsiDefault <= ichiRsiOverSold
    shortIchi = bear and downTrend and ichiRsiDefault >= ichiRsiOverBought

    [longIchi, shortIchi]

funcDirectionalMovement(_len) =>
    _up = ta.change(high)
    _down = -ta.change(low)
    _plusDM = na(_up) ? na : _up > _down and _up > 0 ? _up : 0
    _minusDM = na(_down) ? na : _down > _up and _down > 0 ? _down : 0
    _trueRange = ta.rma(ta.tr, _len)
    _plus = fixnan(100 * ta.rma(_plusDM, _len) / _trueRange)
    _minus = fixnan(100 * ta.rma(_minusDM, _len) / _trueRange)
    [_plus, _minus]

funcAdx(valAdxDirectionalIndexLength, _len) =>
    [_plus, _minus] = funcDirectionalMovement(valAdxDirectionalIndexLength)
    sum = _plus + _minus
    funcAdx = 100 * ta.rma(math.abs(_plus - _minus) / (sum == 0 ? 1 : sum), _len)
    funcAdx

funcAdxLowHigh(_len, _type) =>
    [_plus, _minus] = funcDirectionalMovement(_len)
    return_1 = _type == 'high' ? _plus : _minus
    return_1

funcHullMovingAverage(_src, _len) =>
    tmpVal = math.max(2, _len)
    return_2 = ta.wma(2 * ta.wma(_src, tmpVal / 2) - ta.wma(_src, tmpVal), math.round(math.sqrt(tmpVal)))
    return_2

funcHullMovingAverage3(_src, _len) =>
    tmpVal = _len / 2
    ta.wma(ta.wma(_src, tmpVal / 3) * 3 - ta.wma(_src, tmpVal / 2) - ta.wma(_src, tmpVal), tmpVal)

funcHullTrend(_src, _period) =>
    valHullTrendLength = _period == '1' ? 30 : _period == '3' ? 29 : _period == '5' ? 28 : _period == '15' ? 27 : _period == '30' ? 26 : _period == '45' ? 24 : _period == '60' ? 24 : timeframe.isdaily ? 24 : timeframe.isweekly ? 24 : timeframe.ismonthly ? 24 : 24
    boolHullTrendA = funcHullMovingAverage(_src, valHullTrendLength)
    boolHullTrendB = funcHullMovingAverage3(_src, valHullTrendLength)
    buyHullTrend = boolHullTrendB > boolHullTrendA and boolHullTrendB[1] < boolHullTrendA[1]
    sellHullTrend = boolHullTrendA > boolHullTrendB and boolHullTrendA[1] < boolHullTrendB[1]
    [buyHullTrend, sellHullTrend]

funcFractalCalculated(_type, _variant) =>
    _regular = _variant == 1 ? high[4] < high[3] and high[3] < high[2] and high[2] > high[1] and high[1] > high[0] : _variant == -1 ? low[4] > low[3] and low[3] > low[2] and low[2] < low[1] and low[1] < low[0] : false
    _billWilliams = _variant == 1 ? high[4] < high[2] and high[3] < high[2] and high[2] > high[1] and high[2] > high[0] : _variant == -1 ? low[4] > low[2] and low[3] > low[2] and low[2] < low[1] and low[2] < low[0] : false
    return_3 = _type == 'Fractal Regular' ? _regular : _billWilliams
    return_3



//********** Inputs

// The HLC stands for High, Low, Close and the /3 divides the result by 3 to give you the average.
inputSource = input(title='Calculation Source', defval=close)

string inputStrategy = input.string(title='Strategy', defval='EMA/SMA', options=['EMA/SMA', 'EMA/SMA TF based', 'Fractal Regular', 'Fractal Bill Williams', 'Percentage Price Oscillator', 'Hull Trend', 'Kaufman Adaptive Moving Average'])
string inputStrategyLongShort = input.string(title='Strategy - Long/Short', defval='ADX', options=['DISABLED', 'ADX', 'Ichimoku_9-26-52', 'Ichimoku_10-30-60', 'Ichimoku_20-60-120'])
string inputStyleLabelSize = input.string(title='Label - Size', defval='small', options=['auto', 'huge', 'large', 'normal', 'small', 'tiny'])
string inputStyleLabelType = input.string(title='Label - Type', defval='label', options=['label', 'triangle'])
string inputStyleLabelPosition = input.string(title='Label - Position', defval='default', options=['default', 'lowhigh'])
bool inputShowPriceOnLabel = input(title='Show Price on Labels', defval=true)
bool inputShowBuyLabel = input(title='Show BUY Signal', defval=true)
bool inputShowSellLabel = input(title='Show SELL Signal', defval=true)
bool inputActivateAlerts = input(title='Activate Alerts', defval=false)



//********** globals
valXPosTimeBased = time  //offset -1
string valCurrentTimeFramePeriod = timeframe.period
string valPrice = close <= 0.99999 ? str.tostring(close, '#.####') : close <= 99.99 ? str.tostring(close, '#.###') : close <= 999.99 ? str.tostring(close, '#.##') : str.tostring(close, '#')
string valLabelTextBuy = 'BUY' + (inputShowPriceOnLabel == true ? ': ' + valPrice : '')
string valLabelTextSell = 'SELL' + (inputShowPriceOnLabel == true ? ': ' + valPrice : '')



//********** Average Directional Index (ADX)
int valAdxLength = 13
int valAdxDirectionalIndexLength = 14
int valAdxAverageTrueRange = 20
int valAdxHigherLowTrend = 40

boolAdxDirectionalIndexHigh = funcAdxLowHigh(valAdxDirectionalIndexLength, 'high')
boolAdxDirectionalIndexLow = funcAdxLowHigh(valAdxDirectionalIndexLength, 'low')
boolAdxDirectionalIndexCross = ta.cross(boolAdxDirectionalIndexHigh, boolAdxDirectionalIndexLow)

funcAdxUp() =>
    funcAdx(valAdxDirectionalIndexLength, valAdxLength) >= valAdxAverageTrueRange
funcAdxDirectionalIndexUp() =>
    boolAdxDirectionalIndexHigh >= boolAdxDirectionalIndexLow
funcAdxDirectionalIndexUps() =>
    boolAdxDirectionalIndexHigh >= valAdxHigherLowTrend
funcAdxDirectionalIndexDown() =>
    boolAdxDirectionalIndexLow > boolAdxDirectionalIndexHigh
funcAdxDirectionalIndexDowns() =>
    boolAdxDirectionalIndexLow > valAdxHigherLowTrend

funcAdxFinal() =>
    // bool
    boolAdxBuyCondition = funcAdxUp() and funcAdxDirectionalIndexUp() and funcAdxDirectionalIndexUps()
    boolAdxBuyCloseCondition = boolAdxDirectionalIndexCross and funcAdxDirectionalIndexUp()[1]
    boolAdxSellCondition = funcAdxUp() and funcAdxDirectionalIndexDown() and funcAdxDirectionalIndexDowns()
    boolAdxSellCloseCondition = boolAdxDirectionalIndexCross and funcAdxDirectionalIndexDown()[1]
    // counter
    adxCounter = 0
    adxCounter := boolAdxBuyCloseCondition ? 0 : boolAdxSellCloseCondition ? 0 : boolAdxBuyCondition ? 1 : boolAdxSellCondition ? -1 : nz(adxCounter[1])
    // prepare signals
    longAdx = adxCounter == 1 and adxCounter[1] == 0
    shortAdx = adxCounter == -1 and adxCounter[1] == 0
    [longAdx, shortAdx]



//********** Styling Labels
string valFinalLabelSize = inputStyleLabelSize == 'auto' ? size.auto : inputStyleLabelSize == 'huge' ? size.huge : inputStyleLabelSize == 'large' ? size.large : inputStyleLabelSize == 'normal' ? size.normal : inputStyleLabelSize == 'small' ? size.small : inputStyleLabelSize == 'tiny' ? size.tiny : size.normal
string valFinalLabelStyleUp = inputStyleLabelType == 'label' ? label.style_label_up : inputStyleLabelType == 'triangle' ? label.style_triangleup : label.style_label_up
string valFinalLabelStyleDown = inputStyleLabelType == 'label' ? label.style_label_down : inputStyleLabelType == 'triangle' ? label.style_triangledown : label.style_label_down



//********** Set Signals - Buy/Sell
[signalFinalBuy, signalFinalSell] = funcEmaSma(inputSource, valCurrentTimeFramePeriod, inputStrategy)

if inputStrategy == 'Kaufman Adaptive Moving Average'
    [buyKama, sellKama] = funcKAMA(inputSource)
    signalFinalBuy := buyKama
    signalFinalSell := sellKama
    signalFinalSell
else if inputStrategy == 'Percentage Price Oscillator'
    [buyPPO, sellPPO] = funcPPO(inputSource)
    signalFinalBuy := buyPPO
    signalFinalSell := sellPPO
    signalFinalSell
else if inputStrategy == 'Hull Trend'
    [buyHullTrend, sellHullTrend] = funcHullTrend(inputSource, valCurrentTimeFramePeriod)
    signalFinalBuy := buyHullTrend
    signalFinalSell := sellHullTrend
    signalFinalSell
else if inputStrategy == 'Fractal Regular' or inputStrategy == 'Fractal Bill Williams'
    signalBuyFractal = funcFractalCalculated(inputStrategy, -1)
    signalSellFractal = funcFractalCalculated(inputStrategy, 1)
    signalFinalBuy := signalBuyFractal
    signalFinalSell := signalSellFractal
    signalFinalSell



//********** Set Signals - Long/Short
bool signalFinalLong = false
bool signalFinalShort = false

if inputStrategyLongShort == 'Ichimoku_9-26-52' or inputStrategyLongShort == 'Ichimoku_10-30-60' or inputStrategyLongShort == 'Ichimoku_20-60-120'
    [signalLongIchi, signalShortIchi] = funcIchimoku(inputStrategyLongShort, inputSource)
    signalFinalLong := signalLongIchi
    signalFinalShort := signalShortIchi
    signalFinalShort
else if inputStrategyLongShort == 'ADX'
    [longAdx, shortAdx] = funcAdxFinal()
    signalFinalLong := longAdx
    signalFinalShort := shortAdx
    signalFinalShort



//************  Plotting

// BUY
label.new(x=signalFinalBuy and inputShowBuyLabel == true ? valXPosTimeBased : na, y=inputStyleLabelPosition == 'default' ? na : low, xloc=xloc.bar_time, yloc=inputStyleLabelPosition == 'default' ? yloc.belowbar : yloc.price, text=valLabelTextBuy, color=color.green, textcolor=color.white, style=valFinalLabelStyleUp, size=valFinalLabelSize)


// SELL
label.new(x=signalFinalSell and inputShowSellLabel == true ? valXPosTimeBased : na, y=inputStyleLabelPosition == 'default' ? na : high, xloc=xloc.bar_time, yloc=inputStyleLabelPosition == 'default' ? yloc.abovebar : yloc.price, text=valLabelTextSell, color=color.red, textcolor=color.white, style=valFinalLabelStyleDown, size=valFinalLabelSize)


// LONG
label.new(x=signalFinalLong ? valXPosTimeBased : na, y=low, xloc=xloc.bar_time, yloc=yloc.price, text='LONG', color=color.blue, textcolor=color.white, style=valFinalLabelStyleUp, size=size.tiny)


// SHORT
label.new(x=signalFinalShort ? valXPosTimeBased : na, y=high, xloc=xloc.bar_time, yloc=yloc.price, text='SHORT', color=color.fuchsia, textcolor=color.white, style=valFinalLabelStyleDown, size=size.tiny)



//************  Alerting

// BUY
alertcondition(inputActivateAlerts and signalFinalBuy, title='BUY', message='BUY')

// SELL
alertcondition(inputActivateAlerts and signalFinalSell, title='SELL', message='SELL')

// LONG
alertcondition(inputActivateAlerts and signalFinalLong, title='LONG', message='LONG')

// SHORT
alertcondition(inputActivateAlerts and signalFinalShort, title='SHORT', message='SHORT')



