//@version=5
indicator("MNQ Scalping Pro - Fixed", shorttitle="MNQ Pro", overlay=true, max_boxes_count=100, max_lines_count=50)

// ========== INPUT PARAMETERS ==========

// VWAP Settings
group_vwap = "VWAP Settings"
show_vwap = input.bool(true, "Show VWAP", group=group_vwap)
show_stddev1 = input.bool(false, "Show 1st Std Dev", group=group_vwap)
show_stddev2 = input.bool(false, "Show 2nd Std Dev", group=group_vwap)

// Volume Profile & S/R Settings
group_sr = "Volume Profile & S/R"
enable_volume_profile = input.bool(true, "Enable Volume Profile", group=group_sr)
show_info_table = input.bool(true, "Show Info Table", group=group_sr, tooltip="Show/hide blue info table")
show_poc = input.bool(true, "Show Point of Control", group=group_sr)
show_hvn = input.bool(true, "Show High Volume Nodes", group=group_sr)
show_lvn = input.bool(false, "Show Low Volume Nodes", group=group_sr)
show_value_area = input.bool(true, "Show Value Area", group=group_sr)
volume_profile_lookback = input.int(100, "Volume Profile Lookback", minval=50, maxval=200, group=group_sr)
minimum_zone_strength = input.float(2.5, "Minimum Zone Strength", minval=1.0, maxval=5.0, step=0.1, group=group_sr)
value_area_percentage = input.float(70.0, "Value Area %", minval=50.0, maxval=90.0, step=5.0, group=group_sr)

// Instrument Detection & Settings
group_instrument = "Instrument Settings"
auto_detect_instrument = input.bool(true, "Auto-Detect Instrument", group=group_instrument, tooltip="Automatically adjust settings based on instrument")
manual_instrument = input.string("MNQ", "Manual Instrument", options=["MNQ", "MES"], group=group_instrument, tooltip="Used when Auto-Detect is disabled")

// Detect current instrument - FIXED SYNTAX
detected_instrument = str.contains(syminfo.ticker, "MES") ? "MES" : "MNQ"
current_instrument = auto_detect_instrument ? detected_instrument : manual_instrument

// Instrument-specific settings
is_mes = current_instrument == "MES"
is_mnq = current_instrument == "MNQ"

// Dynamic thresholds based on instrument
base_volume_threshold = is_mes ? 250 : 500
base_strong_threshold = is_mes ? 750 : 1500
base_or_duration = is_mes ? 45 : 30
base_volume_spike_multiplier = is_mes ? 2.5 : 2.0

// Delta Analysis Settings  
group_delta = "Delta Analysis"
enable_delta_coloring = input.bool(true, "Enable Delta Coloring", group=group_delta)
volume_threshold = input.int(500, "Volume Threshold", minval=10, group=group_delta, tooltip="Auto-adjusted: MES=250, MNQ=500")
strong_delta_threshold = input.int(1500, "Strong Delta Threshold", minval=50, group=group_delta, tooltip="Auto-adjusted: MES=750, MNQ=1500")

// Apply instrument-specific overrides
final_volume_threshold = is_mes ? 250 : volume_threshold
final_strong_threshold = is_mes ? 750 : strong_delta_threshold

// Opening Range Settings
group_or = "Opening Range"
enable_opening_range = input.bool(true, "Enable Opening Range", group=group_or)
show_or_info = input.bool(true, "Show OR Info Label", group=group_or, tooltip="Show/hide blue OR information box")
use_cet_time = input.bool(true, "Use CET Time", group=group_or, tooltip="True=CET (15:30), False=ET (9:30)")
or_start_hour = input.int(15, "OR Start Hour", minval=0, maxval=23, group=group_or, tooltip="CET: 15:30 | ET: 9:30")
or_start_minute = input.int(30, "OR Start Minute", minval=0, maxval=59, group=group_or)
or_duration_minutes = input.int(30, "OR Duration (Minutes)", minval=5, maxval=120, group=group_or, tooltip="Auto-adjusted: MES=45min, MNQ=30min")

// Apply instrument-specific overrides
final_or_duration = is_mes ? 45 : or_duration_minutes

// Session Settings
group_sessions = "Session Times"
use_session_filter = input.bool(true, "Use Session Filtering", group=group_sessions)
use_cet_sessions = input.bool(false, "Use CET for Sessions", group=group_sessions, tooltip="True=CET time, False=ET time")
us_market_session = input.session("0930-1600", "US Market Session", group=group_sessions)
use_bullet_hours = input.bool(true, "Use Bullet Hours", group=group_sessions)
bullet_session = input.session("1430-1600", "Bullet Hours", group=group_sessions)
use_london_open = input.bool(true, "Use London Open", group=group_sessions)
london_session = input.session("0800-1000", "London Open", group=group_sessions)
use_power_hour = input.bool(true, "Use Power Hour", group=group_sessions)
power_session = input.session("1500-1600", "Power Hour", group=group_sessions)
use_overnight = input.bool(true, "Use Overnight Session", group=group_sessions)
overnight_session = input.session("1600-0930", "Overnight Session", group=group_sessions)

// Alert Settings
group_alerts = "Alerts"
enable_alerts = input.bool(true, "Enable Alerts", group=group_alerts)
enable_vwap_alerts = input.bool(true, "VWAP Bounce Alerts", group=group_alerts)
enable_volume_alerts = input.bool(true, "Volume Spike Alerts", group=group_alerts)
enable_sr_alerts = input.bool(true, "S/R Level Alerts", group=group_alerts)
volume_spike_multiplier = input.float(2.0, "Volume Spike Multiplier", minval=1.5, maxval=5.0, step=0.1, group=group_alerts, tooltip="Auto-adjusted: MES=2.5, MNQ=2.0")

// Apply instrument-specific overrides
final_volume_spike_multiplier = is_mes ? 2.5 : volume_spike_multiplier

// Color Settings
group_colors = "Colors"
strong_bullish_color = input.color(color.lime, "Strong Bullish", group=group_colors)
bullish_color = input.color(color.green, "Bullish", group=group_colors)
strong_bearish_color = input.color(color.red, "Strong Bearish", group=group_colors)
bearish_color = input.color(color.maroon, "Bearish", group=group_colors)
neutral_color = input.color(color.gray, "Neutral", group=group_colors)
poc_color = input.color(color.yellow, "POC Color", group=group_colors)
hvn_color = input.color(color.green, "HVN Color", group=group_colors)
lvn_color = input.color(color.red, "LVN Color", group=group_colors)
value_area_color = input.color(color.blue, "Value Area Color", group=group_colors)

// ========== VARIABLES ==========
var float poc_price = na
var float value_area_high = na
var float value_area_low = na
var float opening_range_high = na
var float opening_range_low = na
var bool or_set = false
var float session_vwap = na
var int or_bars_analyzed = 0
var float or_start_bar = na

// Opening Range drawing variables
var line or_high_line = na
var line or_low_line = na
var label or_label = na

// Volume Profile Arrays
var array<float> vp_prices = array.new<float>()
var array<float> vp_volumes = array.new<float>()

// ========== HELPER FUNCTIONS ==========

// Check if in session
in_session(sess) =>
    na(sess) ? false : time(timeframe.period, sess)

// Get typical price
get_typical_price() =>
    (high + low + close) / 3

// Calculate VWAP
calc_vwap(length) =>
    var float sum_pv = 0.0
    var float sum_v = 0.0
    
    if barstate.isfirst
        sum_pv := 0.0
        sum_v := 0.0
    
    typical_price = get_typical_price()
    sum_pv := sum_pv + (typical_price * volume)
    sum_v := sum_v + volume
    
    if bar_index > length
        old_typical = (high[length] + low[length] + close[length]) / 3
        sum_pv := sum_pv - (old_typical * volume[length])
        sum_v := sum_v - volume[length]
    
    sum_v > 0 ? sum_pv / sum_v : close

// Calculate VWAP Standard Deviation
calc_vwap_stddev(vwap_value, length) =>
    var float sum_v = 0.0
    var float variance = 0.0
    
    if barstate.isfirst
        sum_v := 0.0
    
    sum_v := sum_v + volume
    if bar_index > length
        sum_v := sum_v - volume[length]
    
    variance := 0.0
    for i = 0 to math.min(length - 1, bar_index)
        typical_price = (high[i] + low[i] + close[i]) / 3
        variance := variance + volume[i] * math.pow(typical_price - vwap_value, 2)
    
    sum_v > 0 ? math.sqrt(variance / sum_v) : 0.0

// Calculate Delta Strength - IMPROVED
calc_delta_strength() =>
    range_val = high - low
    close_relative = range_val > 0 ? (close - low) / range_val : 0.5
    
    is_green = close > open
    is_red = close < open
    is_outside = high > high[1] and low < low[1]
    
    delta = 0.0
    
    // Only color if volume meets minimum threshold
    if volume >= final_volume_threshold
        if is_green and close_relative > 0.75
            delta := volume * 2.0  // Strong bullish
        else if is_green and close_relative > 0.55
            delta := volume * 1.0  // Regular bullish
        else if is_red and close_relative < 0.25
            delta := -volume * 2.0  // Strong bearish
        else if is_red and close_relative < 0.45
            delta := -volume * 1.0  // Regular bearish
        else
            delta := 0  // Neutral - no significant bias
        
        // Boost for outside bars
        if is_outside and math.abs(delta) > 0
            delta := delta * 1.2
    
    delta

// Build Volume Profile - OPTIMIZED
build_volume_profile() =>
    local_poc = poc_price
    local_va_high = value_area_high
    local_va_low = value_area_low
    
    // Update less frequently to improve performance
    if bar_index % 50 == 0 and bar_index >= volume_profile_lookback
        array.clear(vp_prices)
        array.clear(vp_volumes)
        
        // Reduced lookback for performance
        lookback = math.min(100, volume_profile_lookback, bar_index)
        
        // Simplified volume profile - use close price only
        profile_map = map.new<float, float>()
        
        for i = 0 to lookback - 1
            if i > bar_index
                break
                
            bar_volume = volume[i]
            bar_close = close[i]
            
            // Skip invalid data
            if na(bar_volume) or na(bar_close) or bar_volume <= 0
                continue
            
            // Round to nearest tick for grouping
            price = math.round(bar_close / syminfo.mintick) * syminfo.mintick
            
            if not na(price)
                current_vol = map.get(profile_map, price)
                new_vol = na(current_vol) ? bar_volume : current_vol + bar_volume
                map.put(profile_map, price, new_vol)
        
        // Convert to arrays and find POC
        if map.size(profile_map) > 0
            max_volume = 0.0
            total_volume = 0.0
            
            for [price, vol] in profile_map
                if not na(price) and not na(vol) and vol > 0
                    array.push(vp_prices, price)
                    array.push(vp_volumes, vol)
                    total_volume := total_volume + vol
                    
                    if vol > max_volume
                        max_volume := vol
                        local_poc := price
            
            // Simplified Value Area calculation
            if array.size(vp_volumes) > 5 and total_volume > 0
                target_volume = total_volume * 0.7 // Fixed 70%
                
                // Find top 70% of volume without complex sorting
                high_vol_threshold = max_volume * 0.3 // Only consider significant volumes
                va_min = local_poc
                va_max = local_poc
                
                for i = 0 to array.size(vp_volumes) - 1
                    vol = array.get(vp_volumes, i)
                    price = array.get(vp_prices, i)
                    
                    if vol >= high_vol_threshold
                        va_min := math.min(va_min, price)
                        va_max := math.max(va_max, price)
                
                local_va_high := va_max
                local_va_low := va_min
    
    [local_poc, local_va_high, local_va_low]

// ========== MAIN CALCULATIONS ==========

// Session checks with timezone support
session_tz = use_cet_sessions ? "Europe/Warsaw" : "America/New_York"

in_us_session = time(timeframe.period, us_market_session, session_tz)
in_bullet = use_bullet_hours ? time(timeframe.period, bullet_session, session_tz) : na
in_london = use_london_open ? time(timeframe.period, london_session, session_tz) : na
in_power = use_power_hour ? time(timeframe.period, power_session, session_tz) : na
in_overnight = use_overnight ? time(timeframe.period, overnight_session, session_tz) : na

// Convert to boolean
in_us_session_bool = not na(in_us_session)
in_bullet_bool = not na(in_bullet)
in_london_bool = not na(in_london)
in_power_bool = not na(in_power)
in_overnight_bool = not na(in_overnight)

in_active_session = use_session_filter ? (in_us_session_bool or in_bullet_bool or in_london_bool or in_power_bool or in_overnight_bool) : true

// Opening Range Calculation
var int or_start_time_ms = na
var bool or_collecting = false
var int or_bars_in_range = 0

if enable_opening_range
    // Use CET or ET timezone
    or_timezone = use_cet_time ? "Europe/Warsaw" : "America/New_York"
    
    // Create start time for today
    today_or_start = timestamp(or_timezone, year, month, dayofmonth, or_start_hour, or_start_minute, 0)
    or_end_time = today_or_start + (final_or_duration * 60 * 1000)
    
    // Check if current bar is at OR start
    if time >= today_or_start and time[1] < today_or_start
        opening_range_high := high
        opening_range_low := low
        or_set := false
        or_collecting := true
        or_start_bar := bar_index
        or_bars_in_range := 1
        or_start_time_ms := int(today_or_start)
    
    // Collect bars during OR period
    if or_collecting and time >= today_or_start and time < or_end_time
        opening_range_high := math.max(opening_range_high, high)
        opening_range_low := math.min(opening_range_low, low)
        if time != time[1]
            or_bars_in_range := or_bars_in_range + 1
    
    // End OR period
    if or_collecting and time >= or_end_time
        or_set := true
        or_collecting := false
        or_bars_analyzed := or_bars_in_range

// VWAP Calculation
vwap_value = show_vwap ? calc_vwap(100) : na
vwap_stddev = show_vwap ? calc_vwap_stddev(vwap_value, 100) : na

vwap_upper1 = vwap_value + vwap_stddev
vwap_lower1 = vwap_value - vwap_stddev
vwap_upper2 = vwap_value + (2 * vwap_stddev)
vwap_lower2 = vwap_value - (2 * vwap_stddev)

// Delta Analysis
delta_strength = calc_delta_strength()

// Volume Profile
if enable_volume_profile
    [new_poc, new_va_high, new_va_low] = build_volume_profile()
    poc_price := new_poc
    value_area_high := new_va_high
    value_area_low := new_va_low

// Volume Analysis
avg_volume = ta.sma(volume, 20)
high_volume_bar = volume >= (avg_volume * 2.0)

// ========== PLOTTING ==========

// VWAP Lines
plot(show_vwap ? vwap_value : na, "VWAP", color=color.yellow, linewidth=2)
plot(show_stddev1 ? vwap_upper1 : na, "VWAP +1σ", color=color.orange, linewidth=1)
plot(show_stddev1 ? vwap_lower1 : na, "VWAP -1σ", color=color.orange, linewidth=1)
plot(show_stddev2 ? vwap_upper2 : na, "VWAP +2σ", color=color.red, linewidth=1)
plot(show_stddev2 ? vwap_lower2 : na, "VWAP -2σ", color=color.red, linewidth=1)

// Point of Control
plot(show_poc and not na(poc_price) ? poc_price : na, "POC", color=poc_color, linewidth=3, style=plot.style_line)

// Value Area
plot(show_value_area and not na(value_area_high) ? value_area_high : na, "VA High", color=value_area_color, linewidth=1, style=plot.style_line)
plot(show_value_area and not na(value_area_low) ? value_area_low : na, "VA Low", color=value_area_color, linewidth=1, style=plot.style_line)

// ========== CANDLE COLORING ==========
candle_color = neutral_color  // Default to neutral

if enable_delta_coloring
    abs_delta = math.abs(delta_strength)
    
    if abs_delta >= final_strong_threshold
        // Strong coloring - only for very high volume bars
        candle_color := delta_strength > 0 ? strong_bullish_color : strong_bearish_color
    else if abs_delta >= final_volume_threshold and abs_delta > 0
        // Regular coloring - medium volume bars
        candle_color := delta_strength > 0 ? bullish_color : bearish_color
    else
        // Neutral - low volume or no clear bias
        candle_color := neutral_color

barcolor(enable_delta_coloring ? candle_color : na, title="Delta Colors")

// ========== SESSION BACKGROUNDS ==========
bgcolor(use_session_filter and in_us_session_bool ? color.new(color.blue, 95) : na, title="US Market Hours")
bgcolor(use_bullet_hours and in_bullet_bool ? color.new(color.yellow, 90) : na, title="Bullet Hours")
bgcolor(use_london_open and in_london_bool ? color.new(color.green, 90) : na, title="London Open") 
bgcolor(use_power_hour and in_power_bool ? color.new(color.purple, 90) : na, title="Power Hour")
bgcolor(use_overnight and in_overnight_bool ? color.new(color.gray, 95) : na, title="Overnight Session")

// ========== OPENING RANGE DRAWING ==========
if enable_opening_range and or_set and barstate.islast and not na(or_start_bar)
    // Delete old lines and labels
    if not na(or_high_line)
        line.delete(or_high_line)
    if not na(or_low_line)
        line.delete(or_low_line)
    if not na(or_label)
        label.delete(or_label)
    
    start_bar = int(or_start_bar)
    
    // Calculate end of trading day (market close)
    or_timezone = use_cet_time ? "Europe/Warsaw" : "America/New_York"
    market_close_hour = use_cet_time ? 22 : 16  // 22:00 CET or 16:00 ET
    today_market_close = timestamp(or_timezone, year, month, dayofmonth, market_close_hour, 0, 0)
    
    // Find bar index closest to market close
    end_bar = bar_index
    for i = 0 to 100
        if bar_index - i >= 0 and time[i] <= today_market_close
            end_bar := bar_index - i
            break
    
    // Create horizontal lines that end at market close
    or_high_line := line.new(start_bar, opening_range_high, end_bar, opening_range_high, color=color.blue, width=2)
    or_low_line := line.new(start_bar, opening_range_low, end_bar, opening_range_low, color=color.blue, width=2)
    
    // Add label with OR info - OPTIONAL
    if show_or_info
        or_range = opening_range_high - opening_range_low
        timezone_text = use_cet_time ? "CET" : "ET"
        or_text = "OR (" + str.tostring(final_or_duration) + "m, " + str.tostring(or_bars_analyzed) + " bars, " + timezone_text + ")\nH: " + str.tostring(opening_range_high, "#.##") + "\nL: " + str.tostring(opening_range_low, "#.##") + "\nRange: " + str.tostring(or_range, "#.##")
        or_label := label.new(end_bar, opening_range_high + (or_range * 0.1), or_text, color=color.blue, textcolor=color.white, size=size.small, style=label.style_label_down)
    else
        or_label := na  // Ensure label is set to na when not showing

// ========== ALERTS ==========
// VWAP Bounce Alert
vwap_distance = math.abs(close - vwap_value)
vwap_tolerance = vwap_value * 0.001
if enable_alerts and enable_vwap_alerts and vwap_distance <= vwap_tolerance and volume > final_volume_threshold
    alert("VWAP Bounce Setup! Price: " + str.tostring(close), alert.freq_once_per_bar)

// Volume Spike Alert
if enable_alerts and enable_volume_alerts and volume >= (avg_volume * final_volume_spike_multiplier)
    alert("Volume Spike Detected! Volume: " + str.tostring(volume), alert.freq_once_per_bar)

// Opening Range Breakout Alert
if enable_alerts and enable_opening_range and or_set
    if close > opening_range_high
        alert("Opening Range Upside Breakout! Price: " + str.tostring(close), alert.freq_once_per_bar)
    if close < opening_range_low
        alert("Opening Range Downside Breakout! Price: " + str.tostring(close), alert.freq_once_per_bar)

// S/R Level Alerts
if enable_alerts and enable_sr_alerts and not na(poc_price)
    if math.abs(close - poc_price) <= syminfo.mintick * 2
        alert("Price at Point of Control! Level: " + str.tostring(poc_price), alert.freq_once_per_bar)

// ========== INFO TABLE ==========
if barstate.islast and enable_volume_profile and show_info_table
    var table info_table = table.new(position.top_right, 2, 9, bgcolor=color.white, border_width=1)
    
    // Instrument detection info
    instrument_bg = is_mes ? color.orange : color.blue
    table.cell(info_table, 0, 0, "Instrument", bgcolor=color.gray, text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, current_instrument, bgcolor=instrument_bg, text_color=color.white, text_size=size.small)
    
    if not na(poc_price)
        table.cell(info_table, 0, 1, "POC Price", bgcolor=color.gray, text_color=color.white, text_size=size.small)
        table.cell(info_table, 1, 1, str.tostring(poc_price, "#.##"), bgcolor=color.white, text_color=color.black, text_size=size.small)
    
    if not na(value_area_high) and not na(value_area_low)
        table.cell(info_table, 0, 2, "VA High", bgcolor=color.gray, text_color=color.white, text_size=size.small)
        table.cell(info_table, 1, 2, str.tostring(value_area_high, "#.##"), bgcolor=color.white, text_color=color.black, text_size=size.small)
        table.cell(info_table, 0, 3, "VA Low", bgcolor=color.gray, text_color=color.white, text_size=size.small)
        table.cell(info_table, 1, 3, str.tostring(value_area_low, "#.##"), bgcolor=color.white, text_color=color.black, text_size=size.small)
    
    table.cell(info_table, 0, 4, "Volume", bgcolor=color.gray, text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 4, str.tostring(volume), bgcolor=color.white, text_color=color.black, text_size=size.small)
    
    table.cell(info_table, 0, 5, "Avg Volume", bgcolor=color.gray, text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 5, str.tostring(avg_volume, "#"), bgcolor=color.white, text_color=color.black, text_size=size.small)
    
    // Volume Ratio with color-coded thresholds
    volume_ratio = avg_volume > 0 ? volume / avg_volume : 0
    ratio_text = str.tostring(volume_ratio, "#.##") + "x"
    
    // Color coding based on volume ratio thresholds
    ratio_color = color.white
    ratio_text_color = color.black
    
    if volume_ratio >= 2.0
        ratio_color := color.red  // High volume - strong signal
        ratio_text_color := color.white
        ratio_text := ratio_text + " HIGH"
    else if volume_ratio >= 1.5
        ratio_color := color.orange  // Above average - moderate signal
        ratio_text_color := color.white
        ratio_text := ratio_text + " MED+"
    else if volume_ratio >= 1.0
        ratio_color := color.yellow  // Average - normal activity
        ratio_text_color := color.black
        ratio_text := ratio_text + " AVG"
    else if volume_ratio >= 0.5
        ratio_color := color.silver  // Below average - low activity
        ratio_text_color := color.black
        ratio_text := ratio_text + " LOW"
    else
        ratio_color := color.gray  // Very low - minimal activity
        ratio_text_color := color.white
        ratio_text := ratio_text + " MIN"
    
    table.cell(info_table, 0, 6, "Vol Ratio", bgcolor=color.gray, text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 6, ratio_text, bgcolor=ratio_color, text_color=ratio_text_color, text_size=size.small)
    
    // Session status with priority logic
    session_text = "INACTIVE"
    session_color = color.red
    
    if in_power_bool
        session_text := "POWER"
        session_color := color.purple
    else if in_bullet_bool
        session_text := "BULLET"  
        session_color := color.yellow
    else if in_us_session_bool
        session_text := "US MARKET"
        session_color := color.blue
    else if in_london_bool
        session_text := "LONDON"
        session_color := color.green
    else if in_overnight_bool
        session_text := "OVERNIGHT"
        session_color := color.gray
    
    table.cell(info_table, 0, 7, "Session", bgcolor=color.gray, text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 7, session_text, bgcolor=session_color, text_color=color.white, text_size=size.small)
    
    // Delta Strength indicator
    delta_abs = math.abs(delta_strength)
    delta_text = str.tostring(delta_abs, "#")
    delta_bg_color = color.white
    delta_txt_color = color.black
    
    if delta_abs >= final_strong_threshold
        delta_bg_color := delta_strength > 0 ? strong_bullish_color : strong_bearish_color
        delta_txt_color := color.white
        delta_text := delta_text + (delta_strength > 0 ? " BULL+" : " BEAR+")
    else if delta_abs >= final_volume_threshold and delta_abs > 0
        delta_bg_color := delta_strength > 0 ? bullish_color : bearish_color
        delta_txt_color := color.white
        delta_text := delta_text + (delta_strength > 0 ? " BULL" : " BEAR")
    else
        delta_bg_color := neutral_color
        delta_txt_color := color.white
        delta_text := delta_text + " NEUT"
    
    table.cell(info_table, 0, 8, "Delta", bgcolor=color.gray, text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 8, delta_text, bgcolor=delta_bg_color, text_color=delta_txt_color, text_size=size.small)

// ========== DEBUG PLOTS ==========
plot(in_us_session_bool ? 1 : 0, "US Session", color=color.blue, display=display.data_window)
plot(in_bullet_bool ? 1 : 0, "Bullet Session", color=color.yellow, display=display.data_window)
plot(in_overnight_bool ? 1 : 0, "Overnight Session", color=color.gray, display=display.data_window)
plot(enable_opening_range and or_collecting ? 100 : 0, "OR Collecting", color=color.lime, display=display.data_window)
plot(enable_opening_range ? or_bars_in_range : na, "Bars in Range", color=color.orange, display=display.data_window)
plot(math.abs(delta_strength), "Delta Strength", color=color.yellow, display=display.data_window)
plot(volume, "Current Volume", color=color.aqua, display=display.data_window)
plot(final_volume_threshold, "Volume Threshold", color=color.purple, display=display.data_window)
plot(final_strong_threshold, "Strong Threshold", color=color.red, display=display.data_window)
